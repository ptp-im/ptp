// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PTP.Common.proto

#ifndef PROTOBUF_INCLUDED_PTP_2eCommon_2eproto
#define PROTOBUF_INCLUDED_PTP_2eCommon_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_PTP_2eCommon_2eproto 

namespace protobuf_PTP_2eCommon_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_PTP_2eCommon_2eproto
namespace PTP {
namespace Common {
class BuddyQueryParam;
class BuddyQueryParamDefaultTypeInternal;
extern BuddyQueryParamDefaultTypeInternal _BuddyQueryParam_default_instance_;
class DevicesInfo;
class DevicesInfoDefaultTypeInternal;
extern DevicesInfoDefaultTypeInternal _DevicesInfo_default_instance_;
class GroupInfo;
class GroupInfoDefaultTypeInternal;
extern GroupInfoDefaultTypeInternal _GroupInfo_default_instance_;
class GroupMember;
class GroupMemberDefaultTypeInternal;
extern GroupMemberDefaultTypeInternal _GroupMember_default_instance_;
class GroupRecord;
class GroupRecordDefaultTypeInternal;
extern GroupRecordDefaultTypeInternal _GroupRecord_default_instance_;
class InputPhoneContact;
class InputPhoneContactDefaultTypeInternal;
extern InputPhoneContactDefaultTypeInternal _InputPhoneContact_default_instance_;
class IpAddress;
class IpAddressDefaultTypeInternal;
extern IpAddressDefaultTypeInternal _IpAddress_default_instance_;
class MsgInfo;
class MsgInfoDefaultTypeInternal;
extern MsgInfoDefaultTypeInternal _MsgInfo_default_instance_;
class MsgInfoList;
class MsgInfoListDefaultTypeInternal;
extern MsgInfoListDefaultTypeInternal _MsgInfoList_default_instance_;
class UserInfo;
class UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class UserStatInfo;
class UserStatInfoDefaultTypeInternal;
extern UserStatInfoDefaultTypeInternal _UserStatInfo_default_instance_;
}  // namespace Common
}  // namespace PTP
namespace google {
namespace protobuf {
template<> ::PTP::Common::BuddyQueryParam* Arena::CreateMaybeMessage<::PTP::Common::BuddyQueryParam>(Arena*);
template<> ::PTP::Common::DevicesInfo* Arena::CreateMaybeMessage<::PTP::Common::DevicesInfo>(Arena*);
template<> ::PTP::Common::GroupInfo* Arena::CreateMaybeMessage<::PTP::Common::GroupInfo>(Arena*);
template<> ::PTP::Common::GroupMember* Arena::CreateMaybeMessage<::PTP::Common::GroupMember>(Arena*);
template<> ::PTP::Common::GroupRecord* Arena::CreateMaybeMessage<::PTP::Common::GroupRecord>(Arena*);
template<> ::PTP::Common::InputPhoneContact* Arena::CreateMaybeMessage<::PTP::Common::InputPhoneContact>(Arena*);
template<> ::PTP::Common::IpAddress* Arena::CreateMaybeMessage<::PTP::Common::IpAddress>(Arena*);
template<> ::PTP::Common::MsgInfo* Arena::CreateMaybeMessage<::PTP::Common::MsgInfo>(Arena*);
template<> ::PTP::Common::MsgInfoList* Arena::CreateMaybeMessage<::PTP::Common::MsgInfoList>(Arena*);
template<> ::PTP::Common::UserInfo* Arena::CreateMaybeMessage<::PTP::Common::UserInfo>(Arena*);
template<> ::PTP::Common::UserStatInfo* Arena::CreateMaybeMessage<::PTP::Common::UserStatInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace PTP {
namespace Common {

enum SID {
  S_AUTH = 1,
  S_BUDDY = 2,
  S_MSG = 3,
  S_GROUP = 4,
  S_FILE = 5,
  S_SERVER = 6,
  S_OTHER = 7,
  S_SWITCH = 8
};
bool SID_IsValid(int value);
const SID SID_MIN = S_AUTH;
const SID SID_MAX = S_SWITCH;
const int SID_ARRAYSIZE = SID_MAX + 1;

enum CID_AUTH {
  CID_AuthLoginReq = 257,
  CID_AuthLoginRes = 258,
  CID_AuthLogoutReq = 259,
  CID_AuthLogoutRes = 260,
  CID_AuthCaptchaReq = 261,
  CID_AuthCaptchaRes = 262
};
bool CID_AUTH_IsValid(int value);
const CID_AUTH CID_AUTH_MIN = CID_AuthLoginReq;
const CID_AUTH CID_AUTH_MAX = CID_AuthCaptchaRes;
const int CID_AUTH_ARRAYSIZE = CID_AUTH_MAX + 1;

enum CID_BUDDY {
  CID_BuddyStatNotify = 513,
  CID_BuddyGetListReq = 514,
  CID_BuddyGetListRes = 515,
  CID_BuddyGetALLReq = 516,
  CID_BuddyGetALLRes = 517,
  CID_BuddyGetStatReq = 518,
  CID_BuddyGetStatRes = 519,
  CID_BuddyModifyReq = 520,
  CID_BuddyModifyRes = 521,
  CID_BuddyModifyNotify = 522,
  CID_BuddyModifyUpdatePair = 523,
  CID_BuddyImportContactsReq = 524,
  CID_BuddyImportContactsRes = 525,
  CID_BuddyQueryListReq = 526,
  CID_BuddyQueryListRes = 527
};
bool CID_BUDDY_IsValid(int value);
const CID_BUDDY CID_BUDDY_MIN = CID_BuddyStatNotify;
const CID_BUDDY CID_BUDDY_MAX = CID_BuddyQueryListRes;
const int CID_BUDDY_ARRAYSIZE = CID_BUDDY_MAX + 1;

enum CID_MSG {
  CID_MsgReq = 769,
  CID_MsgRes = 770,
  CID_MsgReadAckReq = 771,
  CID_MsgReadNotify = 772,
  CID_MsgGetMaxIdReq = 773,
  CID_MsgGetMaxIdRes = 774,
  CID_MsgGetByIdsReq = 775,
  CID_MsgGetByIdsRes = 776,
  CID_MsgNotify = 777,
  CID_MsgUnNotify = 778
};
bool CID_MSG_IsValid(int value);
const CID_MSG CID_MSG_MIN = CID_MsgReq;
const CID_MSG CID_MSG_MAX = CID_MsgUnNotify;
const int CID_MSG_ARRAYSIZE = CID_MSG_MAX + 1;

enum CID_GROUP {
  CID_GroupPreCreateReq = 1025,
  CID_GroupPreCreateRes = 1026,
  CID_GroupCreateReq = 1027,
  CID_GroupCreateRes = 1028,
  CID_GroupModifyReq = 1029,
  CID_GroupModifyRes = 1030,
  CID_GroupModifyNotify = 1031,
  CID_GroupChangeMemberReq = 1032,
  CID_GroupChangeMemberRes = 1033,
  CID_GroupChangeMemberNotify = 1034,
  CID_GroupGetListReq = 1035,
  CID_GroupGetListRes = 1036,
  CID_GroupUnreadMsgReq = 1037,
  CID_GroupUnreadMsgRes = 1038,
  CID_GroupRemoveSessionReq = 1039,
  CID_GroupRemoveSessionRes = 1041,
  CID_GroupRemoveSessionNotify = 1042,
  CID_GroupGetMembersListReq = 1043,
  CID_GroupGetMembersListRes = 1044
};
bool CID_GROUP_IsValid(int value);
const CID_GROUP CID_GROUP_MIN = CID_GroupPreCreateReq;
const CID_GROUP CID_GROUP_MAX = CID_GroupGetMembersListRes;
const int CID_GROUP_ARRAYSIZE = CID_GROUP_MAX + 1;

enum CID_FILE {
  CID_FileImgUploadReq = 1281,
  CID_FileImgUploadRes = 1282,
  CID_FileImgDownloadReq = 1283,
  CID_FileImgDownloadRes = 1284
};
bool CID_FILE_IsValid(int value);
const CID_FILE CID_FILE_MIN = CID_FileImgUploadReq;
const CID_FILE CID_FILE_MAX = CID_FileImgDownloadRes;
const int CID_FILE_ARRAYSIZE = CID_FILE_MAX + 1;

enum CID_SERVER {
  CID_ServerLoginReq = 1537,
  CID_ServerLoginRes = 1538
};
bool CID_SERVER_IsValid(int value);
const CID_SERVER CID_SERVER_MIN = CID_ServerLoginReq;
const CID_SERVER CID_SERVER_MAX = CID_ServerLoginRes;
const int CID_SERVER_ARRAYSIZE = CID_SERVER_MAX + 1;

enum CID_OTHER {
  CID_HeartBeatNotify = 1793,
  CID_CaptchaReq = 1794,
  CID_CaptchaRes = 1795
};
bool CID_OTHER_IsValid(int value);
const CID_OTHER CID_OTHER_MIN = CID_HeartBeatNotify;
const CID_OTHER CID_OTHER_MAX = CID_CaptchaRes;
const int CID_OTHER_ARRAYSIZE = CID_OTHER_MAX + 1;

enum CID_SWITCH {
  CID_SwitchPtpReq = 2049,
  CID_SwitchPtpRes = 2050,
  CID_SwitchPtpNotify = 2051,
  CID_SwitchDevicesReq = 2052,
  CID_SwitchDevicesNotify = 2053
};
bool CID_SWITCH_IsValid(int value);
const CID_SWITCH CID_SWITCH_MIN = CID_SwitchPtpReq;
const CID_SWITCH CID_SWITCH_MAX = CID_SwitchDevicesNotify;
const int CID_SWITCH_ARRAYSIZE = CID_SWITCH_MAX + 1;

enum QRCODE_TYPE {
  QRCODE_TYPE_MNEMONIC_SHARE = 1,
  QRCODE_TYPE_NAME_CARD = 2
};
bool QRCODE_TYPE_IsValid(int value);
const QRCODE_TYPE QRCODE_TYPE_MIN = QRCODE_TYPE_MNEMONIC_SHARE;
const QRCODE_TYPE QRCODE_TYPE_MAX = QRCODE_TYPE_NAME_CARD;
const int QRCODE_TYPE_ARRAYSIZE = QRCODE_TYPE_MAX + 1;

enum ERR {
  NO_ERROR = 0,
  E_SYSTEM = 1,
  E_GROUP_CREATE_PAIR_GROUP_MEMBER_SIE_INVALID = 2,
  E_GROUP_CREATE_PAIR_GROUP_NO_REG_USER = 3,
  E_GROUP_HAS_CREATED = 4,
  E_REASON_NO_ROUTE_SERVER = 5,
  E_REASON_NO_LOGIN_SERVER = 6,
  E_REASON_NO_DB_SERVER = 7,
  E_LOGIN_ERROR = 8,
  E_PB_PARSE_ERROR = 9,
  E_SWITCH_USER_NO_ONLINE = 10,
  E_USERNAME_EXISTS = 11,
  E_USERNAME_INVALID = 12,
  E_CLIENT = 1003,
  E_CLIENT_TIMEOUT = 1004,
  E_SERVER_NOT_FOUND = 404
};
bool ERR_IsValid(int value);
const ERR ERR_MIN = NO_ERROR;
const ERR ERR_MAX = E_CLIENT_TIMEOUT;
const int ERR_ARRAYSIZE = ERR_MAX + 1;

enum SwitchType {
  SwitchType_Apply = 1,
  SwitchType_Offer = 2,
  SwitchType_Answer = 3,
  SwitchType_Candidate = 4,
  SwitchType_Ready = 5,
  SwitchType_Bye = 6
};
bool SwitchType_IsValid(int value);
const SwitchType SwitchType_MIN = SwitchType_Apply;
const SwitchType SwitchType_MAX = SwitchType_Bye;
const int SwitchType_ARRAYSIZE = SwitchType_MAX + 1;

enum UserStat {
  USER_STAT_ONLINE = 1,
  USER_STAT_OFFLINE = 2,
  USER_STAT_LEAVE = 3
};
bool UserStat_IsValid(int value);
const UserStat UserStat_MIN = USER_STAT_ONLINE;
const UserStat UserStat_MAX = USER_STAT_LEAVE;
const int UserStat_ARRAYSIZE = UserStat_MAX + 1;

enum MsgType {
  MSG_TYPE_TEXT = 1,
  MSG_TYPE_AUDIO = 2
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = MSG_TYPE_TEXT;
const MsgType MsgType_MAX = MSG_TYPE_AUDIO;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

enum ClientType {
  CLIENT_TYPE_WEB = 1,
  CLIENT_TYPE_PC = 2,
  CLIENT_TYPE_MAC = 3,
  CLIENT_TYPE_IOS = 17,
  CLIENT_TYPE_ANDROID = 18
};
bool ClientType_IsValid(int value);
const ClientType ClientType_MIN = CLIENT_TYPE_WEB;
const ClientType ClientType_MAX = CLIENT_TYPE_ANDROID;
const int ClientType_ARRAYSIZE = ClientType_MAX + 1;

enum SessionStat {
  SESSION_STAT_OK = 0,
  SESSION_STAT_DELETE = 1
};
bool SessionStat_IsValid(int value);
const SessionStat SessionStat_MIN = SESSION_STAT_OK;
const SessionStat SessionStat_MAX = SESSION_STAT_DELETE;
const int SessionStat_ARRAYSIZE = SessionStat_MAX + 1;

enum ShieldStatus {
  SHIELD_STATUS_OK = 0,
  SHIELD_STATUS_DELETE = 1
};
bool ShieldStatus_IsValid(int value);
const ShieldStatus ShieldStatus_MIN = SHIELD_STATUS_OK;
const ShieldStatus ShieldStatus_MAX = SHIELD_STATUS_DELETE;
const int ShieldStatus_ARRAYSIZE = ShieldStatus_MAX + 1;

enum BuddyModifyAction {
  BuddyModifyAction_nickname = 1,
  BuddyModifyAction_avatar = 2,
  BuddyModifyAction_sign_info = 3,
  BuddyModifyAction_user_name = 4,
  BuddyModifyAction_first_name = 5,
  BuddyModifyAction_last_name = 6
};
bool BuddyModifyAction_IsValid(int value);
const BuddyModifyAction BuddyModifyAction_MIN = BuddyModifyAction_nickname;
const BuddyModifyAction BuddyModifyAction_MAX = BuddyModifyAction_last_name;
const int BuddyModifyAction_ARRAYSIZE = BuddyModifyAction_MAX + 1;

enum GroupType {
  GROUP_TYPE_PAIR = 1,
  GROUP_TYPE_MULTI = 2
};
bool GroupType_IsValid(int value);
const GroupType GroupType_MIN = GROUP_TYPE_PAIR;
const GroupType GroupType_MAX = GROUP_TYPE_MULTI;
const int GroupType_ARRAYSIZE = GroupType_MAX + 1;

enum GroupMemberStatus {
  GROUP_MEMBER_STATUS_NORMAL = 1
};
bool GroupMemberStatus_IsValid(int value);
const GroupMemberStatus GroupMemberStatus_MIN = GROUP_MEMBER_STATUS_NORMAL;
const GroupMemberStatus GroupMemberStatus_MAX = GROUP_MEMBER_STATUS_NORMAL;
const int GroupMemberStatus_ARRAYSIZE = GroupMemberStatus_MAX + 1;

enum GroupModifyAction {
  GroupModifyAction_name = 1,
  GroupModifyAction_avatar = 2
};
bool GroupModifyAction_IsValid(int value);
const GroupModifyAction GroupModifyAction_MIN = GroupModifyAction_name;
const GroupModifyAction GroupModifyAction_MAX = GroupModifyAction_avatar;
const int GroupModifyAction_ARRAYSIZE = GroupModifyAction_MAX + 1;

enum GroupMemberModifyAction {
  GroupMemberModifyAction_DEL = 1,
  GroupMemberModifyAction_ADD = 2
};
bool GroupMemberModifyAction_IsValid(int value);
const GroupMemberModifyAction GroupMemberModifyAction_MIN = GroupMemberModifyAction_DEL;
const GroupMemberModifyAction GroupMemberModifyAction_MAX = GroupMemberModifyAction_ADD;
const int GroupMemberModifyAction_ARRAYSIZE = GroupMemberModifyAction_MAX + 1;

// ===================================================================

class IpAddress : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.IpAddress) */ {
 public:
  IpAddress();
  virtual ~IpAddress();

  IpAddress(const IpAddress& from);

  inline IpAddress& operator=(const IpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IpAddress(IpAddress&& from) noexcept
    : IpAddress() {
    *this = ::std::move(from);
  }

  inline IpAddress& operator=(IpAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IpAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IpAddress* internal_default_instance() {
    return reinterpret_cast<const IpAddress*>(
               &_IpAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(IpAddress* other);
  friend void swap(IpAddress& a, IpAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IpAddress* New() const final {
    return CreateMaybeMessage<IpAddress>(NULL);
  }

  IpAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IpAddress>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IpAddress& from);
  void MergeFrom(const IpAddress& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IpAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PTP.Common.IpAddress)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::uint32 port_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.UserInfo) */ {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const UserInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(UserInfo* other);
  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserInfo* New() const final {
    return CreateMaybeMessage<UserInfo>(NULL);
  }

  UserInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // required bytes pub_key = 2;
  bool has_pub_key() const;
  void clear_pub_key();
  static const int kPubKeyFieldNumber = 2;
  const ::std::string& pub_key() const;
  void set_pub_key(const ::std::string& value);
  #if LANG_CXX11
  void set_pub_key(::std::string&& value);
  #endif
  void set_pub_key(const char* value);
  void set_pub_key(const void* value, size_t size);
  ::std::string* mutable_pub_key();
  ::std::string* release_pub_key();
  void set_allocated_pub_key(::std::string* pub_key);

  // required string avatar = 3;
  bool has_avatar() const;
  void clear_avatar();
  static const int kAvatarFieldNumber = 3;
  const ::std::string& avatar() const;
  void set_avatar(const ::std::string& value);
  #if LANG_CXX11
  void set_avatar(::std::string&& value);
  #endif
  void set_avatar(const char* value);
  void set_avatar(const char* value, size_t size);
  ::std::string* mutable_avatar();
  ::std::string* release_avatar();
  void set_allocated_avatar(::std::string* avatar);

  // optional string user_name = 5;
  bool has_user_name() const;
  void clear_user_name();
  static const int kUserNameFieldNumber = 5;
  const ::std::string& user_name() const;
  void set_user_name(const ::std::string& value);
  #if LANG_CXX11
  void set_user_name(::std::string&& value);
  #endif
  void set_user_name(const char* value);
  void set_user_name(const char* value, size_t size);
  ::std::string* mutable_user_name();
  ::std::string* release_user_name();
  void set_allocated_user_name(::std::string* user_name);

  // optional string nick_name = 6;
  bool has_nick_name() const;
  void clear_nick_name();
  static const int kNickNameFieldNumber = 6;
  const ::std::string& nick_name() const;
  void set_nick_name(const ::std::string& value);
  #if LANG_CXX11
  void set_nick_name(::std::string&& value);
  #endif
  void set_nick_name(const char* value);
  void set_nick_name(const char* value, size_t size);
  ::std::string* mutable_nick_name();
  ::std::string* release_nick_name();
  void set_allocated_nick_name(::std::string* nick_name);

  // optional string sign_info = 7;
  bool has_sign_info() const;
  void clear_sign_info();
  static const int kSignInfoFieldNumber = 7;
  const ::std::string& sign_info() const;
  void set_sign_info(const ::std::string& value);
  #if LANG_CXX11
  void set_sign_info(::std::string&& value);
  #endif
  void set_sign_info(const char* value);
  void set_sign_info(const char* value, size_t size);
  ::std::string* mutable_sign_info();
  ::std::string* release_sign_info();
  void set_allocated_sign_info(::std::string* sign_info);

  // optional string first_name = 9;
  bool has_first_name() const;
  void clear_first_name();
  static const int kFirstNameFieldNumber = 9;
  const ::std::string& first_name() const;
  void set_first_name(const ::std::string& value);
  #if LANG_CXX11
  void set_first_name(::std::string&& value);
  #endif
  void set_first_name(const char* value);
  void set_first_name(const char* value, size_t size);
  ::std::string* mutable_first_name();
  ::std::string* release_first_name();
  void set_allocated_first_name(::std::string* first_name);

  // optional string last_name = 10;
  bool has_last_name() const;
  void clear_last_name();
  static const int kLastNameFieldNumber = 10;
  const ::std::string& last_name() const;
  void set_last_name(const ::std::string& value);
  #if LANG_CXX11
  void set_last_name(::std::string&& value);
  #endif
  void set_last_name(const char* value);
  void set_last_name(const char* value, size_t size);
  ::std::string* mutable_last_name();
  ::std::string* release_last_name();
  void set_allocated_last_name(::std::string* last_name);

  // required uint32 status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // required uint32 uid = 8;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 8;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // optional uint32 login_time = 11;
  bool has_login_time() const;
  void clear_login_time();
  static const int kLoginTimeFieldNumber = 11;
  ::google::protobuf::uint32 login_time() const;
  void set_login_time(::google::protobuf::uint32 value);

  // optional bool is_online = 12;
  bool has_is_online() const;
  void clear_is_online();
  static const int kIsOnlineFieldNumber = 12;
  bool is_online() const;
  void set_is_online(bool value);

  // @@protoc_insertion_point(class_scope:PTP.Common.UserInfo)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_pub_key();
  void clear_has_pub_key();
  void set_has_avatar();
  void clear_has_avatar();
  void set_has_status();
  void clear_has_status();
  void set_has_user_name();
  void clear_has_user_name();
  void set_has_nick_name();
  void clear_has_nick_name();
  void set_has_sign_info();
  void clear_has_sign_info();
  void set_has_uid();
  void clear_has_uid();
  void set_has_first_name();
  void clear_has_first_name();
  void set_has_last_name();
  void clear_has_last_name();
  void set_has_login_time();
  void clear_has_login_time();
  void set_has_is_online();
  void clear_has_is_online();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr pub_key_;
  ::google::protobuf::internal::ArenaStringPtr avatar_;
  ::google::protobuf::internal::ArenaStringPtr user_name_;
  ::google::protobuf::internal::ArenaStringPtr nick_name_;
  ::google::protobuf::internal::ArenaStringPtr sign_info_;
  ::google::protobuf::internal::ArenaStringPtr first_name_;
  ::google::protobuf::internal::ArenaStringPtr last_name_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 login_time_;
  bool is_online_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserStatInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.UserStatInfo) */ {
 public:
  UserStatInfo();
  virtual ~UserStatInfo();

  UserStatInfo(const UserStatInfo& from);

  inline UserStatInfo& operator=(const UserStatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserStatInfo(UserStatInfo&& from) noexcept
    : UserStatInfo() {
    *this = ::std::move(from);
  }

  inline UserStatInfo& operator=(UserStatInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const UserStatInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserStatInfo* internal_default_instance() {
    return reinterpret_cast<const UserStatInfo*>(
               &_UserStatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UserStatInfo* other);
  friend void swap(UserStatInfo& a, UserStatInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserStatInfo* New() const final {
    return CreateMaybeMessage<UserStatInfo>(NULL);
  }

  UserStatInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserStatInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const UserStatInfo& from);
  void MergeFrom(const UserStatInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserStatInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // required .PTP.Common.UserStat status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::PTP::Common::UserStat status() const;
  void set_status(::PTP::Common::UserStat value);

  // @@protoc_insertion_point(class_scope:PTP.Common.UserStatInfo)
 private:
  void set_has_uid();
  void clear_has_uid();
  void set_has_status();
  void clear_has_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 uid_;
  int status_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgInfoList : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.MsgInfoList) */ {
 public:
  MsgInfoList();
  virtual ~MsgInfoList();

  MsgInfoList(const MsgInfoList& from);

  inline MsgInfoList& operator=(const MsgInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgInfoList(MsgInfoList&& from) noexcept
    : MsgInfoList() {
    *this = ::std::move(from);
  }

  inline MsgInfoList& operator=(MsgInfoList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MsgInfoList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgInfoList* internal_default_instance() {
    return reinterpret_cast<const MsgInfoList*>(
               &_MsgInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MsgInfoList* other);
  friend void swap(MsgInfoList& a, MsgInfoList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgInfoList* New() const final {
    return CreateMaybeMessage<MsgInfoList>(NULL);
  }

  MsgInfoList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MsgInfoList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MsgInfoList& from);
  void MergeFrom(const MsgInfoList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgInfoList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msg_data = 8;
  bool has_msg_data() const;
  void clear_msg_data();
  static const int kMsgDataFieldNumber = 8;
  const ::std::string& msg_data() const;
  void set_msg_data(const ::std::string& value);
  #if LANG_CXX11
  void set_msg_data(::std::string&& value);
  #endif
  void set_msg_data(const char* value);
  void set_msg_data(const char* value, size_t size);
  ::std::string* mutable_msg_data();
  ::std::string* release_msg_data();
  void set_allocated_msg_data(::std::string* msg_data);

  // required uint32 msg_id = 1;
  bool has_msg_id() const;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  ::google::protobuf::uint32 msg_id() const;
  void set_msg_id(::google::protobuf::uint32 value);

  // required uint32 from_uid = 4;
  bool has_from_uid() const;
  void clear_from_uid();
  static const int kFromUidFieldNumber = 4;
  ::google::protobuf::uint32 from_uid() const;
  void set_from_uid(::google::protobuf::uint32 value);

  // optional uint32 group_id = 5;
  bool has_group_id() const;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 5;
  ::google::protobuf::uint32 group_id() const;
  void set_group_id(::google::protobuf::uint32 value);

  // required uint32 sent_at = 6;
  bool has_sent_at() const;
  void clear_sent_at();
  static const int kSentAtFieldNumber = 6;
  ::google::protobuf::uint32 sent_at() const;
  void set_sent_at(::google::protobuf::uint32 value);

  // required .PTP.Common.MsgType msg_type = 7;
  bool has_msg_type() const;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 7;
  ::PTP::Common::MsgType msg_type() const;
  void set_msg_type(::PTP::Common::MsgType value);

  // @@protoc_insertion_point(class_scope:PTP.Common.MsgInfoList)
 private:
  void set_has_msg_id();
  void clear_has_msg_id();
  void set_has_from_uid();
  void clear_has_from_uid();
  void set_has_group_id();
  void clear_has_group_id();
  void set_has_sent_at();
  void clear_has_sent_at();
  void set_has_msg_type();
  void clear_has_msg_type();
  void set_has_msg_data();
  void clear_has_msg_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr msg_data_;
  ::google::protobuf::uint32 msg_id_;
  ::google::protobuf::uint32 from_uid_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 sent_at_;
  int msg_type_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupMember : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.GroupMember) */ {
 public:
  GroupMember();
  virtual ~GroupMember();

  GroupMember(const GroupMember& from);

  inline GroupMember& operator=(const GroupMember& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupMember(GroupMember&& from) noexcept
    : GroupMember() {
    *this = ::std::move(from);
  }

  inline GroupMember& operator=(GroupMember&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupMember& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupMember* internal_default_instance() {
    return reinterpret_cast<const GroupMember*>(
               &_GroupMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GroupMember* other);
  friend void swap(GroupMember& a, GroupMember& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupMember* New() const final {
    return CreateMaybeMessage<GroupMember>(NULL);
  }

  GroupMember* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupMember>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupMember& from);
  void MergeFrom(const GroupMember& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupMember* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // required .PTP.Common.GroupMemberStatus member_status = 2;
  bool has_member_status() const;
  void clear_member_status();
  static const int kMemberStatusFieldNumber = 2;
  ::PTP::Common::GroupMemberStatus member_status() const;
  void set_member_status(::PTP::Common::GroupMemberStatus value);

  // @@protoc_insertion_point(class_scope:PTP.Common.GroupMember)
 private:
  void set_has_uid();
  void clear_has_uid();
  void set_has_member_status();
  void clear_has_member_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 uid_;
  int member_status_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupRecord : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.GroupRecord) */ {
 public:
  GroupRecord();
  virtual ~GroupRecord();

  GroupRecord(const GroupRecord& from);

  inline GroupRecord& operator=(const GroupRecord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupRecord(GroupRecord&& from) noexcept
    : GroupRecord() {
    *this = ::std::move(from);
  }

  inline GroupRecord& operator=(GroupRecord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupRecord* internal_default_instance() {
    return reinterpret_cast<const GroupRecord*>(
               &_GroupRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GroupRecord* other);
  friend void swap(GroupRecord& a, GroupRecord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupRecord* New() const final {
    return CreateMaybeMessage<GroupRecord>(NULL);
  }

  GroupRecord* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupRecord>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupRecord& from);
  void MergeFrom(const GroupRecord& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string avatar = 2;
  bool has_avatar() const;
  void clear_avatar();
  static const int kAvatarFieldNumber = 2;
  const ::std::string& avatar() const;
  void set_avatar(const ::std::string& value);
  #if LANG_CXX11
  void set_avatar(::std::string&& value);
  #endif
  void set_avatar(const char* value);
  void set_avatar(const char* value, size_t size);
  ::std::string* mutable_avatar();
  ::std::string* release_avatar();
  void set_allocated_avatar(::std::string* avatar);

  // required string group_adr = 3;
  bool has_group_adr() const;
  void clear_group_adr();
  static const int kGroupAdrFieldNumber = 3;
  const ::std::string& group_adr() const;
  void set_group_adr(const ::std::string& value);
  #if LANG_CXX11
  void set_group_adr(::std::string&& value);
  #endif
  void set_group_adr(const char* value);
  void set_group_adr(const char* value, size_t size);
  ::std::string* mutable_group_adr();
  ::std::string* release_group_adr();
  void set_allocated_group_adr(::std::string* group_adr);

  // optional uint32 pair_uid = 5;
  bool has_pair_uid() const;
  void clear_pair_uid();
  static const int kPairUidFieldNumber = 5;
  ::google::protobuf::uint32 pair_uid() const;
  void set_pair_uid(::google::protobuf::uint32 value);

  // optional uint32 owner_uid = 6;
  bool has_owner_uid() const;
  void clear_owner_uid();
  static const int kOwnerUidFieldNumber = 6;
  ::google::protobuf::uint32 owner_uid() const;
  void set_owner_uid(::google::protobuf::uint32 value);

  // required uint32 group_id = 7;
  bool has_group_id() const;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 7;
  ::google::protobuf::uint32 group_id() const;
  void set_group_id(::google::protobuf::uint32 value);

  // required uint32 unReadCnt = 8;
  bool has_unreadcnt() const;
  void clear_unreadcnt();
  static const int kUnReadCntFieldNumber = 8;
  ::google::protobuf::uint32 unreadcnt() const;
  void set_unreadcnt(::google::protobuf::uint32 value);

  // optional uint32 lastMsgId = 9;
  bool has_lastmsgid() const;
  void clear_lastmsgid();
  static const int kLastMsgIdFieldNumber = 9;
  ::google::protobuf::uint32 lastmsgid() const;
  void set_lastmsgid(::google::protobuf::uint32 value);

  // required uint32 msgUpTime = 11;
  bool has_msguptime() const;
  void clear_msguptime();
  static const int kMsgUpTimeFieldNumber = 11;
  ::google::protobuf::uint32 msguptime() const;
  void set_msguptime(::google::protobuf::uint32 value);

  // required uint32 memberUpTime = 12;
  bool has_memberuptime() const;
  void clear_memberuptime();
  static const int kMemberUpTimeFieldNumber = 12;
  ::google::protobuf::uint32 memberuptime() const;
  void set_memberuptime(::google::protobuf::uint32 value);

  // required .PTP.Common.GroupType group_type = 4;
  bool has_group_type() const;
  void clear_group_type();
  static const int kGroupTypeFieldNumber = 4;
  ::PTP::Common::GroupType group_type() const;
  void set_group_type(::PTP::Common::GroupType value);

  // @@protoc_insertion_point(class_scope:PTP.Common.GroupRecord)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_avatar();
  void clear_has_avatar();
  void set_has_group_adr();
  void clear_has_group_adr();
  void set_has_group_type();
  void clear_has_group_type();
  void set_has_pair_uid();
  void clear_has_pair_uid();
  void set_has_owner_uid();
  void clear_has_owner_uid();
  void set_has_group_id();
  void clear_has_group_id();
  void set_has_unreadcnt();
  void clear_has_unreadcnt();
  void set_has_lastmsgid();
  void clear_has_lastmsgid();
  void set_has_msguptime();
  void clear_has_msguptime();
  void set_has_memberuptime();
  void clear_has_memberuptime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr avatar_;
  ::google::protobuf::internal::ArenaStringPtr group_adr_;
  ::google::protobuf::uint32 pair_uid_;
  ::google::protobuf::uint32 owner_uid_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 unreadcnt_;
  ::google::protobuf::uint32 lastmsgid_;
  ::google::protobuf::uint32 msguptime_;
  ::google::protobuf::uint32 memberuptime_;
  int group_type_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.GroupInfo) */ {
 public:
  GroupInfo();
  virtual ~GroupInfo();

  GroupInfo(const GroupInfo& from);

  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupInfo(GroupInfo&& from) noexcept
    : GroupInfo() {
    *this = ::std::move(from);
  }

  inline GroupInfo& operator=(GroupInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const GroupInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupInfo* internal_default_instance() {
    return reinterpret_cast<const GroupInfo*>(
               &_GroupInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GroupInfo* other);
  friend void swap(GroupInfo& a, GroupInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupInfo* New() const final {
    return CreateMaybeMessage<GroupInfo>(NULL);
  }

  GroupInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const GroupInfo& from);
  void MergeFrom(const GroupInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string group_adr = 1;
  bool has_group_adr() const;
  void clear_group_adr();
  static const int kGroupAdrFieldNumber = 1;
  const ::std::string& group_adr() const;
  void set_group_adr(const ::std::string& value);
  #if LANG_CXX11
  void set_group_adr(::std::string&& value);
  #endif
  void set_group_adr(const char* value);
  void set_group_adr(const char* value, size_t size);
  ::std::string* mutable_group_adr();
  ::std::string* release_group_adr();
  void set_allocated_group_adr(::std::string* group_adr);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string avatar = 3;
  bool has_avatar() const;
  void clear_avatar();
  static const int kAvatarFieldNumber = 3;
  const ::std::string& avatar() const;
  void set_avatar(const ::std::string& value);
  #if LANG_CXX11
  void set_avatar(::std::string&& value);
  #endif
  void set_avatar(const char* value);
  void set_avatar(const char* value, size_t size);
  ::std::string* mutable_avatar();
  ::std::string* release_avatar();
  void set_allocated_avatar(::std::string* avatar);

  // required uint32 owner_uid = 4;
  bool has_owner_uid() const;
  void clear_owner_uid();
  static const int kOwnerUidFieldNumber = 4;
  ::google::protobuf::uint32 owner_uid() const;
  void set_owner_uid(::google::protobuf::uint32 value);

  // optional uint32 pair_uid = 5;
  bool has_pair_uid() const;
  void clear_pair_uid();
  static const int kPairUidFieldNumber = 5;
  ::google::protobuf::uint32 pair_uid() const;
  void set_pair_uid(::google::protobuf::uint32 value);

  // required uint32 group_idx = 7;
  bool has_group_idx() const;
  void clear_group_idx();
  static const int kGroupIdxFieldNumber = 7;
  ::google::protobuf::uint32 group_idx() const;
  void set_group_idx(::google::protobuf::uint32 value);

  // required uint32 created_time = 8;
  bool has_created_time() const;
  void clear_created_time();
  static const int kCreatedTimeFieldNumber = 8;
  ::google::protobuf::uint32 created_time() const;
  void set_created_time(::google::protobuf::uint32 value);

  // required uint32 group_id = 9;
  bool has_group_id() const;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 9;
  ::google::protobuf::uint32 group_id() const;
  void set_group_id(::google::protobuf::uint32 value);

  // required .PTP.Common.GroupType group_type = 6;
  bool has_group_type() const;
  void clear_group_type();
  static const int kGroupTypeFieldNumber = 6;
  ::PTP::Common::GroupType group_type() const;
  void set_group_type(::PTP::Common::GroupType value);

  // @@protoc_insertion_point(class_scope:PTP.Common.GroupInfo)
 private:
  void set_has_group_adr();
  void clear_has_group_adr();
  void set_has_group_id();
  void clear_has_group_id();
  void set_has_name();
  void clear_has_name();
  void set_has_avatar();
  void clear_has_avatar();
  void set_has_owner_uid();
  void clear_has_owner_uid();
  void set_has_pair_uid();
  void clear_has_pair_uid();
  void set_has_group_type();
  void clear_has_group_type();
  void set_has_group_idx();
  void clear_has_group_idx();
  void set_has_created_time();
  void clear_has_created_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr group_adr_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr avatar_;
  ::google::protobuf::uint32 owner_uid_;
  ::google::protobuf::uint32 pair_uid_;
  ::google::protobuf::uint32 group_idx_;
  ::google::protobuf::uint32 created_time_;
  ::google::protobuf::uint32 group_id_;
  int group_type_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MsgInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.MsgInfo) */ {
 public:
  MsgInfo();
  virtual ~MsgInfo();

  MsgInfo(const MsgInfo& from);

  inline MsgInfo& operator=(const MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgInfo(MsgInfo&& from) noexcept
    : MsgInfo() {
    *this = ::std::move(from);
  }

  inline MsgInfo& operator=(MsgInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MsgInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgInfo* internal_default_instance() {
    return reinterpret_cast<const MsgInfo*>(
               &_MsgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(MsgInfo* other);
  friend void swap(MsgInfo& a, MsgInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgInfo* New() const final {
    return CreateMaybeMessage<MsgInfo>(NULL);
  }

  MsgInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MsgInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const MsgInfo& from);
  void MergeFrom(const MsgInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msg_data = 7;
  bool has_msg_data() const;
  void clear_msg_data();
  static const int kMsgDataFieldNumber = 7;
  const ::std::string& msg_data() const;
  void set_msg_data(const ::std::string& value);
  #if LANG_CXX11
  void set_msg_data(::std::string&& value);
  #endif
  void set_msg_data(const char* value);
  void set_msg_data(const char* value, size_t size);
  ::std::string* mutable_msg_data();
  ::std::string* release_msg_data();
  void set_allocated_msg_data(::std::string* msg_data);

  // required uint32 group_id = 1;
  bool has_group_id() const;
  void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  ::google::protobuf::uint32 group_id() const;
  void set_group_id(::google::protobuf::uint32 value);

  // required uint32 from_uid = 2;
  bool has_from_uid() const;
  void clear_from_uid();
  static const int kFromUidFieldNumber = 2;
  ::google::protobuf::uint32 from_uid() const;
  void set_from_uid(::google::protobuf::uint32 value);

  // required uint32 sent_at = 3;
  bool has_sent_at() const;
  void clear_sent_at();
  static const int kSentAtFieldNumber = 3;
  ::google::protobuf::uint32 sent_at() const;
  void set_sent_at(::google::protobuf::uint32 value);

  // required uint32 msg_id = 4;
  bool has_msg_id() const;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 4;
  ::google::protobuf::uint32 msg_id() const;
  void set_msg_id(::google::protobuf::uint32 value);

  // required .PTP.Common.MsgType msg_type = 6;
  bool has_msg_type() const;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 6;
  ::PTP::Common::MsgType msg_type() const;
  void set_msg_type(::PTP::Common::MsgType value);

  // @@protoc_insertion_point(class_scope:PTP.Common.MsgInfo)
 private:
  void set_has_group_id();
  void clear_has_group_id();
  void set_has_from_uid();
  void clear_has_from_uid();
  void set_has_sent_at();
  void clear_has_sent_at();
  void set_has_msg_id();
  void clear_has_msg_id();
  void set_has_msg_type();
  void clear_has_msg_type();
  void set_has_msg_data();
  void clear_has_msg_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr msg_data_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 from_uid_;
  ::google::protobuf::uint32 sent_at_;
  ::google::protobuf::uint32 msg_id_;
  int msg_type_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DevicesInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.DevicesInfo) */ {
 public:
  DevicesInfo();
  virtual ~DevicesInfo();

  DevicesInfo(const DevicesInfo& from);

  inline DevicesInfo& operator=(const DevicesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DevicesInfo(DevicesInfo&& from) noexcept
    : DevicesInfo() {
    *this = ::std::move(from);
  }

  inline DevicesInfo& operator=(DevicesInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DevicesInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DevicesInfo* internal_default_instance() {
    return reinterpret_cast<const DevicesInfo*>(
               &_DevicesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(DevicesInfo* other);
  friend void swap(DevicesInfo& a, DevicesInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DevicesInfo* New() const final {
    return CreateMaybeMessage<DevicesInfo>(NULL);
  }

  DevicesInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DevicesInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DevicesInfo& from);
  void MergeFrom(const DevicesInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicesInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_version = 2;
  bool has_client_version() const;
  void clear_client_version();
  static const int kClientVersionFieldNumber = 2;
  const ::std::string& client_version() const;
  void set_client_version(const ::std::string& value);
  #if LANG_CXX11
  void set_client_version(::std::string&& value);
  #endif
  void set_client_version(const char* value);
  void set_client_version(const char* value, size_t size);
  ::std::string* mutable_client_version();
  ::std::string* release_client_version();
  void set_allocated_client_version(::std::string* client_version);

  // required string browser_name = 4;
  bool has_browser_name() const;
  void clear_browser_name();
  static const int kBrowserNameFieldNumber = 4;
  const ::std::string& browser_name() const;
  void set_browser_name(const ::std::string& value);
  #if LANG_CXX11
  void set_browser_name(::std::string&& value);
  #endif
  void set_browser_name(const char* value);
  void set_browser_name(const char* value, size_t size);
  ::std::string* mutable_browser_name();
  ::std::string* release_browser_name();
  void set_allocated_browser_name(::std::string* browser_name);

  // required string browser_version = 5;
  bool has_browser_version() const;
  void clear_browser_version();
  static const int kBrowserVersionFieldNumber = 5;
  const ::std::string& browser_version() const;
  void set_browser_version(const ::std::string& value);
  #if LANG_CXX11
  void set_browser_version(::std::string&& value);
  #endif
  void set_browser_version(const char* value);
  void set_browser_version(const char* value, size_t size);
  ::std::string* mutable_browser_version();
  ::std::string* release_browser_version();
  void set_allocated_browser_version(::std::string* browser_version);

  // required string os_name = 6;
  bool has_os_name() const;
  void clear_os_name();
  static const int kOsNameFieldNumber = 6;
  const ::std::string& os_name() const;
  void set_os_name(const ::std::string& value);
  #if LANG_CXX11
  void set_os_name(::std::string&& value);
  #endif
  void set_os_name(const char* value);
  void set_os_name(const char* value, size_t size);
  ::std::string* mutable_os_name();
  ::std::string* release_os_name();
  void set_allocated_os_name(::std::string* os_name);

  // required string os_version = 7;
  bool has_os_version() const;
  void clear_os_version();
  static const int kOsVersionFieldNumber = 7;
  const ::std::string& os_version() const;
  void set_os_version(const ::std::string& value);
  #if LANG_CXX11
  void set_os_version(::std::string&& value);
  #endif
  void set_os_version(const char* value);
  void set_os_version(const char* value, size_t size);
  ::std::string* mutable_os_version();
  ::std::string* release_os_version();
  void set_allocated_os_version(::std::string* os_version);

  // required string client_id = 10;
  bool has_client_id() const;
  void clear_client_id();
  static const int kClientIdFieldNumber = 10;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // required uint32 login_time = 3;
  bool has_login_time() const;
  void clear_login_time();
  static const int kLoginTimeFieldNumber = 3;
  ::google::protobuf::uint32 login_time() const;
  void set_login_time(::google::protobuf::uint32 value);

  // required bool is_intel = 8;
  bool has_is_intel() const;
  void clear_is_intel();
  static const int kIsIntelFieldNumber = 8;
  bool is_intel() const;
  void set_is_intel(bool value);

  // required uint32 uid = 9;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 9;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // required .PTP.Common.ClientType client_type = 1;
  bool has_client_type() const;
  void clear_client_type();
  static const int kClientTypeFieldNumber = 1;
  ::PTP::Common::ClientType client_type() const;
  void set_client_type(::PTP::Common::ClientType value);

  // @@protoc_insertion_point(class_scope:PTP.Common.DevicesInfo)
 private:
  void set_has_client_type();
  void clear_has_client_type();
  void set_has_client_version();
  void clear_has_client_version();
  void set_has_login_time();
  void clear_has_login_time();
  void set_has_browser_name();
  void clear_has_browser_name();
  void set_has_browser_version();
  void clear_has_browser_version();
  void set_has_os_name();
  void clear_has_os_name();
  void set_has_os_version();
  void clear_has_os_version();
  void set_has_is_intel();
  void clear_has_is_intel();
  void set_has_uid();
  void clear_has_uid();
  void set_has_client_id();
  void clear_has_client_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_version_;
  ::google::protobuf::internal::ArenaStringPtr browser_name_;
  ::google::protobuf::internal::ArenaStringPtr browser_version_;
  ::google::protobuf::internal::ArenaStringPtr os_name_;
  ::google::protobuf::internal::ArenaStringPtr os_version_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  ::google::protobuf::uint32 login_time_;
  bool is_intel_;
  ::google::protobuf::uint32 uid_;
  int client_type_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InputPhoneContact : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.InputPhoneContact) */ {
 public:
  InputPhoneContact();
  virtual ~InputPhoneContact();

  InputPhoneContact(const InputPhoneContact& from);

  inline InputPhoneContact& operator=(const InputPhoneContact& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputPhoneContact(InputPhoneContact&& from) noexcept
    : InputPhoneContact() {
    *this = ::std::move(from);
  }

  inline InputPhoneContact& operator=(InputPhoneContact&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InputPhoneContact& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputPhoneContact* internal_default_instance() {
    return reinterpret_cast<const InputPhoneContact*>(
               &_InputPhoneContact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(InputPhoneContact* other);
  friend void swap(InputPhoneContact& a, InputPhoneContact& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputPhoneContact* New() const final {
    return CreateMaybeMessage<InputPhoneContact>(NULL);
  }

  InputPhoneContact* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InputPhoneContact>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const InputPhoneContact& from);
  void MergeFrom(const InputPhoneContact& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InputPhoneContact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string phone = 2;
  bool has_phone() const;
  void clear_phone();
  static const int kPhoneFieldNumber = 2;
  const ::std::string& phone() const;
  void set_phone(const ::std::string& value);
  #if LANG_CXX11
  void set_phone(::std::string&& value);
  #endif
  void set_phone(const char* value);
  void set_phone(const char* value, size_t size);
  ::std::string* mutable_phone();
  ::std::string* release_phone();
  void set_allocated_phone(::std::string* phone);

  // optional string first_name = 3;
  bool has_first_name() const;
  void clear_first_name();
  static const int kFirstNameFieldNumber = 3;
  const ::std::string& first_name() const;
  void set_first_name(const ::std::string& value);
  #if LANG_CXX11
  void set_first_name(::std::string&& value);
  #endif
  void set_first_name(const char* value);
  void set_first_name(const char* value, size_t size);
  ::std::string* mutable_first_name();
  ::std::string* release_first_name();
  void set_allocated_first_name(::std::string* first_name);

  // optional string last_name = 4;
  bool has_last_name() const;
  void clear_last_name();
  static const int kLastNameFieldNumber = 4;
  const ::std::string& last_name() const;
  void set_last_name(const ::std::string& value);
  #if LANG_CXX11
  void set_last_name(::std::string&& value);
  #endif
  void set_last_name(const char* value);
  void set_last_name(const char* value, size_t size);
  ::std::string* mutable_last_name();
  ::std::string* release_last_name();
  void set_allocated_last_name(::std::string* last_name);

  // required uint64 client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  ::google::protobuf::uint64 client_id() const;
  void set_client_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:PTP.Common.InputPhoneContact)
 private:
  void set_has_client_id();
  void clear_has_client_id();
  void set_has_phone();
  void clear_has_phone();
  void set_has_first_name();
  void clear_has_first_name();
  void set_has_last_name();
  void clear_has_last_name();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr phone_;
  ::google::protobuf::internal::ArenaStringPtr first_name_;
  ::google::protobuf::internal::ArenaStringPtr last_name_;
  ::google::protobuf::uint64 client_id_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BuddyQueryParam : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.BuddyQueryParam) */ {
 public:
  BuddyQueryParam();
  virtual ~BuddyQueryParam();

  BuddyQueryParam(const BuddyQueryParam& from);

  inline BuddyQueryParam& operator=(const BuddyQueryParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuddyQueryParam(BuddyQueryParam&& from) noexcept
    : BuddyQueryParam() {
    *this = ::std::move(from);
  }

  inline BuddyQueryParam& operator=(BuddyQueryParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const BuddyQueryParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuddyQueryParam* internal_default_instance() {
    return reinterpret_cast<const BuddyQueryParam*>(
               &_BuddyQueryParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(BuddyQueryParam* other);
  friend void swap(BuddyQueryParam& a, BuddyQueryParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuddyQueryParam* New() const final {
    return CreateMaybeMessage<BuddyQueryParam>(NULL);
  }

  BuddyQueryParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BuddyQueryParam>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const BuddyQueryParam& from);
  void MergeFrom(const BuddyQueryParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BuddyQueryParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string addressList = 1;
  int addresslist_size() const;
  void clear_addresslist();
  static const int kAddressListFieldNumber = 1;
  const ::std::string& addresslist(int index) const;
  ::std::string* mutable_addresslist(int index);
  void set_addresslist(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_addresslist(int index, ::std::string&& value);
  #endif
  void set_addresslist(int index, const char* value);
  void set_addresslist(int index, const char* value, size_t size);
  ::std::string* add_addresslist();
  void add_addresslist(const ::std::string& value);
  #if LANG_CXX11
  void add_addresslist(::std::string&& value);
  #endif
  void add_addresslist(const char* value);
  void add_addresslist(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& addresslist() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_addresslist();

  // repeated string usernameList = 2;
  int usernamelist_size() const;
  void clear_usernamelist();
  static const int kUsernameListFieldNumber = 2;
  const ::std::string& usernamelist(int index) const;
  ::std::string* mutable_usernamelist(int index);
  void set_usernamelist(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_usernamelist(int index, ::std::string&& value);
  #endif
  void set_usernamelist(int index, const char* value);
  void set_usernamelist(int index, const char* value, size_t size);
  ::std::string* add_usernamelist();
  void add_usernamelist(const ::std::string& value);
  #if LANG_CXX11
  void add_usernamelist(::std::string&& value);
  #endif
  void add_usernamelist(const char* value);
  void add_usernamelist(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& usernamelist() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_usernamelist();

  // @@protoc_insertion_point(class_scope:PTP.Common.BuddyQueryParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> addresslist_;
  ::google::protobuf::RepeatedPtrField< ::std::string> usernamelist_;
  friend struct ::protobuf_PTP_2eCommon_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IpAddress

// required string ip = 1;
inline bool IpAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpAddress::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& IpAddress::ip() const {
  // @@protoc_insertion_point(field_get:PTP.Common.IpAddress.ip)
  return ip_.GetNoArena();
}
inline void IpAddress::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.IpAddress.ip)
}
#if LANG_CXX11
inline void IpAddress::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.IpAddress.ip)
}
#endif
inline void IpAddress::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.IpAddress.ip)
}
inline void IpAddress::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.IpAddress.ip)
}
inline ::std::string* IpAddress::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:PTP.Common.IpAddress.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IpAddress::release_ip() {
  // @@protoc_insertion_point(field_release:PTP.Common.IpAddress.ip)
  if (!has_ip()) {
    return NULL;
  }
  clear_has_ip();
  return ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IpAddress::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.IpAddress.ip)
}

// required uint32 port = 2;
inline bool IpAddress::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpAddress::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpAddress::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpAddress::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 IpAddress::port() const {
  // @@protoc_insertion_point(field_get:PTP.Common.IpAddress.port)
  return port_;
}
inline void IpAddress::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.IpAddress.port)
}

// -------------------------------------------------------------------

// UserInfo

// required string address = 1;
inline bool UserInfo::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& UserInfo::address() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.address)
  return address_.GetNoArena();
}
inline void UserInfo::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.address)
}
#if LANG_CXX11
inline void UserInfo::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.UserInfo.address)
}
#endif
inline void UserInfo::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.UserInfo.address)
}
inline void UserInfo::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.UserInfo.address)
}
inline ::std::string* UserInfo::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_address() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.address)
  if (!has_address()) {
    return NULL;
  }
  clear_has_address();
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.address)
}

// required bytes pub_key = 2;
inline bool UserInfo::has_pub_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_pub_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_pub_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_pub_key() {
  pub_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pub_key();
}
inline const ::std::string& UserInfo::pub_key() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.pub_key)
  return pub_key_.GetNoArena();
}
inline void UserInfo::set_pub_key(const ::std::string& value) {
  set_has_pub_key();
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.pub_key)
}
#if LANG_CXX11
inline void UserInfo::set_pub_key(::std::string&& value) {
  set_has_pub_key();
  pub_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.UserInfo.pub_key)
}
#endif
inline void UserInfo::set_pub_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pub_key();
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.UserInfo.pub_key)
}
inline void UserInfo::set_pub_key(const void* value, size_t size) {
  set_has_pub_key();
  pub_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.UserInfo.pub_key)
}
inline ::std::string* UserInfo::mutable_pub_key() {
  set_has_pub_key();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.pub_key)
  return pub_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_pub_key() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.pub_key)
  if (!has_pub_key()) {
    return NULL;
  }
  clear_has_pub_key();
  return pub_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_pub_key(::std::string* pub_key) {
  if (pub_key != NULL) {
    set_has_pub_key();
  } else {
    clear_has_pub_key();
  }
  pub_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pub_key);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.pub_key)
}

// required string avatar = 3;
inline bool UserInfo::has_avatar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_avatar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_avatar() {
  avatar_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_avatar();
}
inline const ::std::string& UserInfo::avatar() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.avatar)
  return avatar_.GetNoArena();
}
inline void UserInfo::set_avatar(const ::std::string& value) {
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.avatar)
}
#if LANG_CXX11
inline void UserInfo::set_avatar(::std::string&& value) {
  set_has_avatar();
  avatar_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.UserInfo.avatar)
}
#endif
inline void UserInfo::set_avatar(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.UserInfo.avatar)
}
inline void UserInfo::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.UserInfo.avatar)
}
inline ::std::string* UserInfo::mutable_avatar() {
  set_has_avatar();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.avatar)
  return avatar_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_avatar() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.avatar)
  if (!has_avatar()) {
    return NULL;
  }
  clear_has_avatar();
  return avatar_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_avatar(::std::string* avatar) {
  if (avatar != NULL) {
    set_has_avatar();
  } else {
    clear_has_avatar();
  }
  avatar_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.avatar)
}

// required uint32 status = 4;
inline bool UserInfo::has_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 UserInfo::status() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.status)
  return status_;
}
inline void UserInfo::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.status)
}

// optional string user_name = 5;
inline bool UserInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_name();
}
inline const ::std::string& UserInfo::user_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.user_name)
  return user_name_.GetNoArena();
}
inline void UserInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.user_name)
}
#if LANG_CXX11
inline void UserInfo::set_user_name(::std::string&& value) {
  set_has_user_name();
  user_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.UserInfo.user_name)
}
#endif
inline void UserInfo::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.UserInfo.user_name)
}
inline void UserInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  user_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.UserInfo.user_name)
}
inline ::std::string* UserInfo::mutable_user_name() {
  set_has_user_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.user_name)
  return user_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_user_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.user_name)
  if (!has_user_name()) {
    return NULL;
  }
  clear_has_user_name();
  return user_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name != NULL) {
    set_has_user_name();
  } else {
    clear_has_user_name();
  }
  user_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.user_name)
}

// optional string nick_name = 6;
inline bool UserInfo::has_nick_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_nick_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_nick_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_nick_name() {
  nick_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nick_name();
}
inline const ::std::string& UserInfo::nick_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.nick_name)
  return nick_name_.GetNoArena();
}
inline void UserInfo::set_nick_name(const ::std::string& value) {
  set_has_nick_name();
  nick_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.nick_name)
}
#if LANG_CXX11
inline void UserInfo::set_nick_name(::std::string&& value) {
  set_has_nick_name();
  nick_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.UserInfo.nick_name)
}
#endif
inline void UserInfo::set_nick_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nick_name();
  nick_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.UserInfo.nick_name)
}
inline void UserInfo::set_nick_name(const char* value, size_t size) {
  set_has_nick_name();
  nick_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.UserInfo.nick_name)
}
inline ::std::string* UserInfo::mutable_nick_name() {
  set_has_nick_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.nick_name)
  return nick_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_nick_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.nick_name)
  if (!has_nick_name()) {
    return NULL;
  }
  clear_has_nick_name();
  return nick_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_nick_name(::std::string* nick_name) {
  if (nick_name != NULL) {
    set_has_nick_name();
  } else {
    clear_has_nick_name();
  }
  nick_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick_name);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.nick_name)
}

// optional string sign_info = 7;
inline bool UserInfo::has_sign_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_sign_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_sign_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_sign_info() {
  sign_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sign_info();
}
inline const ::std::string& UserInfo::sign_info() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.sign_info)
  return sign_info_.GetNoArena();
}
inline void UserInfo::set_sign_info(const ::std::string& value) {
  set_has_sign_info();
  sign_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.sign_info)
}
#if LANG_CXX11
inline void UserInfo::set_sign_info(::std::string&& value) {
  set_has_sign_info();
  sign_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.UserInfo.sign_info)
}
#endif
inline void UserInfo::set_sign_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sign_info();
  sign_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.UserInfo.sign_info)
}
inline void UserInfo::set_sign_info(const char* value, size_t size) {
  set_has_sign_info();
  sign_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.UserInfo.sign_info)
}
inline ::std::string* UserInfo::mutable_sign_info() {
  set_has_sign_info();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.sign_info)
  return sign_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_sign_info() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.sign_info)
  if (!has_sign_info()) {
    return NULL;
  }
  clear_has_sign_info();
  return sign_info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_sign_info(::std::string* sign_info) {
  if (sign_info != NULL) {
    set_has_sign_info();
  } else {
    clear_has_sign_info();
  }
  sign_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign_info);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.sign_info)
}

// required uint32 uid = 8;
inline bool UserInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 UserInfo::uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.uid)
  return uid_;
}
inline void UserInfo::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.uid)
}

// optional string first_name = 9;
inline bool UserInfo::has_first_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_first_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_first_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_first_name() {
  first_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_first_name();
}
inline const ::std::string& UserInfo::first_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.first_name)
  return first_name_.GetNoArena();
}
inline void UserInfo::set_first_name(const ::std::string& value) {
  set_has_first_name();
  first_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.first_name)
}
#if LANG_CXX11
inline void UserInfo::set_first_name(::std::string&& value) {
  set_has_first_name();
  first_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.UserInfo.first_name)
}
#endif
inline void UserInfo::set_first_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_first_name();
  first_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.UserInfo.first_name)
}
inline void UserInfo::set_first_name(const char* value, size_t size) {
  set_has_first_name();
  first_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.UserInfo.first_name)
}
inline ::std::string* UserInfo::mutable_first_name() {
  set_has_first_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.first_name)
  return first_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_first_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.first_name)
  if (!has_first_name()) {
    return NULL;
  }
  clear_has_first_name();
  return first_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_first_name(::std::string* first_name) {
  if (first_name != NULL) {
    set_has_first_name();
  } else {
    clear_has_first_name();
  }
  first_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), first_name);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.first_name)
}

// optional string last_name = 10;
inline bool UserInfo::has_last_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_last_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_last_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_last_name() {
  last_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_last_name();
}
inline const ::std::string& UserInfo::last_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.last_name)
  return last_name_.GetNoArena();
}
inline void UserInfo::set_last_name(const ::std::string& value) {
  set_has_last_name();
  last_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.last_name)
}
#if LANG_CXX11
inline void UserInfo::set_last_name(::std::string&& value) {
  set_has_last_name();
  last_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.UserInfo.last_name)
}
#endif
inline void UserInfo::set_last_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_last_name();
  last_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.UserInfo.last_name)
}
inline void UserInfo::set_last_name(const char* value, size_t size) {
  set_has_last_name();
  last_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.UserInfo.last_name)
}
inline ::std::string* UserInfo::mutable_last_name() {
  set_has_last_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.last_name)
  return last_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserInfo::release_last_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.last_name)
  if (!has_last_name()) {
    return NULL;
  }
  clear_has_last_name();
  return last_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserInfo::set_allocated_last_name(::std::string* last_name) {
  if (last_name != NULL) {
    set_has_last_name();
  } else {
    clear_has_last_name();
  }
  last_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_name);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.last_name)
}

// optional uint32 login_time = 11;
inline bool UserInfo::has_login_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfo::set_has_login_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfo::clear_has_login_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfo::clear_login_time() {
  login_time_ = 0u;
  clear_has_login_time();
}
inline ::google::protobuf::uint32 UserInfo::login_time() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.login_time)
  return login_time_;
}
inline void UserInfo::set_login_time(::google::protobuf::uint32 value) {
  set_has_login_time();
  login_time_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.login_time)
}

// optional bool is_online = 12;
inline bool UserInfo::has_is_online() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfo::set_has_is_online() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfo::clear_has_is_online() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfo::clear_is_online() {
  is_online_ = false;
  clear_has_is_online();
}
inline bool UserInfo::is_online() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.is_online)
  return is_online_;
}
inline void UserInfo::set_is_online(bool value) {
  set_has_is_online();
  is_online_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.is_online)
}

// -------------------------------------------------------------------

// UserStatInfo

// required uint32 uid = 1;
inline bool UserStatInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStatInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStatInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStatInfo::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 UserStatInfo::uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserStatInfo.uid)
  return uid_;
}
inline void UserStatInfo::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.UserStatInfo.uid)
}

// required .PTP.Common.UserStat status = 2;
inline bool UserStatInfo::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStatInfo::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStatInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStatInfo::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::PTP::Common::UserStat UserStatInfo::status() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserStatInfo.status)
  return static_cast< ::PTP::Common::UserStat >(status_);
}
inline void UserStatInfo::set_status(::PTP::Common::UserStat value) {
  assert(::PTP::Common::UserStat_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.UserStatInfo.status)
}

// -------------------------------------------------------------------

// MsgInfoList

// required uint32 msg_id = 1;
inline bool MsgInfoList::has_msg_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgInfoList::set_has_msg_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgInfoList::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgInfoList::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 MsgInfoList::msg_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.msg_id)
  return msg_id_;
}
inline void MsgInfoList::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.msg_id)
}

// required uint32 from_uid = 4;
inline bool MsgInfoList::has_from_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgInfoList::set_has_from_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgInfoList::clear_has_from_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgInfoList::clear_from_uid() {
  from_uid_ = 0u;
  clear_has_from_uid();
}
inline ::google::protobuf::uint32 MsgInfoList::from_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.from_uid)
  return from_uid_;
}
inline void MsgInfoList::set_from_uid(::google::protobuf::uint32 value) {
  set_has_from_uid();
  from_uid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.from_uid)
}

// optional uint32 group_id = 5;
inline bool MsgInfoList::has_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgInfoList::set_has_group_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgInfoList::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgInfoList::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 MsgInfoList::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.group_id)
  return group_id_;
}
inline void MsgInfoList::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.group_id)
}

// required uint32 sent_at = 6;
inline bool MsgInfoList::has_sent_at() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgInfoList::set_has_sent_at() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgInfoList::clear_has_sent_at() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgInfoList::clear_sent_at() {
  sent_at_ = 0u;
  clear_has_sent_at();
}
inline ::google::protobuf::uint32 MsgInfoList::sent_at() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.sent_at)
  return sent_at_;
}
inline void MsgInfoList::set_sent_at(::google::protobuf::uint32 value) {
  set_has_sent_at();
  sent_at_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.sent_at)
}

// required .PTP.Common.MsgType msg_type = 7;
inline bool MsgInfoList::has_msg_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgInfoList::set_has_msg_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgInfoList::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgInfoList::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::PTP::Common::MsgType MsgInfoList::msg_type() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.msg_type)
  return static_cast< ::PTP::Common::MsgType >(msg_type_);
}
inline void MsgInfoList::set_msg_type(::PTP::Common::MsgType value) {
  assert(::PTP::Common::MsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.msg_type)
}

// required string msg_data = 8;
inline bool MsgInfoList::has_msg_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgInfoList::set_has_msg_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgInfoList::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgInfoList::clear_msg_data() {
  msg_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg_data();
}
inline const ::std::string& MsgInfoList::msg_data() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.msg_data)
  return msg_data_.GetNoArena();
}
inline void MsgInfoList::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.msg_data)
}
#if LANG_CXX11
inline void MsgInfoList::set_msg_data(::std::string&& value) {
  set_has_msg_data();
  msg_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.MsgInfoList.msg_data)
}
#endif
inline void MsgInfoList::set_msg_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg_data();
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.MsgInfoList.msg_data)
}
inline void MsgInfoList::set_msg_data(const char* value, size_t size) {
  set_has_msg_data();
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.MsgInfoList.msg_data)
}
inline ::std::string* MsgInfoList::mutable_msg_data() {
  set_has_msg_data();
  // @@protoc_insertion_point(field_mutable:PTP.Common.MsgInfoList.msg_data)
  return msg_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgInfoList::release_msg_data() {
  // @@protoc_insertion_point(field_release:PTP.Common.MsgInfoList.msg_data)
  if (!has_msg_data()) {
    return NULL;
  }
  clear_has_msg_data();
  return msg_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgInfoList::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data != NULL) {
    set_has_msg_data();
  } else {
    clear_has_msg_data();
  }
  msg_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg_data);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.MsgInfoList.msg_data)
}

// -------------------------------------------------------------------

// GroupMember

// required uint32 uid = 1;
inline bool GroupMember::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMember::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMember::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMember::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 GroupMember::uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupMember.uid)
  return uid_;
}
inline void GroupMember::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupMember.uid)
}

// required .PTP.Common.GroupMemberStatus member_status = 2;
inline bool GroupMember::has_member_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMember::set_has_member_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMember::clear_has_member_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMember::clear_member_status() {
  member_status_ = 1;
  clear_has_member_status();
}
inline ::PTP::Common::GroupMemberStatus GroupMember::member_status() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupMember.member_status)
  return static_cast< ::PTP::Common::GroupMemberStatus >(member_status_);
}
inline void GroupMember::set_member_status(::PTP::Common::GroupMemberStatus value) {
  assert(::PTP::Common::GroupMemberStatus_IsValid(value));
  set_has_member_status();
  member_status_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupMember.member_status)
}

// -------------------------------------------------------------------

// GroupRecord

// required string name = 1;
inline bool GroupRecord::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupRecord::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupRecord::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupRecord::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GroupRecord::name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.name)
  return name_.GetNoArena();
}
inline void GroupRecord::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.name)
}
#if LANG_CXX11
inline void GroupRecord::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.GroupRecord.name)
}
#endif
inline void GroupRecord::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.GroupRecord.name)
}
inline void GroupRecord::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.GroupRecord.name)
}
inline ::std::string* GroupRecord::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupRecord.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupRecord::release_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupRecord.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupRecord::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupRecord.name)
}

// required string avatar = 2;
inline bool GroupRecord::has_avatar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupRecord::set_has_avatar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupRecord::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupRecord::clear_avatar() {
  avatar_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_avatar();
}
inline const ::std::string& GroupRecord::avatar() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.avatar)
  return avatar_.GetNoArena();
}
inline void GroupRecord::set_avatar(const ::std::string& value) {
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.avatar)
}
#if LANG_CXX11
inline void GroupRecord::set_avatar(::std::string&& value) {
  set_has_avatar();
  avatar_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.GroupRecord.avatar)
}
#endif
inline void GroupRecord::set_avatar(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.GroupRecord.avatar)
}
inline void GroupRecord::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.GroupRecord.avatar)
}
inline ::std::string* GroupRecord::mutable_avatar() {
  set_has_avatar();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupRecord.avatar)
  return avatar_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupRecord::release_avatar() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupRecord.avatar)
  if (!has_avatar()) {
    return NULL;
  }
  clear_has_avatar();
  return avatar_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupRecord::set_allocated_avatar(::std::string* avatar) {
  if (avatar != NULL) {
    set_has_avatar();
  } else {
    clear_has_avatar();
  }
  avatar_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupRecord.avatar)
}

// required string group_adr = 3;
inline bool GroupRecord::has_group_adr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupRecord::set_has_group_adr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupRecord::clear_has_group_adr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupRecord::clear_group_adr() {
  group_adr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_group_adr();
}
inline const ::std::string& GroupRecord::group_adr() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.group_adr)
  return group_adr_.GetNoArena();
}
inline void GroupRecord::set_group_adr(const ::std::string& value) {
  set_has_group_adr();
  group_adr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.group_adr)
}
#if LANG_CXX11
inline void GroupRecord::set_group_adr(::std::string&& value) {
  set_has_group_adr();
  group_adr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.GroupRecord.group_adr)
}
#endif
inline void GroupRecord::set_group_adr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_group_adr();
  group_adr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.GroupRecord.group_adr)
}
inline void GroupRecord::set_group_adr(const char* value, size_t size) {
  set_has_group_adr();
  group_adr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.GroupRecord.group_adr)
}
inline ::std::string* GroupRecord::mutable_group_adr() {
  set_has_group_adr();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupRecord.group_adr)
  return group_adr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupRecord::release_group_adr() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupRecord.group_adr)
  if (!has_group_adr()) {
    return NULL;
  }
  clear_has_group_adr();
  return group_adr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupRecord::set_allocated_group_adr(::std::string* group_adr) {
  if (group_adr != NULL) {
    set_has_group_adr();
  } else {
    clear_has_group_adr();
  }
  group_adr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_adr);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupRecord.group_adr)
}

// required .PTP.Common.GroupType group_type = 4;
inline bool GroupRecord::has_group_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GroupRecord::set_has_group_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GroupRecord::clear_has_group_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GroupRecord::clear_group_type() {
  group_type_ = 1;
  clear_has_group_type();
}
inline ::PTP::Common::GroupType GroupRecord::group_type() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.group_type)
  return static_cast< ::PTP::Common::GroupType >(group_type_);
}
inline void GroupRecord::set_group_type(::PTP::Common::GroupType value) {
  assert(::PTP::Common::GroupType_IsValid(value));
  set_has_group_type();
  group_type_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.group_type)
}

// optional uint32 pair_uid = 5;
inline bool GroupRecord::has_pair_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupRecord::set_has_pair_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupRecord::clear_has_pair_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupRecord::clear_pair_uid() {
  pair_uid_ = 0u;
  clear_has_pair_uid();
}
inline ::google::protobuf::uint32 GroupRecord::pair_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.pair_uid)
  return pair_uid_;
}
inline void GroupRecord::set_pair_uid(::google::protobuf::uint32 value) {
  set_has_pair_uid();
  pair_uid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.pair_uid)
}

// optional uint32 owner_uid = 6;
inline bool GroupRecord::has_owner_uid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupRecord::set_has_owner_uid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupRecord::clear_has_owner_uid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupRecord::clear_owner_uid() {
  owner_uid_ = 0u;
  clear_has_owner_uid();
}
inline ::google::protobuf::uint32 GroupRecord::owner_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.owner_uid)
  return owner_uid_;
}
inline void GroupRecord::set_owner_uid(::google::protobuf::uint32 value) {
  set_has_owner_uid();
  owner_uid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.owner_uid)
}

// required uint32 group_id = 7;
inline bool GroupRecord::has_group_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupRecord::set_has_group_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupRecord::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupRecord::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupRecord::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.group_id)
  return group_id_;
}
inline void GroupRecord::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.group_id)
}

// required uint32 unReadCnt = 8;
inline bool GroupRecord::has_unreadcnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupRecord::set_has_unreadcnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupRecord::clear_has_unreadcnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupRecord::clear_unreadcnt() {
  unreadcnt_ = 0u;
  clear_has_unreadcnt();
}
inline ::google::protobuf::uint32 GroupRecord::unreadcnt() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.unReadCnt)
  return unreadcnt_;
}
inline void GroupRecord::set_unreadcnt(::google::protobuf::uint32 value) {
  set_has_unreadcnt();
  unreadcnt_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.unReadCnt)
}

// optional uint32 lastMsgId = 9;
inline bool GroupRecord::has_lastmsgid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupRecord::set_has_lastmsgid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupRecord::clear_has_lastmsgid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupRecord::clear_lastmsgid() {
  lastmsgid_ = 0u;
  clear_has_lastmsgid();
}
inline ::google::protobuf::uint32 GroupRecord::lastmsgid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.lastMsgId)
  return lastmsgid_;
}
inline void GroupRecord::set_lastmsgid(::google::protobuf::uint32 value) {
  set_has_lastmsgid();
  lastmsgid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.lastMsgId)
}

// required uint32 msgUpTime = 11;
inline bool GroupRecord::has_msguptime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupRecord::set_has_msguptime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupRecord::clear_has_msguptime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupRecord::clear_msguptime() {
  msguptime_ = 0u;
  clear_has_msguptime();
}
inline ::google::protobuf::uint32 GroupRecord::msguptime() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.msgUpTime)
  return msguptime_;
}
inline void GroupRecord::set_msguptime(::google::protobuf::uint32 value) {
  set_has_msguptime();
  msguptime_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.msgUpTime)
}

// required uint32 memberUpTime = 12;
inline bool GroupRecord::has_memberuptime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupRecord::set_has_memberuptime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupRecord::clear_has_memberuptime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupRecord::clear_memberuptime() {
  memberuptime_ = 0u;
  clear_has_memberuptime();
}
inline ::google::protobuf::uint32 GroupRecord::memberuptime() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.memberUpTime)
  return memberuptime_;
}
inline void GroupRecord::set_memberuptime(::google::protobuf::uint32 value) {
  set_has_memberuptime();
  memberuptime_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.memberUpTime)
}

// -------------------------------------------------------------------

// GroupInfo

// required string group_adr = 1;
inline bool GroupInfo::has_group_adr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInfo::set_has_group_adr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInfo::clear_has_group_adr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInfo::clear_group_adr() {
  group_adr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_group_adr();
}
inline const ::std::string& GroupInfo::group_adr() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.group_adr)
  return group_adr_.GetNoArena();
}
inline void GroupInfo::set_group_adr(const ::std::string& value) {
  set_has_group_adr();
  group_adr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.group_adr)
}
#if LANG_CXX11
inline void GroupInfo::set_group_adr(::std::string&& value) {
  set_has_group_adr();
  group_adr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.GroupInfo.group_adr)
}
#endif
inline void GroupInfo::set_group_adr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_group_adr();
  group_adr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.GroupInfo.group_adr)
}
inline void GroupInfo::set_group_adr(const char* value, size_t size) {
  set_has_group_adr();
  group_adr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.GroupInfo.group_adr)
}
inline ::std::string* GroupInfo::mutable_group_adr() {
  set_has_group_adr();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupInfo.group_adr)
  return group_adr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupInfo::release_group_adr() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupInfo.group_adr)
  if (!has_group_adr()) {
    return NULL;
  }
  clear_has_group_adr();
  return group_adr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupInfo::set_allocated_group_adr(::std::string* group_adr) {
  if (group_adr != NULL) {
    set_has_group_adr();
  } else {
    clear_has_group_adr();
  }
  group_adr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_adr);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupInfo.group_adr)
}

// required uint32 group_id = 9;
inline bool GroupInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupInfo::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.group_id)
  return group_id_;
}
inline void GroupInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.group_id)
}

// required string name = 2;
inline bool GroupInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GroupInfo::name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.name)
  return name_.GetNoArena();
}
inline void GroupInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.name)
}
#if LANG_CXX11
inline void GroupInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.GroupInfo.name)
}
#endif
inline void GroupInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.GroupInfo.name)
}
inline void GroupInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.GroupInfo.name)
}
inline ::std::string* GroupInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupInfo::release_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupInfo.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupInfo.name)
}

// required string avatar = 3;
inline bool GroupInfo::has_avatar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupInfo::set_has_avatar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupInfo::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupInfo::clear_avatar() {
  avatar_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_avatar();
}
inline const ::std::string& GroupInfo::avatar() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.avatar)
  return avatar_.GetNoArena();
}
inline void GroupInfo::set_avatar(const ::std::string& value) {
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.avatar)
}
#if LANG_CXX11
inline void GroupInfo::set_avatar(::std::string&& value) {
  set_has_avatar();
  avatar_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.GroupInfo.avatar)
}
#endif
inline void GroupInfo::set_avatar(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.GroupInfo.avatar)
}
inline void GroupInfo::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  avatar_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.GroupInfo.avatar)
}
inline ::std::string* GroupInfo::mutable_avatar() {
  set_has_avatar();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupInfo.avatar)
  return avatar_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GroupInfo::release_avatar() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupInfo.avatar)
  if (!has_avatar()) {
    return NULL;
  }
  clear_has_avatar();
  return avatar_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GroupInfo::set_allocated_avatar(::std::string* avatar) {
  if (avatar != NULL) {
    set_has_avatar();
  } else {
    clear_has_avatar();
  }
  avatar_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), avatar);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupInfo.avatar)
}

// required uint32 owner_uid = 4;
inline bool GroupInfo::has_owner_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupInfo::set_has_owner_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupInfo::clear_has_owner_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupInfo::clear_owner_uid() {
  owner_uid_ = 0u;
  clear_has_owner_uid();
}
inline ::google::protobuf::uint32 GroupInfo::owner_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.owner_uid)
  return owner_uid_;
}
inline void GroupInfo::set_owner_uid(::google::protobuf::uint32 value) {
  set_has_owner_uid();
  owner_uid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.owner_uid)
}

// optional uint32 pair_uid = 5;
inline bool GroupInfo::has_pair_uid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupInfo::set_has_pair_uid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupInfo::clear_has_pair_uid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupInfo::clear_pair_uid() {
  pair_uid_ = 0u;
  clear_has_pair_uid();
}
inline ::google::protobuf::uint32 GroupInfo::pair_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.pair_uid)
  return pair_uid_;
}
inline void GroupInfo::set_pair_uid(::google::protobuf::uint32 value) {
  set_has_pair_uid();
  pair_uid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.pair_uid)
}

// required .PTP.Common.GroupType group_type = 6;
inline bool GroupInfo::has_group_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupInfo::set_has_group_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupInfo::clear_has_group_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupInfo::clear_group_type() {
  group_type_ = 1;
  clear_has_group_type();
}
inline ::PTP::Common::GroupType GroupInfo::group_type() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.group_type)
  return static_cast< ::PTP::Common::GroupType >(group_type_);
}
inline void GroupInfo::set_group_type(::PTP::Common::GroupType value) {
  assert(::PTP::Common::GroupType_IsValid(value));
  set_has_group_type();
  group_type_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.group_type)
}

// required uint32 group_idx = 7;
inline bool GroupInfo::has_group_idx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupInfo::set_has_group_idx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupInfo::clear_has_group_idx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupInfo::clear_group_idx() {
  group_idx_ = 0u;
  clear_has_group_idx();
}
inline ::google::protobuf::uint32 GroupInfo::group_idx() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.group_idx)
  return group_idx_;
}
inline void GroupInfo::set_group_idx(::google::protobuf::uint32 value) {
  set_has_group_idx();
  group_idx_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.group_idx)
}

// required uint32 created_time = 8;
inline bool GroupInfo::has_created_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupInfo::set_has_created_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupInfo::clear_has_created_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupInfo::clear_created_time() {
  created_time_ = 0u;
  clear_has_created_time();
}
inline ::google::protobuf::uint32 GroupInfo::created_time() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.created_time)
  return created_time_;
}
inline void GroupInfo::set_created_time(::google::protobuf::uint32 value) {
  set_has_created_time();
  created_time_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.created_time)
}

// -------------------------------------------------------------------

// MsgInfo

// required uint32 group_id = 1;
inline bool MsgInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 MsgInfo::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.group_id)
  return group_id_;
}
inline void MsgInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.group_id)
}

// required uint32 from_uid = 2;
inline bool MsgInfo::has_from_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgInfo::set_has_from_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgInfo::clear_has_from_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgInfo::clear_from_uid() {
  from_uid_ = 0u;
  clear_has_from_uid();
}
inline ::google::protobuf::uint32 MsgInfo::from_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.from_uid)
  return from_uid_;
}
inline void MsgInfo::set_from_uid(::google::protobuf::uint32 value) {
  set_has_from_uid();
  from_uid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.from_uid)
}

// required uint32 sent_at = 3;
inline bool MsgInfo::has_sent_at() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgInfo::set_has_sent_at() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgInfo::clear_has_sent_at() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgInfo::clear_sent_at() {
  sent_at_ = 0u;
  clear_has_sent_at();
}
inline ::google::protobuf::uint32 MsgInfo::sent_at() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.sent_at)
  return sent_at_;
}
inline void MsgInfo::set_sent_at(::google::protobuf::uint32 value) {
  set_has_sent_at();
  sent_at_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.sent_at)
}

// required uint32 msg_id = 4;
inline bool MsgInfo::has_msg_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgInfo::set_has_msg_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgInfo::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgInfo::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 MsgInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.msg_id)
  return msg_id_;
}
inline void MsgInfo::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.msg_id)
}

// required .PTP.Common.MsgType msg_type = 6;
inline bool MsgInfo::has_msg_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgInfo::set_has_msg_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgInfo::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgInfo::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::PTP::Common::MsgType MsgInfo::msg_type() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.msg_type)
  return static_cast< ::PTP::Common::MsgType >(msg_type_);
}
inline void MsgInfo::set_msg_type(::PTP::Common::MsgType value) {
  assert(::PTP::Common::MsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.msg_type)
}

// required string msg_data = 7;
inline bool MsgInfo::has_msg_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgInfo::set_has_msg_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgInfo::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgInfo::clear_msg_data() {
  msg_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg_data();
}
inline const ::std::string& MsgInfo::msg_data() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.msg_data)
  return msg_data_.GetNoArena();
}
inline void MsgInfo::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.msg_data)
}
#if LANG_CXX11
inline void MsgInfo::set_msg_data(::std::string&& value) {
  set_has_msg_data();
  msg_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.MsgInfo.msg_data)
}
#endif
inline void MsgInfo::set_msg_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg_data();
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.MsgInfo.msg_data)
}
inline void MsgInfo::set_msg_data(const char* value, size_t size) {
  set_has_msg_data();
  msg_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.MsgInfo.msg_data)
}
inline ::std::string* MsgInfo::mutable_msg_data() {
  set_has_msg_data();
  // @@protoc_insertion_point(field_mutable:PTP.Common.MsgInfo.msg_data)
  return msg_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgInfo::release_msg_data() {
  // @@protoc_insertion_point(field_release:PTP.Common.MsgInfo.msg_data)
  if (!has_msg_data()) {
    return NULL;
  }
  clear_has_msg_data();
  return msg_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgInfo::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data != NULL) {
    set_has_msg_data();
  } else {
    clear_has_msg_data();
  }
  msg_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg_data);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.MsgInfo.msg_data)
}

// -------------------------------------------------------------------

// DevicesInfo

// required .PTP.Common.ClientType client_type = 1;
inline bool DevicesInfo::has_client_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DevicesInfo::set_has_client_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DevicesInfo::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DevicesInfo::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
inline ::PTP::Common::ClientType DevicesInfo::client_type() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.client_type)
  return static_cast< ::PTP::Common::ClientType >(client_type_);
}
inline void DevicesInfo::set_client_type(::PTP::Common::ClientType value) {
  assert(::PTP::Common::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.client_type)
}

// required string client_version = 2;
inline bool DevicesInfo::has_client_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DevicesInfo::set_has_client_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DevicesInfo::clear_has_client_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DevicesInfo::clear_client_version() {
  client_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_version();
}
inline const ::std::string& DevicesInfo::client_version() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.client_version)
  return client_version_.GetNoArena();
}
inline void DevicesInfo::set_client_version(const ::std::string& value) {
  set_has_client_version();
  client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.client_version)
}
#if LANG_CXX11
inline void DevicesInfo::set_client_version(::std::string&& value) {
  set_has_client_version();
  client_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.DevicesInfo.client_version)
}
#endif
inline void DevicesInfo::set_client_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_version();
  client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.DevicesInfo.client_version)
}
inline void DevicesInfo::set_client_version(const char* value, size_t size) {
  set_has_client_version();
  client_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.DevicesInfo.client_version)
}
inline ::std::string* DevicesInfo::mutable_client_version() {
  set_has_client_version();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.client_version)
  return client_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevicesInfo::release_client_version() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.client_version)
  if (!has_client_version()) {
    return NULL;
  }
  clear_has_client_version();
  return client_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevicesInfo::set_allocated_client_version(::std::string* client_version) {
  if (client_version != NULL) {
    set_has_client_version();
  } else {
    clear_has_client_version();
  }
  client_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_version);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.client_version)
}

// required uint32 login_time = 3;
inline bool DevicesInfo::has_login_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DevicesInfo::set_has_login_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DevicesInfo::clear_has_login_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DevicesInfo::clear_login_time() {
  login_time_ = 0u;
  clear_has_login_time();
}
inline ::google::protobuf::uint32 DevicesInfo::login_time() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.login_time)
  return login_time_;
}
inline void DevicesInfo::set_login_time(::google::protobuf::uint32 value) {
  set_has_login_time();
  login_time_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.login_time)
}

// required string browser_name = 4;
inline bool DevicesInfo::has_browser_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DevicesInfo::set_has_browser_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DevicesInfo::clear_has_browser_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DevicesInfo::clear_browser_name() {
  browser_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_browser_name();
}
inline const ::std::string& DevicesInfo::browser_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.browser_name)
  return browser_name_.GetNoArena();
}
inline void DevicesInfo::set_browser_name(const ::std::string& value) {
  set_has_browser_name();
  browser_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.browser_name)
}
#if LANG_CXX11
inline void DevicesInfo::set_browser_name(::std::string&& value) {
  set_has_browser_name();
  browser_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.DevicesInfo.browser_name)
}
#endif
inline void DevicesInfo::set_browser_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_browser_name();
  browser_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.DevicesInfo.browser_name)
}
inline void DevicesInfo::set_browser_name(const char* value, size_t size) {
  set_has_browser_name();
  browser_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.DevicesInfo.browser_name)
}
inline ::std::string* DevicesInfo::mutable_browser_name() {
  set_has_browser_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.browser_name)
  return browser_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevicesInfo::release_browser_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.browser_name)
  if (!has_browser_name()) {
    return NULL;
  }
  clear_has_browser_name();
  return browser_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevicesInfo::set_allocated_browser_name(::std::string* browser_name) {
  if (browser_name != NULL) {
    set_has_browser_name();
  } else {
    clear_has_browser_name();
  }
  browser_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), browser_name);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.browser_name)
}

// required string browser_version = 5;
inline bool DevicesInfo::has_browser_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DevicesInfo::set_has_browser_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DevicesInfo::clear_has_browser_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DevicesInfo::clear_browser_version() {
  browser_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_browser_version();
}
inline const ::std::string& DevicesInfo::browser_version() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.browser_version)
  return browser_version_.GetNoArena();
}
inline void DevicesInfo::set_browser_version(const ::std::string& value) {
  set_has_browser_version();
  browser_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.browser_version)
}
#if LANG_CXX11
inline void DevicesInfo::set_browser_version(::std::string&& value) {
  set_has_browser_version();
  browser_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.DevicesInfo.browser_version)
}
#endif
inline void DevicesInfo::set_browser_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_browser_version();
  browser_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.DevicesInfo.browser_version)
}
inline void DevicesInfo::set_browser_version(const char* value, size_t size) {
  set_has_browser_version();
  browser_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.DevicesInfo.browser_version)
}
inline ::std::string* DevicesInfo::mutable_browser_version() {
  set_has_browser_version();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.browser_version)
  return browser_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevicesInfo::release_browser_version() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.browser_version)
  if (!has_browser_version()) {
    return NULL;
  }
  clear_has_browser_version();
  return browser_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevicesInfo::set_allocated_browser_version(::std::string* browser_version) {
  if (browser_version != NULL) {
    set_has_browser_version();
  } else {
    clear_has_browser_version();
  }
  browser_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), browser_version);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.browser_version)
}

// required string os_name = 6;
inline bool DevicesInfo::has_os_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DevicesInfo::set_has_os_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DevicesInfo::clear_has_os_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DevicesInfo::clear_os_name() {
  os_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os_name();
}
inline const ::std::string& DevicesInfo::os_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.os_name)
  return os_name_.GetNoArena();
}
inline void DevicesInfo::set_os_name(const ::std::string& value) {
  set_has_os_name();
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.os_name)
}
#if LANG_CXX11
inline void DevicesInfo::set_os_name(::std::string&& value) {
  set_has_os_name();
  os_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.DevicesInfo.os_name)
}
#endif
inline void DevicesInfo::set_os_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_os_name();
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.DevicesInfo.os_name)
}
inline void DevicesInfo::set_os_name(const char* value, size_t size) {
  set_has_os_name();
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.DevicesInfo.os_name)
}
inline ::std::string* DevicesInfo::mutable_os_name() {
  set_has_os_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.os_name)
  return os_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevicesInfo::release_os_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.os_name)
  if (!has_os_name()) {
    return NULL;
  }
  clear_has_os_name();
  return os_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevicesInfo::set_allocated_os_name(::std::string* os_name) {
  if (os_name != NULL) {
    set_has_os_name();
  } else {
    clear_has_os_name();
  }
  os_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_name);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.os_name)
}

// required string os_version = 7;
inline bool DevicesInfo::has_os_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DevicesInfo::set_has_os_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DevicesInfo::clear_has_os_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DevicesInfo::clear_os_version() {
  os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_os_version();
}
inline const ::std::string& DevicesInfo::os_version() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.os_version)
  return os_version_.GetNoArena();
}
inline void DevicesInfo::set_os_version(const ::std::string& value) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.os_version)
}
#if LANG_CXX11
inline void DevicesInfo::set_os_version(::std::string&& value) {
  set_has_os_version();
  os_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.DevicesInfo.os_version)
}
#endif
inline void DevicesInfo::set_os_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.DevicesInfo.os_version)
}
inline void DevicesInfo::set_os_version(const char* value, size_t size) {
  set_has_os_version();
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.DevicesInfo.os_version)
}
inline ::std::string* DevicesInfo::mutable_os_version() {
  set_has_os_version();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.os_version)
  return os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevicesInfo::release_os_version() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.os_version)
  if (!has_os_version()) {
    return NULL;
  }
  clear_has_os_version();
  return os_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevicesInfo::set_allocated_os_version(::std::string* os_version) {
  if (os_version != NULL) {
    set_has_os_version();
  } else {
    clear_has_os_version();
  }
  os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_version);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.os_version)
}

// required bool is_intel = 8;
inline bool DevicesInfo::has_is_intel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DevicesInfo::set_has_is_intel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DevicesInfo::clear_has_is_intel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DevicesInfo::clear_is_intel() {
  is_intel_ = false;
  clear_has_is_intel();
}
inline bool DevicesInfo::is_intel() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.is_intel)
  return is_intel_;
}
inline void DevicesInfo::set_is_intel(bool value) {
  set_has_is_intel();
  is_intel_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.is_intel)
}

// required uint32 uid = 9;
inline bool DevicesInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DevicesInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DevicesInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DevicesInfo::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 DevicesInfo::uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.uid)
  return uid_;
}
inline void DevicesInfo::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.uid)
}

// required string client_id = 10;
inline bool DevicesInfo::has_client_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DevicesInfo::set_has_client_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DevicesInfo::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DevicesInfo::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
inline const ::std::string& DevicesInfo::client_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.client_id)
  return client_id_.GetNoArena();
}
inline void DevicesInfo::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.client_id)
}
#if LANG_CXX11
inline void DevicesInfo::set_client_id(::std::string&& value) {
  set_has_client_id();
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.DevicesInfo.client_id)
}
#endif
inline void DevicesInfo::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.DevicesInfo.client_id)
}
inline void DevicesInfo::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.DevicesInfo.client_id)
}
inline ::std::string* DevicesInfo::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DevicesInfo::release_client_id() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.client_id)
  if (!has_client_id()) {
    return NULL;
  }
  clear_has_client_id();
  return client_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DevicesInfo::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.client_id)
}

// -------------------------------------------------------------------

// InputPhoneContact

// required uint64 client_id = 1;
inline bool InputPhoneContact::has_client_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InputPhoneContact::set_has_client_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InputPhoneContact::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InputPhoneContact::clear_client_id() {
  client_id_ = GOOGLE_ULONGLONG(0);
  clear_has_client_id();
}
inline ::google::protobuf::uint64 InputPhoneContact::client_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.InputPhoneContact.client_id)
  return client_id_;
}
inline void InputPhoneContact::set_client_id(::google::protobuf::uint64 value) {
  set_has_client_id();
  client_id_ = value;
  // @@protoc_insertion_point(field_set:PTP.Common.InputPhoneContact.client_id)
}

// optional string phone = 2;
inline bool InputPhoneContact::has_phone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputPhoneContact::set_has_phone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputPhoneContact::clear_has_phone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputPhoneContact::clear_phone() {
  phone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_phone();
}
inline const ::std::string& InputPhoneContact::phone() const {
  // @@protoc_insertion_point(field_get:PTP.Common.InputPhoneContact.phone)
  return phone_.GetNoArena();
}
inline void InputPhoneContact::set_phone(const ::std::string& value) {
  set_has_phone();
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.InputPhoneContact.phone)
}
#if LANG_CXX11
inline void InputPhoneContact::set_phone(::std::string&& value) {
  set_has_phone();
  phone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.InputPhoneContact.phone)
}
#endif
inline void InputPhoneContact::set_phone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_phone();
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.InputPhoneContact.phone)
}
inline void InputPhoneContact::set_phone(const char* value, size_t size) {
  set_has_phone();
  phone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.InputPhoneContact.phone)
}
inline ::std::string* InputPhoneContact::mutable_phone() {
  set_has_phone();
  // @@protoc_insertion_point(field_mutable:PTP.Common.InputPhoneContact.phone)
  return phone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputPhoneContact::release_phone() {
  // @@protoc_insertion_point(field_release:PTP.Common.InputPhoneContact.phone)
  if (!has_phone()) {
    return NULL;
  }
  clear_has_phone();
  return phone_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputPhoneContact::set_allocated_phone(::std::string* phone) {
  if (phone != NULL) {
    set_has_phone();
  } else {
    clear_has_phone();
  }
  phone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), phone);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.InputPhoneContact.phone)
}

// optional string first_name = 3;
inline bool InputPhoneContact::has_first_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputPhoneContact::set_has_first_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputPhoneContact::clear_has_first_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputPhoneContact::clear_first_name() {
  first_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_first_name();
}
inline const ::std::string& InputPhoneContact::first_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.InputPhoneContact.first_name)
  return first_name_.GetNoArena();
}
inline void InputPhoneContact::set_first_name(const ::std::string& value) {
  set_has_first_name();
  first_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.InputPhoneContact.first_name)
}
#if LANG_CXX11
inline void InputPhoneContact::set_first_name(::std::string&& value) {
  set_has_first_name();
  first_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.InputPhoneContact.first_name)
}
#endif
inline void InputPhoneContact::set_first_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_first_name();
  first_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.InputPhoneContact.first_name)
}
inline void InputPhoneContact::set_first_name(const char* value, size_t size) {
  set_has_first_name();
  first_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.InputPhoneContact.first_name)
}
inline ::std::string* InputPhoneContact::mutable_first_name() {
  set_has_first_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.InputPhoneContact.first_name)
  return first_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputPhoneContact::release_first_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.InputPhoneContact.first_name)
  if (!has_first_name()) {
    return NULL;
  }
  clear_has_first_name();
  return first_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputPhoneContact::set_allocated_first_name(::std::string* first_name) {
  if (first_name != NULL) {
    set_has_first_name();
  } else {
    clear_has_first_name();
  }
  first_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), first_name);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.InputPhoneContact.first_name)
}

// optional string last_name = 4;
inline bool InputPhoneContact::has_last_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputPhoneContact::set_has_last_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputPhoneContact::clear_has_last_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputPhoneContact::clear_last_name() {
  last_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_last_name();
}
inline const ::std::string& InputPhoneContact::last_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.InputPhoneContact.last_name)
  return last_name_.GetNoArena();
}
inline void InputPhoneContact::set_last_name(const ::std::string& value) {
  set_has_last_name();
  last_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PTP.Common.InputPhoneContact.last_name)
}
#if LANG_CXX11
inline void InputPhoneContact::set_last_name(::std::string&& value) {
  set_has_last_name();
  last_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PTP.Common.InputPhoneContact.last_name)
}
#endif
inline void InputPhoneContact::set_last_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_last_name();
  last_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PTP.Common.InputPhoneContact.last_name)
}
inline void InputPhoneContact::set_last_name(const char* value, size_t size) {
  set_has_last_name();
  last_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.InputPhoneContact.last_name)
}
inline ::std::string* InputPhoneContact::mutable_last_name() {
  set_has_last_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.InputPhoneContact.last_name)
  return last_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputPhoneContact::release_last_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.InputPhoneContact.last_name)
  if (!has_last_name()) {
    return NULL;
  }
  clear_has_last_name();
  return last_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputPhoneContact::set_allocated_last_name(::std::string* last_name) {
  if (last_name != NULL) {
    set_has_last_name();
  } else {
    clear_has_last_name();
  }
  last_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_name);
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.InputPhoneContact.last_name)
}

// -------------------------------------------------------------------

// BuddyQueryParam

// repeated string addressList = 1;
inline int BuddyQueryParam::addresslist_size() const {
  return addresslist_.size();
}
inline void BuddyQueryParam::clear_addresslist() {
  addresslist_.Clear();
}
inline const ::std::string& BuddyQueryParam::addresslist(int index) const {
  // @@protoc_insertion_point(field_get:PTP.Common.BuddyQueryParam.addressList)
  return addresslist_.Get(index);
}
inline ::std::string* BuddyQueryParam::mutable_addresslist(int index) {
  // @@protoc_insertion_point(field_mutable:PTP.Common.BuddyQueryParam.addressList)
  return addresslist_.Mutable(index);
}
inline void BuddyQueryParam::set_addresslist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:PTP.Common.BuddyQueryParam.addressList)
  addresslist_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BuddyQueryParam::set_addresslist(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:PTP.Common.BuddyQueryParam.addressList)
  addresslist_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BuddyQueryParam::set_addresslist(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  addresslist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PTP.Common.BuddyQueryParam.addressList)
}
inline void BuddyQueryParam::set_addresslist(int index, const char* value, size_t size) {
  addresslist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.BuddyQueryParam.addressList)
}
inline ::std::string* BuddyQueryParam::add_addresslist() {
  // @@protoc_insertion_point(field_add_mutable:PTP.Common.BuddyQueryParam.addressList)
  return addresslist_.Add();
}
inline void BuddyQueryParam::add_addresslist(const ::std::string& value) {
  addresslist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PTP.Common.BuddyQueryParam.addressList)
}
#if LANG_CXX11
inline void BuddyQueryParam::add_addresslist(::std::string&& value) {
  addresslist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PTP.Common.BuddyQueryParam.addressList)
}
#endif
inline void BuddyQueryParam::add_addresslist(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  addresslist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PTP.Common.BuddyQueryParam.addressList)
}
inline void BuddyQueryParam::add_addresslist(const char* value, size_t size) {
  addresslist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PTP.Common.BuddyQueryParam.addressList)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BuddyQueryParam::addresslist() const {
  // @@protoc_insertion_point(field_list:PTP.Common.BuddyQueryParam.addressList)
  return addresslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BuddyQueryParam::mutable_addresslist() {
  // @@protoc_insertion_point(field_mutable_list:PTP.Common.BuddyQueryParam.addressList)
  return &addresslist_;
}

// repeated string usernameList = 2;
inline int BuddyQueryParam::usernamelist_size() const {
  return usernamelist_.size();
}
inline void BuddyQueryParam::clear_usernamelist() {
  usernamelist_.Clear();
}
inline const ::std::string& BuddyQueryParam::usernamelist(int index) const {
  // @@protoc_insertion_point(field_get:PTP.Common.BuddyQueryParam.usernameList)
  return usernamelist_.Get(index);
}
inline ::std::string* BuddyQueryParam::mutable_usernamelist(int index) {
  // @@protoc_insertion_point(field_mutable:PTP.Common.BuddyQueryParam.usernameList)
  return usernamelist_.Mutable(index);
}
inline void BuddyQueryParam::set_usernamelist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:PTP.Common.BuddyQueryParam.usernameList)
  usernamelist_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BuddyQueryParam::set_usernamelist(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:PTP.Common.BuddyQueryParam.usernameList)
  usernamelist_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BuddyQueryParam::set_usernamelist(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usernamelist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PTP.Common.BuddyQueryParam.usernameList)
}
inline void BuddyQueryParam::set_usernamelist(int index, const char* value, size_t size) {
  usernamelist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.BuddyQueryParam.usernameList)
}
inline ::std::string* BuddyQueryParam::add_usernamelist() {
  // @@protoc_insertion_point(field_add_mutable:PTP.Common.BuddyQueryParam.usernameList)
  return usernamelist_.Add();
}
inline void BuddyQueryParam::add_usernamelist(const ::std::string& value) {
  usernamelist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PTP.Common.BuddyQueryParam.usernameList)
}
#if LANG_CXX11
inline void BuddyQueryParam::add_usernamelist(::std::string&& value) {
  usernamelist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PTP.Common.BuddyQueryParam.usernameList)
}
#endif
inline void BuddyQueryParam::add_usernamelist(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  usernamelist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PTP.Common.BuddyQueryParam.usernameList)
}
inline void BuddyQueryParam::add_usernamelist(const char* value, size_t size) {
  usernamelist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PTP.Common.BuddyQueryParam.usernameList)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BuddyQueryParam::usernamelist() const {
  // @@protoc_insertion_point(field_list:PTP.Common.BuddyQueryParam.usernameList)
  return usernamelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BuddyQueryParam::mutable_usernamelist() {
  // @@protoc_insertion_point(field_mutable_list:PTP.Common.BuddyQueryParam.usernameList)
  return &usernamelist_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Common
}  // namespace PTP

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::PTP::Common::SID> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::CID_AUTH> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::CID_BUDDY> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::CID_MSG> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::CID_GROUP> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::CID_FILE> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::CID_SERVER> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::CID_OTHER> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::CID_SWITCH> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::QRCODE_TYPE> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::ERR> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::SwitchType> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::UserStat> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::MsgType> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::ClientType> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::SessionStat> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::ShieldStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::BuddyModifyAction> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::GroupType> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::GroupMemberStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::GroupModifyAction> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::GroupMemberModifyAction> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_PTP_2eCommon_2eproto
