// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PTP.Common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_PTP_2eCommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_PTP_2eCommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_PTP_2eCommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_PTP_2eCommon_2eproto {
  static const uint32_t offsets[];
};
namespace PTP {
namespace Common {
class BuddyQueryParam;
struct BuddyQueryParamDefaultTypeInternal;
extern BuddyQueryParamDefaultTypeInternal _BuddyQueryParam_default_instance_;
class DevicesInfo;
struct DevicesInfoDefaultTypeInternal;
extern DevicesInfoDefaultTypeInternal _DevicesInfo_default_instance_;
class GroupInfo;
struct GroupInfoDefaultTypeInternal;
extern GroupInfoDefaultTypeInternal _GroupInfo_default_instance_;
class GroupMember;
struct GroupMemberDefaultTypeInternal;
extern GroupMemberDefaultTypeInternal _GroupMember_default_instance_;
class GroupRecord;
struct GroupRecordDefaultTypeInternal;
extern GroupRecordDefaultTypeInternal _GroupRecord_default_instance_;
class InputPhoneContact;
struct InputPhoneContactDefaultTypeInternal;
extern InputPhoneContactDefaultTypeInternal _InputPhoneContact_default_instance_;
class IpAddress;
struct IpAddressDefaultTypeInternal;
extern IpAddressDefaultTypeInternal _IpAddress_default_instance_;
class MsgInfo;
struct MsgInfoDefaultTypeInternal;
extern MsgInfoDefaultTypeInternal _MsgInfo_default_instance_;
class MsgInfoList;
struct MsgInfoListDefaultTypeInternal;
extern MsgInfoListDefaultTypeInternal _MsgInfoList_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
class UserStatInfo;
struct UserStatInfoDefaultTypeInternal;
extern UserStatInfoDefaultTypeInternal _UserStatInfo_default_instance_;
}  // namespace Common
}  // namespace PTP
PROTOBUF_NAMESPACE_OPEN
template<> ::PTP::Common::BuddyQueryParam* Arena::CreateMaybeMessage<::PTP::Common::BuddyQueryParam>(Arena*);
template<> ::PTP::Common::DevicesInfo* Arena::CreateMaybeMessage<::PTP::Common::DevicesInfo>(Arena*);
template<> ::PTP::Common::GroupInfo* Arena::CreateMaybeMessage<::PTP::Common::GroupInfo>(Arena*);
template<> ::PTP::Common::GroupMember* Arena::CreateMaybeMessage<::PTP::Common::GroupMember>(Arena*);
template<> ::PTP::Common::GroupRecord* Arena::CreateMaybeMessage<::PTP::Common::GroupRecord>(Arena*);
template<> ::PTP::Common::InputPhoneContact* Arena::CreateMaybeMessage<::PTP::Common::InputPhoneContact>(Arena*);
template<> ::PTP::Common::IpAddress* Arena::CreateMaybeMessage<::PTP::Common::IpAddress>(Arena*);
template<> ::PTP::Common::MsgInfo* Arena::CreateMaybeMessage<::PTP::Common::MsgInfo>(Arena*);
template<> ::PTP::Common::MsgInfoList* Arena::CreateMaybeMessage<::PTP::Common::MsgInfoList>(Arena*);
template<> ::PTP::Common::UserInfo* Arena::CreateMaybeMessage<::PTP::Common::UserInfo>(Arena*);
template<> ::PTP::Common::UserStatInfo* Arena::CreateMaybeMessage<::PTP::Common::UserStatInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PTP {
namespace Common {

enum ERR : int {
  NO_ERROR = 0,
  E_SYSTEM = 1,
  E_GROUP_CREATE_PAIR_GROUP_MEMBER_SIE_INVALID = 2,
  E_GROUP_CREATE_PAIR_GROUP_NO_REG_USER = 3,
  E_GROUP_HAS_CREATED = 4,
  E_REASON_NO_ROUTE_SERVER = 5,
  E_REASON_NO_LOGIN_SERVER = 6,
  E_REASON_NO_DB_SERVER = 7,
  E_LOGIN_ERROR = 8,
  E_PB_PARSE_ERROR = 9,
  E_SWITCH_USER_NO_ONLINE = 10,
  E_USERNAME_EXISTS = 11,
  E_USERNAME_INVALID = 12,
  E_CLIENT = 1003,
  E_CLIENT_TIMEOUT = 1004,
  E_SERVER_NOT_FOUND = 404
};
bool ERR_IsValid(int value);
constexpr ERR ERR_MIN = NO_ERROR;
constexpr ERR ERR_MAX = E_CLIENT_TIMEOUT;
constexpr int ERR_ARRAYSIZE = ERR_MAX + 1;

const std::string& ERR_Name(ERR value);
template<typename T>
inline const std::string& ERR_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERR>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERR_Name.");
  return ERR_Name(static_cast<ERR>(enum_t_value));
}
bool ERR_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERR* value);
enum SwitchType : int {
  SwitchType_Apply = 1,
  SwitchType_Offer = 2,
  SwitchType_Answer = 3,
  SwitchType_Candidate = 4,
  SwitchType_Ready = 5,
  SwitchType_Bye = 6
};
bool SwitchType_IsValid(int value);
constexpr SwitchType SwitchType_MIN = SwitchType_Apply;
constexpr SwitchType SwitchType_MAX = SwitchType_Bye;
constexpr int SwitchType_ARRAYSIZE = SwitchType_MAX + 1;

const std::string& SwitchType_Name(SwitchType value);
template<typename T>
inline const std::string& SwitchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SwitchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SwitchType_Name.");
  return SwitchType_Name(static_cast<SwitchType>(enum_t_value));
}
bool SwitchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SwitchType* value);
enum UserStat : int {
  USER_STAT_ONLINE = 1,
  USER_STAT_OFFLINE = 2,
  USER_STAT_LEAVE = 3
};
bool UserStat_IsValid(int value);
constexpr UserStat UserStat_MIN = USER_STAT_ONLINE;
constexpr UserStat UserStat_MAX = USER_STAT_LEAVE;
constexpr int UserStat_ARRAYSIZE = UserStat_MAX + 1;

const std::string& UserStat_Name(UserStat value);
template<typename T>
inline const std::string& UserStat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UserStat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UserStat_Name.");
  return UserStat_Name(static_cast<UserStat>(enum_t_value));
}
bool UserStat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStat* value);
enum MsgType : int {
  MSG_TYPE_TEXT = 1,
  MSG_TYPE_AUDIO = 2
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = MSG_TYPE_TEXT;
constexpr MsgType MsgType_MAX = MSG_TYPE_AUDIO;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const std::string& MsgType_Name(MsgType value);
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return MsgType_Name(static_cast<MsgType>(enum_t_value));
}
bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value);
enum ClientType : int {
  CLIENT_TYPE_WEB = 1,
  CLIENT_TYPE_PC = 2,
  CLIENT_TYPE_MAC = 3,
  CLIENT_TYPE_IOS = 17,
  CLIENT_TYPE_ANDROID = 18
};
bool ClientType_IsValid(int value);
constexpr ClientType ClientType_MIN = CLIENT_TYPE_WEB;
constexpr ClientType ClientType_MAX = CLIENT_TYPE_ANDROID;
constexpr int ClientType_ARRAYSIZE = ClientType_MAX + 1;

const std::string& ClientType_Name(ClientType value);
template<typename T>
inline const std::string& ClientType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientType_Name.");
  return ClientType_Name(static_cast<ClientType>(enum_t_value));
}
bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value);
enum SessionStat : int {
  SESSION_STAT_OK = 0,
  SESSION_STAT_DELETE = 1
};
bool SessionStat_IsValid(int value);
constexpr SessionStat SessionStat_MIN = SESSION_STAT_OK;
constexpr SessionStat SessionStat_MAX = SESSION_STAT_DELETE;
constexpr int SessionStat_ARRAYSIZE = SessionStat_MAX + 1;

const std::string& SessionStat_Name(SessionStat value);
template<typename T>
inline const std::string& SessionStat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionStat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionStat_Name.");
  return SessionStat_Name(static_cast<SessionStat>(enum_t_value));
}
bool SessionStat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionStat* value);
enum ShieldStatus : int {
  SHIELD_STATUS_OK = 0,
  SHIELD_STATUS_DELETE = 1
};
bool ShieldStatus_IsValid(int value);
constexpr ShieldStatus ShieldStatus_MIN = SHIELD_STATUS_OK;
constexpr ShieldStatus ShieldStatus_MAX = SHIELD_STATUS_DELETE;
constexpr int ShieldStatus_ARRAYSIZE = ShieldStatus_MAX + 1;

const std::string& ShieldStatus_Name(ShieldStatus value);
template<typename T>
inline const std::string& ShieldStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShieldStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShieldStatus_Name.");
  return ShieldStatus_Name(static_cast<ShieldStatus>(enum_t_value));
}
bool ShieldStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShieldStatus* value);
enum BuddyModifyAction : int {
  BuddyModifyAction_nickname = 1,
  BuddyModifyAction_avatar = 2,
  BuddyModifyAction_sign_info = 3,
  BuddyModifyAction_user_name = 4,
  BuddyModifyAction_first_name = 5,
  BuddyModifyAction_last_name = 6
};
bool BuddyModifyAction_IsValid(int value);
constexpr BuddyModifyAction BuddyModifyAction_MIN = BuddyModifyAction_nickname;
constexpr BuddyModifyAction BuddyModifyAction_MAX = BuddyModifyAction_last_name;
constexpr int BuddyModifyAction_ARRAYSIZE = BuddyModifyAction_MAX + 1;

const std::string& BuddyModifyAction_Name(BuddyModifyAction value);
template<typename T>
inline const std::string& BuddyModifyAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BuddyModifyAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BuddyModifyAction_Name.");
  return BuddyModifyAction_Name(static_cast<BuddyModifyAction>(enum_t_value));
}
bool BuddyModifyAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BuddyModifyAction* value);
enum GroupType : int {
  GROUP_TYPE_PAIR = 1,
  GROUP_TYPE_MULTI = 2
};
bool GroupType_IsValid(int value);
constexpr GroupType GroupType_MIN = GROUP_TYPE_PAIR;
constexpr GroupType GroupType_MAX = GROUP_TYPE_MULTI;
constexpr int GroupType_ARRAYSIZE = GroupType_MAX + 1;

const std::string& GroupType_Name(GroupType value);
template<typename T>
inline const std::string& GroupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupType_Name.");
  return GroupType_Name(static_cast<GroupType>(enum_t_value));
}
bool GroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupType* value);
enum GroupMemberStatus : int {
  GROUP_MEMBER_STATUS_NORMAL = 1
};
bool GroupMemberStatus_IsValid(int value);
constexpr GroupMemberStatus GroupMemberStatus_MIN = GROUP_MEMBER_STATUS_NORMAL;
constexpr GroupMemberStatus GroupMemberStatus_MAX = GROUP_MEMBER_STATUS_NORMAL;
constexpr int GroupMemberStatus_ARRAYSIZE = GroupMemberStatus_MAX + 1;

const std::string& GroupMemberStatus_Name(GroupMemberStatus value);
template<typename T>
inline const std::string& GroupMemberStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupMemberStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupMemberStatus_Name.");
  return GroupMemberStatus_Name(static_cast<GroupMemberStatus>(enum_t_value));
}
bool GroupMemberStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupMemberStatus* value);
enum GroupModifyAction : int {
  GroupModifyAction_name = 1,
  GroupModifyAction_avatar = 2
};
bool GroupModifyAction_IsValid(int value);
constexpr GroupModifyAction GroupModifyAction_MIN = GroupModifyAction_name;
constexpr GroupModifyAction GroupModifyAction_MAX = GroupModifyAction_avatar;
constexpr int GroupModifyAction_ARRAYSIZE = GroupModifyAction_MAX + 1;

const std::string& GroupModifyAction_Name(GroupModifyAction value);
template<typename T>
inline const std::string& GroupModifyAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupModifyAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupModifyAction_Name.");
  return GroupModifyAction_Name(static_cast<GroupModifyAction>(enum_t_value));
}
bool GroupModifyAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupModifyAction* value);
enum GroupMemberModifyAction : int {
  GroupMemberModifyAction_DEL = 1,
  GroupMemberModifyAction_ADD = 2
};
bool GroupMemberModifyAction_IsValid(int value);
constexpr GroupMemberModifyAction GroupMemberModifyAction_MIN = GroupMemberModifyAction_DEL;
constexpr GroupMemberModifyAction GroupMemberModifyAction_MAX = GroupMemberModifyAction_ADD;
constexpr int GroupMemberModifyAction_ARRAYSIZE = GroupMemberModifyAction_MAX + 1;

const std::string& GroupMemberModifyAction_Name(GroupMemberModifyAction value);
template<typename T>
inline const std::string& GroupMemberModifyAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GroupMemberModifyAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GroupMemberModifyAction_Name.");
  return GroupMemberModifyAction_Name(static_cast<GroupMemberModifyAction>(enum_t_value));
}
bool GroupMemberModifyAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupMemberModifyAction* value);
// ===================================================================

class IpAddress final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.IpAddress) */ {
 public:
  inline IpAddress() : IpAddress(nullptr) {}
  ~IpAddress() override;
  explicit PROTOBUF_CONSTEXPR IpAddress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IpAddress(const IpAddress& from);
  IpAddress(IpAddress&& from) noexcept
    : IpAddress() {
    *this = ::std::move(from);
  }

  inline IpAddress& operator=(const IpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline IpAddress& operator=(IpAddress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const IpAddress& default_instance() {
    return *internal_default_instance();
  }
  static inline const IpAddress* internal_default_instance() {
    return reinterpret_cast<const IpAddress*>(
               &_IpAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IpAddress& a, IpAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(IpAddress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IpAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IpAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IpAddress>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const IpAddress& from);
  void MergeFrom(const IpAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IpAddress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.IpAddress";
  }
  protected:
  explicit IpAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // required string ip = 1;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // required uint32 port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.IpAddress)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    uint32_t port_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class UserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  explicit PROTOBUF_CONSTEXPR UserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserInfo(const UserInfo& from);
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.UserInfo";
  }
  protected:
  explicit UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPubKeyFieldNumber = 2,
    kAvatarFieldNumber = 3,
    kUserNameFieldNumber = 5,
    kNickNameFieldNumber = 6,
    kSignInfoFieldNumber = 7,
    kFirstNameFieldNumber = 9,
    kLastNameFieldNumber = 10,
    kStatusFieldNumber = 4,
    kUidFieldNumber = 8,
    kLoginTimeFieldNumber = 11,
    kIsOnlineFieldNumber = 12,
  };
  // required string address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // required bytes pub_key = 2;
  bool has_pub_key() const;
  private:
  bool _internal_has_pub_key() const;
  public:
  void clear_pub_key();
  const std::string& pub_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub_key();
  PROTOBUF_NODISCARD std::string* release_pub_key();
  void set_allocated_pub_key(std::string* pub_key);
  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(const std::string& value);
  std::string* _internal_mutable_pub_key();
  public:

  // required string avatar = 3;
  bool has_avatar() const;
  private:
  bool _internal_has_avatar() const;
  public:
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // optional string user_name = 5;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional string nick_name = 6;
  bool has_nick_name() const;
  private:
  bool _internal_has_nick_name() const;
  public:
  void clear_nick_name();
  const std::string& nick_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nick_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nick_name();
  PROTOBUF_NODISCARD std::string* release_nick_name();
  void set_allocated_nick_name(std::string* nick_name);
  private:
  const std::string& _internal_nick_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nick_name(const std::string& value);
  std::string* _internal_mutable_nick_name();
  public:

  // optional string sign_info = 7;
  bool has_sign_info() const;
  private:
  bool _internal_has_sign_info() const;
  public:
  void clear_sign_info();
  const std::string& sign_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign_info();
  PROTOBUF_NODISCARD std::string* release_sign_info();
  void set_allocated_sign_info(std::string* sign_info);
  private:
  const std::string& _internal_sign_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_info(const std::string& value);
  std::string* _internal_mutable_sign_info();
  public:

  // optional string first_name = 9;
  bool has_first_name() const;
  private:
  bool _internal_has_first_name() const;
  public:
  void clear_first_name();
  const std::string& first_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_name();
  PROTOBUF_NODISCARD std::string* release_first_name();
  void set_allocated_first_name(std::string* first_name);
  private:
  const std::string& _internal_first_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name(const std::string& value);
  std::string* _internal_mutable_first_name();
  public:

  // optional string last_name = 10;
  bool has_last_name() const;
  private:
  bool _internal_has_last_name() const;
  public:
  void clear_last_name();
  const std::string& last_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_name();
  PROTOBUF_NODISCARD std::string* release_last_name();
  void set_allocated_last_name(std::string* last_name);
  private:
  const std::string& _internal_last_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name(const std::string& value);
  std::string* _internal_mutable_last_name();
  public:

  // required uint32 status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // required uint32 uid = 8;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  uint32_t uid() const;
  void set_uid(uint32_t value);
  private:
  uint32_t _internal_uid() const;
  void _internal_set_uid(uint32_t value);
  public:

  // optional uint32 login_time = 11;
  bool has_login_time() const;
  private:
  bool _internal_has_login_time() const;
  public:
  void clear_login_time();
  uint32_t login_time() const;
  void set_login_time(uint32_t value);
  private:
  uint32_t _internal_login_time() const;
  void _internal_set_login_time(uint32_t value);
  public:

  // optional bool is_online = 12;
  bool has_is_online() const;
  private:
  bool _internal_has_is_online() const;
  public:
  void clear_is_online();
  bool is_online() const;
  void set_is_online(bool value);
  private:
  bool _internal_is_online() const;
  void _internal_set_is_online(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.UserInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_info_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_name_;
    uint32_t status_;
    uint32_t uid_;
    uint32_t login_time_;
    bool is_online_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class UserStatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.UserStatInfo) */ {
 public:
  inline UserStatInfo() : UserStatInfo(nullptr) {}
  ~UserStatInfo() override;
  explicit PROTOBUF_CONSTEXPR UserStatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserStatInfo(const UserStatInfo& from);
  UserStatInfo(UserStatInfo&& from) noexcept
    : UserStatInfo() {
    *this = ::std::move(from);
  }

  inline UserStatInfo& operator=(const UserStatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserStatInfo& operator=(UserStatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UserStatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserStatInfo* internal_default_instance() {
    return reinterpret_cast<const UserStatInfo*>(
               &_UserStatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserStatInfo& a, UserStatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserStatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserStatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserStatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserStatInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UserStatInfo& from);
  void MergeFrom(const UserStatInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserStatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.UserStatInfo";
  }
  protected:
  explicit UserStatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // required uint32 uid = 1;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  uint32_t uid() const;
  void set_uid(uint32_t value);
  private:
  uint32_t _internal_uid() const;
  void _internal_set_uid(uint32_t value);
  public:

  // required .PTP.Common.UserStat status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PTP::Common::UserStat status() const;
  void set_status(::PTP::Common::UserStat value);
  private:
  ::PTP::Common::UserStat _internal_status() const;
  void _internal_set_status(::PTP::Common::UserStat value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.UserStatInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t uid_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class MsgInfoList final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.MsgInfoList) */ {
 public:
  inline MsgInfoList() : MsgInfoList(nullptr) {}
  ~MsgInfoList() override;
  explicit PROTOBUF_CONSTEXPR MsgInfoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInfoList(const MsgInfoList& from);
  MsgInfoList(MsgInfoList&& from) noexcept
    : MsgInfoList() {
    *this = ::std::move(from);
  }

  inline MsgInfoList& operator=(const MsgInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInfoList& operator=(MsgInfoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgInfoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInfoList* internal_default_instance() {
    return reinterpret_cast<const MsgInfoList*>(
               &_MsgInfoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgInfoList& a, MsgInfoList& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInfoList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInfoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInfoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInfoList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgInfoList& from);
  void MergeFrom(const MsgInfoList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgInfoList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.MsgInfoList";
  }
  protected:
  explicit MsgInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 8,
    kMsgIdFieldNumber = 1,
    kFromUidFieldNumber = 4,
    kGroupIdFieldNumber = 5,
    kSentAtFieldNumber = 6,
    kMsgTypeFieldNumber = 7,
  };
  // required string msg_data = 8;
  bool has_msg_data() const;
  private:
  bool _internal_has_msg_data() const;
  public:
  void clear_msg_data();
  const std::string& msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_data();
  PROTOBUF_NODISCARD std::string* release_msg_data();
  void set_allocated_msg_data(std::string* msg_data);
  private:
  const std::string& _internal_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_data(const std::string& value);
  std::string* _internal_mutable_msg_data();
  public:

  // required uint32 msg_id = 1;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // required uint32 from_uid = 4;
  bool has_from_uid() const;
  private:
  bool _internal_has_from_uid() const;
  public:
  void clear_from_uid();
  uint32_t from_uid() const;
  void set_from_uid(uint32_t value);
  private:
  uint32_t _internal_from_uid() const;
  void _internal_set_from_uid(uint32_t value);
  public:

  // optional uint32 group_id = 5;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required uint32 sent_at = 6;
  bool has_sent_at() const;
  private:
  bool _internal_has_sent_at() const;
  public:
  void clear_sent_at();
  uint32_t sent_at() const;
  void set_sent_at(uint32_t value);
  private:
  uint32_t _internal_sent_at() const;
  void _internal_set_sent_at(uint32_t value);
  public:

  // required .PTP.Common.MsgType msg_type = 7;
  bool has_msg_type() const;
  private:
  bool _internal_has_msg_type() const;
  public:
  void clear_msg_type();
  ::PTP::Common::MsgType msg_type() const;
  void set_msg_type(::PTP::Common::MsgType value);
  private:
  ::PTP::Common::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::PTP::Common::MsgType value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.MsgInfoList)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_data_;
    uint32_t msg_id_;
    uint32_t from_uid_;
    uint32_t group_id_;
    uint32_t sent_at_;
    int msg_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class GroupMember final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.GroupMember) */ {
 public:
  inline GroupMember() : GroupMember(nullptr) {}
  ~GroupMember() override;
  explicit PROTOBUF_CONSTEXPR GroupMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupMember(const GroupMember& from);
  GroupMember(GroupMember&& from) noexcept
    : GroupMember() {
    *this = ::std::move(from);
  }

  inline GroupMember& operator=(const GroupMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupMember& operator=(GroupMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GroupMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupMember* internal_default_instance() {
    return reinterpret_cast<const GroupMember*>(
               &_GroupMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GroupMember& a, GroupMember& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupMember>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GroupMember& from);
  void MergeFrom(const GroupMember& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.GroupMember";
  }
  protected:
  explicit GroupMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kMemberStatusFieldNumber = 2,
  };
  // required uint32 uid = 1;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  uint32_t uid() const;
  void set_uid(uint32_t value);
  private:
  uint32_t _internal_uid() const;
  void _internal_set_uid(uint32_t value);
  public:

  // required .PTP.Common.GroupMemberStatus member_status = 2;
  bool has_member_status() const;
  private:
  bool _internal_has_member_status() const;
  public:
  void clear_member_status();
  ::PTP::Common::GroupMemberStatus member_status() const;
  void set_member_status(::PTP::Common::GroupMemberStatus value);
  private:
  ::PTP::Common::GroupMemberStatus _internal_member_status() const;
  void _internal_set_member_status(::PTP::Common::GroupMemberStatus value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.GroupMember)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t uid_;
    int member_status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class GroupRecord final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.GroupRecord) */ {
 public:
  inline GroupRecord() : GroupRecord(nullptr) {}
  ~GroupRecord() override;
  explicit PROTOBUF_CONSTEXPR GroupRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupRecord(const GroupRecord& from);
  GroupRecord(GroupRecord&& from) noexcept
    : GroupRecord() {
    *this = ::std::move(from);
  }

  inline GroupRecord& operator=(const GroupRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupRecord& operator=(GroupRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GroupRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupRecord* internal_default_instance() {
    return reinterpret_cast<const GroupRecord*>(
               &_GroupRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GroupRecord& a, GroupRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupRecord>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GroupRecord& from);
  void MergeFrom(const GroupRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.GroupRecord";
  }
  protected:
  explicit GroupRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAvatarFieldNumber = 2,
    kGroupAdrFieldNumber = 3,
    kPairUidFieldNumber = 5,
    kOwnerUidFieldNumber = 6,
    kGroupIdFieldNumber = 7,
    kUnReadCntFieldNumber = 8,
    kLastMsgIdFieldNumber = 9,
    kMsgUpTimeFieldNumber = 11,
    kMemberUpTimeFieldNumber = 12,
    kGroupTypeFieldNumber = 4,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string avatar = 2;
  bool has_avatar() const;
  private:
  bool _internal_has_avatar() const;
  public:
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // required string group_adr = 3;
  bool has_group_adr() const;
  private:
  bool _internal_has_group_adr() const;
  public:
  void clear_group_adr();
  const std::string& group_adr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_adr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_adr();
  PROTOBUF_NODISCARD std::string* release_group_adr();
  void set_allocated_group_adr(std::string* group_adr);
  private:
  const std::string& _internal_group_adr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_adr(const std::string& value);
  std::string* _internal_mutable_group_adr();
  public:

  // optional uint32 pair_uid = 5;
  bool has_pair_uid() const;
  private:
  bool _internal_has_pair_uid() const;
  public:
  void clear_pair_uid();
  uint32_t pair_uid() const;
  void set_pair_uid(uint32_t value);
  private:
  uint32_t _internal_pair_uid() const;
  void _internal_set_pair_uid(uint32_t value);
  public:

  // optional uint32 owner_uid = 6;
  bool has_owner_uid() const;
  private:
  bool _internal_has_owner_uid() const;
  public:
  void clear_owner_uid();
  uint32_t owner_uid() const;
  void set_owner_uid(uint32_t value);
  private:
  uint32_t _internal_owner_uid() const;
  void _internal_set_owner_uid(uint32_t value);
  public:

  // required uint32 group_id = 7;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required uint32 unReadCnt = 8;
  bool has_unreadcnt() const;
  private:
  bool _internal_has_unreadcnt() const;
  public:
  void clear_unreadcnt();
  uint32_t unreadcnt() const;
  void set_unreadcnt(uint32_t value);
  private:
  uint32_t _internal_unreadcnt() const;
  void _internal_set_unreadcnt(uint32_t value);
  public:

  // optional uint32 lastMsgId = 9;
  bool has_lastmsgid() const;
  private:
  bool _internal_has_lastmsgid() const;
  public:
  void clear_lastmsgid();
  uint32_t lastmsgid() const;
  void set_lastmsgid(uint32_t value);
  private:
  uint32_t _internal_lastmsgid() const;
  void _internal_set_lastmsgid(uint32_t value);
  public:

  // required uint32 msgUpTime = 11;
  bool has_msguptime() const;
  private:
  bool _internal_has_msguptime() const;
  public:
  void clear_msguptime();
  uint32_t msguptime() const;
  void set_msguptime(uint32_t value);
  private:
  uint32_t _internal_msguptime() const;
  void _internal_set_msguptime(uint32_t value);
  public:

  // required uint32 memberUpTime = 12;
  bool has_memberuptime() const;
  private:
  bool _internal_has_memberuptime() const;
  public:
  void clear_memberuptime();
  uint32_t memberuptime() const;
  void set_memberuptime(uint32_t value);
  private:
  uint32_t _internal_memberuptime() const;
  void _internal_set_memberuptime(uint32_t value);
  public:

  // required .PTP.Common.GroupType group_type = 4;
  bool has_group_type() const;
  private:
  bool _internal_has_group_type() const;
  public:
  void clear_group_type();
  ::PTP::Common::GroupType group_type() const;
  void set_group_type(::PTP::Common::GroupType value);
  private:
  ::PTP::Common::GroupType _internal_group_type() const;
  void _internal_set_group_type(::PTP::Common::GroupType value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.GroupRecord)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_adr_;
    uint32_t pair_uid_;
    uint32_t owner_uid_;
    uint32_t group_id_;
    uint32_t unreadcnt_;
    uint32_t lastmsgid_;
    uint32_t msguptime_;
    uint32_t memberuptime_;
    int group_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class GroupInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.GroupInfo) */ {
 public:
  inline GroupInfo() : GroupInfo(nullptr) {}
  ~GroupInfo() override;
  explicit PROTOBUF_CONSTEXPR GroupInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupInfo(const GroupInfo& from);
  GroupInfo(GroupInfo&& from) noexcept
    : GroupInfo() {
    *this = ::std::move(from);
  }

  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupInfo& operator=(GroupInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GroupInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupInfo* internal_default_instance() {
    return reinterpret_cast<const GroupInfo*>(
               &_GroupInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GroupInfo& a, GroupInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GroupInfo& from);
  void MergeFrom(const GroupInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GroupInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.GroupInfo";
  }
  protected:
  explicit GroupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupAdrFieldNumber = 1,
    kNameFieldNumber = 2,
    kAvatarFieldNumber = 3,
    kOwnerUidFieldNumber = 4,
    kPairUidFieldNumber = 5,
    kGroupIdxFieldNumber = 7,
    kCreatedTimeFieldNumber = 8,
    kGroupIdFieldNumber = 9,
    kGroupTypeFieldNumber = 6,
  };
  // required string group_adr = 1;
  bool has_group_adr() const;
  private:
  bool _internal_has_group_adr() const;
  public:
  void clear_group_adr();
  const std::string& group_adr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_adr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_adr();
  PROTOBUF_NODISCARD std::string* release_group_adr();
  void set_allocated_group_adr(std::string* group_adr);
  private:
  const std::string& _internal_group_adr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_adr(const std::string& value);
  std::string* _internal_mutable_group_adr();
  public:

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string avatar = 3;
  bool has_avatar() const;
  private:
  bool _internal_has_avatar() const;
  public:
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // required uint32 owner_uid = 4;
  bool has_owner_uid() const;
  private:
  bool _internal_has_owner_uid() const;
  public:
  void clear_owner_uid();
  uint32_t owner_uid() const;
  void set_owner_uid(uint32_t value);
  private:
  uint32_t _internal_owner_uid() const;
  void _internal_set_owner_uid(uint32_t value);
  public:

  // optional uint32 pair_uid = 5;
  bool has_pair_uid() const;
  private:
  bool _internal_has_pair_uid() const;
  public:
  void clear_pair_uid();
  uint32_t pair_uid() const;
  void set_pair_uid(uint32_t value);
  private:
  uint32_t _internal_pair_uid() const;
  void _internal_set_pair_uid(uint32_t value);
  public:

  // required uint32 group_idx = 7;
  bool has_group_idx() const;
  private:
  bool _internal_has_group_idx() const;
  public:
  void clear_group_idx();
  uint32_t group_idx() const;
  void set_group_idx(uint32_t value);
  private:
  uint32_t _internal_group_idx() const;
  void _internal_set_group_idx(uint32_t value);
  public:

  // required uint32 created_time = 8;
  bool has_created_time() const;
  private:
  bool _internal_has_created_time() const;
  public:
  void clear_created_time();
  uint32_t created_time() const;
  void set_created_time(uint32_t value);
  private:
  uint32_t _internal_created_time() const;
  void _internal_set_created_time(uint32_t value);
  public:

  // required uint32 group_id = 9;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required .PTP.Common.GroupType group_type = 6;
  bool has_group_type() const;
  private:
  bool _internal_has_group_type() const;
  public:
  void clear_group_type();
  ::PTP::Common::GroupType group_type() const;
  void set_group_type(::PTP::Common::GroupType value);
  private:
  ::PTP::Common::GroupType _internal_group_type() const;
  void _internal_set_group_type(::PTP::Common::GroupType value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.GroupInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_adr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
    uint32_t owner_uid_;
    uint32_t pair_uid_;
    uint32_t group_idx_;
    uint32_t created_time_;
    uint32_t group_id_;
    int group_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class MsgInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.MsgInfo) */ {
 public:
  inline MsgInfo() : MsgInfo(nullptr) {}
  ~MsgInfo() override;
  explicit PROTOBUF_CONSTEXPR MsgInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgInfo(const MsgInfo& from);
  MsgInfo(MsgInfo&& from) noexcept
    : MsgInfo() {
    *this = ::std::move(from);
  }

  inline MsgInfo& operator=(const MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgInfo& operator=(MsgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgInfo* internal_default_instance() {
    return reinterpret_cast<const MsgInfo*>(
               &_MsgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MsgInfo& a, MsgInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgInfo& from);
  void MergeFrom(const MsgInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.MsgInfo";
  }
  protected:
  explicit MsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgDataFieldNumber = 7,
    kGroupIdFieldNumber = 1,
    kFromUidFieldNumber = 2,
    kSentAtFieldNumber = 3,
    kMsgIdFieldNumber = 4,
    kMsgTypeFieldNumber = 6,
  };
  // required string msg_data = 7;
  bool has_msg_data() const;
  private:
  bool _internal_has_msg_data() const;
  public:
  void clear_msg_data();
  const std::string& msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_data();
  PROTOBUF_NODISCARD std::string* release_msg_data();
  void set_allocated_msg_data(std::string* msg_data);
  private:
  const std::string& _internal_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_data(const std::string& value);
  std::string* _internal_mutable_msg_data();
  public:

  // required uint32 group_id = 1;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required uint32 from_uid = 2;
  bool has_from_uid() const;
  private:
  bool _internal_has_from_uid() const;
  public:
  void clear_from_uid();
  uint32_t from_uid() const;
  void set_from_uid(uint32_t value);
  private:
  uint32_t _internal_from_uid() const;
  void _internal_set_from_uid(uint32_t value);
  public:

  // required uint32 sent_at = 3;
  bool has_sent_at() const;
  private:
  bool _internal_has_sent_at() const;
  public:
  void clear_sent_at();
  uint32_t sent_at() const;
  void set_sent_at(uint32_t value);
  private:
  uint32_t _internal_sent_at() const;
  void _internal_set_sent_at(uint32_t value);
  public:

  // required uint32 msg_id = 4;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // required .PTP.Common.MsgType msg_type = 6;
  bool has_msg_type() const;
  private:
  bool _internal_has_msg_type() const;
  public:
  void clear_msg_type();
  ::PTP::Common::MsgType msg_type() const;
  void set_msg_type(::PTP::Common::MsgType value);
  private:
  ::PTP::Common::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::PTP::Common::MsgType value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.MsgInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_data_;
    uint32_t group_id_;
    uint32_t from_uid_;
    uint32_t sent_at_;
    uint32_t msg_id_;
    int msg_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class DevicesInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.DevicesInfo) */ {
 public:
  inline DevicesInfo() : DevicesInfo(nullptr) {}
  ~DevicesInfo() override;
  explicit PROTOBUF_CONSTEXPR DevicesInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DevicesInfo(const DevicesInfo& from);
  DevicesInfo(DevicesInfo&& from) noexcept
    : DevicesInfo() {
    *this = ::std::move(from);
  }

  inline DevicesInfo& operator=(const DevicesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DevicesInfo& operator=(DevicesInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DevicesInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DevicesInfo* internal_default_instance() {
    return reinterpret_cast<const DevicesInfo*>(
               &_DevicesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DevicesInfo& a, DevicesInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DevicesInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DevicesInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DevicesInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DevicesInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DevicesInfo& from);
  void MergeFrom(const DevicesInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DevicesInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.DevicesInfo";
  }
  protected:
  explicit DevicesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientVersionFieldNumber = 2,
    kBrowserNameFieldNumber = 4,
    kBrowserVersionFieldNumber = 5,
    kOsNameFieldNumber = 6,
    kOsVersionFieldNumber = 7,
    kClientIdFieldNumber = 10,
    kLoginTimeFieldNumber = 3,
    kIsIntelFieldNumber = 8,
    kUidFieldNumber = 9,
    kClientTypeFieldNumber = 1,
  };
  // required string client_version = 2;
  bool has_client_version() const;
  private:
  bool _internal_has_client_version() const;
  public:
  void clear_client_version();
  const std::string& client_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* client_version);
  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(const std::string& value);
  std::string* _internal_mutable_client_version();
  public:

  // required string browser_name = 4;
  bool has_browser_name() const;
  private:
  bool _internal_has_browser_name() const;
  public:
  void clear_browser_name();
  const std::string& browser_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser_name();
  PROTOBUF_NODISCARD std::string* release_browser_name();
  void set_allocated_browser_name(std::string* browser_name);
  private:
  const std::string& _internal_browser_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_name(const std::string& value);
  std::string* _internal_mutable_browser_name();
  public:

  // required string browser_version = 5;
  bool has_browser_version() const;
  private:
  bool _internal_has_browser_version() const;
  public:
  void clear_browser_version();
  const std::string& browser_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_browser_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_browser_version();
  PROTOBUF_NODISCARD std::string* release_browser_version();
  void set_allocated_browser_version(std::string* browser_version);
  private:
  const std::string& _internal_browser_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_version(const std::string& value);
  std::string* _internal_mutable_browser_version();
  public:

  // required string os_name = 6;
  bool has_os_name() const;
  private:
  bool _internal_has_os_name() const;
  public:
  void clear_os_name();
  const std::string& os_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_name();
  PROTOBUF_NODISCARD std::string* release_os_name();
  void set_allocated_os_name(std::string* os_name);
  private:
  const std::string& _internal_os_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_name(const std::string& value);
  std::string* _internal_mutable_os_name();
  public:

  // required string os_version = 7;
  bool has_os_version() const;
  private:
  bool _internal_has_os_version() const;
  public:
  void clear_os_version();
  const std::string& os_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_version();
  PROTOBUF_NODISCARD std::string* release_os_version();
  void set_allocated_os_version(std::string* os_version);
  private:
  const std::string& _internal_os_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_version(const std::string& value);
  std::string* _internal_mutable_os_version();
  public:

  // required string client_id = 10;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // required uint32 login_time = 3;
  bool has_login_time() const;
  private:
  bool _internal_has_login_time() const;
  public:
  void clear_login_time();
  uint32_t login_time() const;
  void set_login_time(uint32_t value);
  private:
  uint32_t _internal_login_time() const;
  void _internal_set_login_time(uint32_t value);
  public:

  // required bool is_intel = 8;
  bool has_is_intel() const;
  private:
  bool _internal_has_is_intel() const;
  public:
  void clear_is_intel();
  bool is_intel() const;
  void set_is_intel(bool value);
  private:
  bool _internal_is_intel() const;
  void _internal_set_is_intel(bool value);
  public:

  // required uint32 uid = 9;
  bool has_uid() const;
  private:
  bool _internal_has_uid() const;
  public:
  void clear_uid();
  uint32_t uid() const;
  void set_uid(uint32_t value);
  private:
  uint32_t _internal_uid() const;
  void _internal_set_uid(uint32_t value);
  public:

  // required .PTP.Common.ClientType client_type = 1;
  bool has_client_type() const;
  private:
  bool _internal_has_client_type() const;
  public:
  void clear_client_type();
  ::PTP::Common::ClientType client_type() const;
  void set_client_type(::PTP::Common::ClientType value);
  private:
  ::PTP::Common::ClientType _internal_client_type() const;
  void _internal_set_client_type(::PTP::Common::ClientType value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.DevicesInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    uint32_t login_time_;
    bool is_intel_;
    uint32_t uid_;
    int client_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class InputPhoneContact final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.InputPhoneContact) */ {
 public:
  inline InputPhoneContact() : InputPhoneContact(nullptr) {}
  ~InputPhoneContact() override;
  explicit PROTOBUF_CONSTEXPR InputPhoneContact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputPhoneContact(const InputPhoneContact& from);
  InputPhoneContact(InputPhoneContact&& from) noexcept
    : InputPhoneContact() {
    *this = ::std::move(from);
  }

  inline InputPhoneContact& operator=(const InputPhoneContact& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputPhoneContact& operator=(InputPhoneContact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InputPhoneContact& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputPhoneContact* internal_default_instance() {
    return reinterpret_cast<const InputPhoneContact*>(
               &_InputPhoneContact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InputPhoneContact& a, InputPhoneContact& b) {
    a.Swap(&b);
  }
  inline void Swap(InputPhoneContact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputPhoneContact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputPhoneContact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputPhoneContact>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InputPhoneContact& from);
  void MergeFrom(const InputPhoneContact& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InputPhoneContact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.InputPhoneContact";
  }
  protected:
  explicit InputPhoneContact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneFieldNumber = 2,
    kFirstNameFieldNumber = 3,
    kLastNameFieldNumber = 4,
    kClientIdFieldNumber = 1,
  };
  // optional string phone = 2;
  bool has_phone() const;
  private:
  bool _internal_has_phone() const;
  public:
  void clear_phone();
  const std::string& phone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* phone);
  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(const std::string& value);
  std::string* _internal_mutable_phone();
  public:

  // optional string first_name = 3;
  bool has_first_name() const;
  private:
  bool _internal_has_first_name() const;
  public:
  void clear_first_name();
  const std::string& first_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_name();
  PROTOBUF_NODISCARD std::string* release_first_name();
  void set_allocated_first_name(std::string* first_name);
  private:
  const std::string& _internal_first_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name(const std::string& value);
  std::string* _internal_mutable_first_name();
  public:

  // optional string last_name = 4;
  bool has_last_name() const;
  private:
  bool _internal_has_last_name() const;
  public:
  void clear_last_name();
  const std::string& last_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_name();
  PROTOBUF_NODISCARD std::string* release_last_name();
  void set_allocated_last_name(std::string* last_name);
  private:
  const std::string& _internal_last_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name(const std::string& value);
  std::string* _internal_mutable_last_name();
  public:

  // required uint64 client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.InputPhoneContact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_name_;
    uint64_t client_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// -------------------------------------------------------------------

class BuddyQueryParam final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Common.BuddyQueryParam) */ {
 public:
  inline BuddyQueryParam() : BuddyQueryParam(nullptr) {}
  ~BuddyQueryParam() override;
  explicit PROTOBUF_CONSTEXPR BuddyQueryParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuddyQueryParam(const BuddyQueryParam& from);
  BuddyQueryParam(BuddyQueryParam&& from) noexcept
    : BuddyQueryParam() {
    *this = ::std::move(from);
  }

  inline BuddyQueryParam& operator=(const BuddyQueryParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuddyQueryParam& operator=(BuddyQueryParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BuddyQueryParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuddyQueryParam* internal_default_instance() {
    return reinterpret_cast<const BuddyQueryParam*>(
               &_BuddyQueryParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BuddyQueryParam& a, BuddyQueryParam& b) {
    a.Swap(&b);
  }
  inline void Swap(BuddyQueryParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuddyQueryParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuddyQueryParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuddyQueryParam>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BuddyQueryParam& from);
  void MergeFrom(const BuddyQueryParam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BuddyQueryParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Common.BuddyQueryParam";
  }
  protected:
  explicit BuddyQueryParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressListFieldNumber = 1,
    kUsernameListFieldNumber = 2,
  };
  // repeated string addressList = 1;
  int addresslist_size() const;
  private:
  int _internal_addresslist_size() const;
  public:
  void clear_addresslist();
  const std::string& addresslist(int index) const;
  std::string* mutable_addresslist(int index);
  void set_addresslist(int index, const std::string& value);
  void set_addresslist(int index, std::string&& value);
  void set_addresslist(int index, const char* value);
  void set_addresslist(int index, const char* value, size_t size);
  std::string* add_addresslist();
  void add_addresslist(const std::string& value);
  void add_addresslist(std::string&& value);
  void add_addresslist(const char* value);
  void add_addresslist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addresslist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addresslist();
  private:
  const std::string& _internal_addresslist(int index) const;
  std::string* _internal_add_addresslist();
  public:

  // repeated string usernameList = 2;
  int usernamelist_size() const;
  private:
  int _internal_usernamelist_size() const;
  public:
  void clear_usernamelist();
  const std::string& usernamelist(int index) const;
  std::string* mutable_usernamelist(int index);
  void set_usernamelist(int index, const std::string& value);
  void set_usernamelist(int index, std::string&& value);
  void set_usernamelist(int index, const char* value);
  void set_usernamelist(int index, const char* value, size_t size);
  std::string* add_usernamelist();
  void add_usernamelist(const std::string& value);
  void add_usernamelist(std::string&& value);
  void add_usernamelist(const char* value);
  void add_usernamelist(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& usernamelist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_usernamelist();
  private:
  const std::string& _internal_usernamelist(int index) const;
  std::string* _internal_add_usernamelist();
  public:

  // @@protoc_insertion_point(class_scope:PTP.Common.BuddyQueryParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addresslist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> usernamelist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eCommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IpAddress

// required string ip = 1;
inline bool IpAddress::_internal_has_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IpAddress::has_ip() const {
  return _internal_has_ip();
}
inline void IpAddress::clear_ip() {
  _impl_.ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IpAddress::ip() const {
  // @@protoc_insertion_point(field_get:PTP.Common.IpAddress.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IpAddress::set_ip(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.IpAddress.ip)
}
inline std::string* IpAddress::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:PTP.Common.IpAddress.ip)
  return _s;
}
inline const std::string& IpAddress::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void IpAddress::_internal_set_ip(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* IpAddress::_internal_mutable_ip() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* IpAddress::release_ip() {
  // @@protoc_insertion_point(field_release:PTP.Common.IpAddress.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IpAddress::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.IpAddress.ip)
}

// required uint32 port = 2;
inline bool IpAddress::_internal_has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IpAddress::has_port() const {
  return _internal_has_port();
}
inline void IpAddress::clear_port() {
  _impl_.port_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t IpAddress::_internal_port() const {
  return _impl_.port_;
}
inline uint32_t IpAddress::port() const {
  // @@protoc_insertion_point(field_get:PTP.Common.IpAddress.port)
  return _internal_port();
}
inline void IpAddress::_internal_set_port(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.port_ = value;
}
inline void IpAddress::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:PTP.Common.IpAddress.port)
}

// -------------------------------------------------------------------

// UserInfo

// required string address = 1;
inline bool UserInfo::_internal_has_address() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserInfo::has_address() const {
  return _internal_has_address();
}
inline void UserInfo::clear_address() {
  _impl_.address_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserInfo::address() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_address(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.address)
}
inline std::string* UserInfo::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.address)
  return _s;
}
inline const std::string& UserInfo::_internal_address() const {
  return _impl_.address_.Get();
}
inline void UserInfo::_internal_set_address(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_address() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_address() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.address)
}

// required bytes pub_key = 2;
inline bool UserInfo::_internal_has_pub_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserInfo::has_pub_key() const {
  return _internal_has_pub_key();
}
inline void UserInfo::clear_pub_key() {
  _impl_.pub_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserInfo::pub_key() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.pub_key)
  return _internal_pub_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_pub_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.pub_key_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.pub_key)
}
inline std::string* UserInfo::mutable_pub_key() {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.pub_key)
  return _s;
}
inline const std::string& UserInfo::_internal_pub_key() const {
  return _impl_.pub_key_.Get();
}
inline void UserInfo::_internal_set_pub_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pub_key_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_pub_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pub_key_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_pub_key() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.pub_key)
  if (!_internal_has_pub_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.pub_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pub_key_.IsDefault()) {
    _impl_.pub_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_pub_key(std::string* pub_key) {
  if (pub_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pub_key_.SetAllocated(pub_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pub_key_.IsDefault()) {
    _impl_.pub_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.pub_key)
}

// required string avatar = 3;
inline bool UserInfo::_internal_has_avatar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserInfo::has_avatar() const {
  return _internal_has_avatar();
}
inline void UserInfo::clear_avatar() {
  _impl_.avatar_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserInfo::avatar() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_avatar(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.avatar_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.avatar)
}
inline std::string* UserInfo::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.avatar)
  return _s;
}
inline const std::string& UserInfo::_internal_avatar() const {
  return _impl_.avatar_.Get();
}
inline void UserInfo::_internal_set_avatar(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_avatar() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_avatar() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.avatar)
  if (!_internal_has_avatar()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.avatar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.avatar_.SetAllocated(avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.avatar)
}

// required uint32 status = 4;
inline bool UserInfo::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UserInfo::has_status() const {
  return _internal_has_status();
}
inline void UserInfo::clear_status() {
  _impl_.status_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t UserInfo::_internal_status() const {
  return _impl_.status_;
}
inline uint32_t UserInfo::status() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.status)
  return _internal_status();
}
inline void UserInfo::_internal_set_status(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.status_ = value;
}
inline void UserInfo::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.status)
}

// optional string user_name = 5;
inline bool UserInfo::_internal_has_user_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserInfo::has_user_name() const {
  return _internal_has_user_name();
}
inline void UserInfo::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserInfo::user_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_user_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.user_name)
}
inline std::string* UserInfo::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.user_name)
  return _s;
}
inline const std::string& UserInfo::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void UserInfo::_internal_set_user_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_user_name() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_user_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.user_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.user_name)
}

// optional string nick_name = 6;
inline bool UserInfo::_internal_has_nick_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserInfo::has_nick_name() const {
  return _internal_has_nick_name();
}
inline void UserInfo::clear_nick_name() {
  _impl_.nick_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& UserInfo::nick_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.nick_name)
  return _internal_nick_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_nick_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.nick_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.nick_name)
}
inline std::string* UserInfo::mutable_nick_name() {
  std::string* _s = _internal_mutable_nick_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.nick_name)
  return _s;
}
inline const std::string& UserInfo::_internal_nick_name() const {
  return _impl_.nick_name_.Get();
}
inline void UserInfo::_internal_set_nick_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nick_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_nick_name() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.nick_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_nick_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.nick_name)
  if (!_internal_has_nick_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.nick_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nick_name_.IsDefault()) {
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_nick_name(std::string* nick_name) {
  if (nick_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.nick_name_.SetAllocated(nick_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nick_name_.IsDefault()) {
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.nick_name)
}

// optional string sign_info = 7;
inline bool UserInfo::_internal_has_sign_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserInfo::has_sign_info() const {
  return _internal_has_sign_info();
}
inline void UserInfo::clear_sign_info() {
  _impl_.sign_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& UserInfo::sign_info() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.sign_info)
  return _internal_sign_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_sign_info(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.sign_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.sign_info)
}
inline std::string* UserInfo::mutable_sign_info() {
  std::string* _s = _internal_mutable_sign_info();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.sign_info)
  return _s;
}
inline const std::string& UserInfo::_internal_sign_info() const {
  return _impl_.sign_info_.Get();
}
inline void UserInfo::_internal_set_sign_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sign_info_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_sign_info() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.sign_info_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_sign_info() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.sign_info)
  if (!_internal_has_sign_info()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.sign_info_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sign_info_.IsDefault()) {
    _impl_.sign_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_sign_info(std::string* sign_info) {
  if (sign_info != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.sign_info_.SetAllocated(sign_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sign_info_.IsDefault()) {
    _impl_.sign_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.sign_info)
}

// required uint32 uid = 8;
inline bool UserInfo::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UserInfo::has_uid() const {
  return _internal_has_uid();
}
inline void UserInfo::clear_uid() {
  _impl_.uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t UserInfo::_internal_uid() const {
  return _impl_.uid_;
}
inline uint32_t UserInfo::uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.uid)
  return _internal_uid();
}
inline void UserInfo::_internal_set_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.uid_ = value;
}
inline void UserInfo::set_uid(uint32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.uid)
}

// optional string first_name = 9;
inline bool UserInfo::_internal_has_first_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserInfo::has_first_name() const {
  return _internal_has_first_name();
}
inline void UserInfo::clear_first_name() {
  _impl_.first_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& UserInfo::first_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.first_name)
  return _internal_first_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_first_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000040u;
 _impl_.first_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.first_name)
}
inline std::string* UserInfo::mutable_first_name() {
  std::string* _s = _internal_mutable_first_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.first_name)
  return _s;
}
inline const std::string& UserInfo::_internal_first_name() const {
  return _impl_.first_name_.Get();
}
inline void UserInfo::_internal_set_first_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.first_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_first_name() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.first_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_first_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.first_name)
  if (!_internal_has_first_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* p = _impl_.first_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.first_name_.IsDefault()) {
    _impl_.first_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_first_name(std::string* first_name) {
  if (first_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.first_name_.SetAllocated(first_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.first_name_.IsDefault()) {
    _impl_.first_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.first_name)
}

// optional string last_name = 10;
inline bool UserInfo::_internal_has_last_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserInfo::has_last_name() const {
  return _internal_has_last_name();
}
inline void UserInfo::clear_last_name() {
  _impl_.last_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& UserInfo::last_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.last_name)
  return _internal_last_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserInfo::set_last_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000080u;
 _impl_.last_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.last_name)
}
inline std::string* UserInfo::mutable_last_name() {
  std::string* _s = _internal_mutable_last_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.UserInfo.last_name)
  return _s;
}
inline const std::string& UserInfo::_internal_last_name() const {
  return _impl_.last_name_.Get();
}
inline void UserInfo::_internal_set_last_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.last_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserInfo::_internal_mutable_last_name() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.last_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserInfo::release_last_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.UserInfo.last_name)
  if (!_internal_has_last_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* p = _impl_.last_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_name_.IsDefault()) {
    _impl_.last_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UserInfo::set_allocated_last_name(std::string* last_name) {
  if (last_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.last_name_.SetAllocated(last_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_name_.IsDefault()) {
    _impl_.last_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.UserInfo.last_name)
}

// optional uint32 login_time = 11;
inline bool UserInfo::_internal_has_login_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool UserInfo::has_login_time() const {
  return _internal_has_login_time();
}
inline void UserInfo::clear_login_time() {
  _impl_.login_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline uint32_t UserInfo::_internal_login_time() const {
  return _impl_.login_time_;
}
inline uint32_t UserInfo::login_time() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.login_time)
  return _internal_login_time();
}
inline void UserInfo::_internal_set_login_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.login_time_ = value;
}
inline void UserInfo::set_login_time(uint32_t value) {
  _internal_set_login_time(value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.login_time)
}

// optional bool is_online = 12;
inline bool UserInfo::_internal_has_is_online() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool UserInfo::has_is_online() const {
  return _internal_has_is_online();
}
inline void UserInfo::clear_is_online() {
  _impl_.is_online_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool UserInfo::_internal_is_online() const {
  return _impl_.is_online_;
}
inline bool UserInfo::is_online() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserInfo.is_online)
  return _internal_is_online();
}
inline void UserInfo::_internal_set_is_online(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.is_online_ = value;
}
inline void UserInfo::set_is_online(bool value) {
  _internal_set_is_online(value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserInfo.is_online)
}

// -------------------------------------------------------------------

// UserStatInfo

// required uint32 uid = 1;
inline bool UserStatInfo::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserStatInfo::has_uid() const {
  return _internal_has_uid();
}
inline void UserStatInfo::clear_uid() {
  _impl_.uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t UserStatInfo::_internal_uid() const {
  return _impl_.uid_;
}
inline uint32_t UserStatInfo::uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserStatInfo.uid)
  return _internal_uid();
}
inline void UserStatInfo::_internal_set_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_ = value;
}
inline void UserStatInfo::set_uid(uint32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserStatInfo.uid)
}

// required .PTP.Common.UserStat status = 2;
inline bool UserStatInfo::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserStatInfo::has_status() const {
  return _internal_has_status();
}
inline void UserStatInfo::clear_status() {
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::PTP::Common::UserStat UserStatInfo::_internal_status() const {
  return static_cast< ::PTP::Common::UserStat >(_impl_.status_);
}
inline ::PTP::Common::UserStat UserStatInfo::status() const {
  // @@protoc_insertion_point(field_get:PTP.Common.UserStatInfo.status)
  return _internal_status();
}
inline void UserStatInfo::_internal_set_status(::PTP::Common::UserStat value) {
  assert(::PTP::Common::UserStat_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}
inline void UserStatInfo::set_status(::PTP::Common::UserStat value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:PTP.Common.UserStatInfo.status)
}

// -------------------------------------------------------------------

// MsgInfoList

// required uint32 msg_id = 1;
inline bool MsgInfoList::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgInfoList::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgInfoList::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgInfoList::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgInfoList::msg_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.msg_id)
  return _internal_msg_id();
}
inline void MsgInfoList::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.msg_id_ = value;
}
inline void MsgInfoList::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.msg_id)
}

// required uint32 from_uid = 4;
inline bool MsgInfoList::_internal_has_from_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgInfoList::has_from_uid() const {
  return _internal_has_from_uid();
}
inline void MsgInfoList::clear_from_uid() {
  _impl_.from_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgInfoList::_internal_from_uid() const {
  return _impl_.from_uid_;
}
inline uint32_t MsgInfoList::from_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.from_uid)
  return _internal_from_uid();
}
inline void MsgInfoList::_internal_set_from_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.from_uid_ = value;
}
inline void MsgInfoList::set_from_uid(uint32_t value) {
  _internal_set_from_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.from_uid)
}

// optional uint32 group_id = 5;
inline bool MsgInfoList::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgInfoList::has_group_id() const {
  return _internal_has_group_id();
}
inline void MsgInfoList::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MsgInfoList::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t MsgInfoList::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.group_id)
  return _internal_group_id();
}
inline void MsgInfoList::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.group_id_ = value;
}
inline void MsgInfoList::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.group_id)
}

// required uint32 sent_at = 6;
inline bool MsgInfoList::_internal_has_sent_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MsgInfoList::has_sent_at() const {
  return _internal_has_sent_at();
}
inline void MsgInfoList::clear_sent_at() {
  _impl_.sent_at_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MsgInfoList::_internal_sent_at() const {
  return _impl_.sent_at_;
}
inline uint32_t MsgInfoList::sent_at() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.sent_at)
  return _internal_sent_at();
}
inline void MsgInfoList::_internal_set_sent_at(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.sent_at_ = value;
}
inline void MsgInfoList::set_sent_at(uint32_t value) {
  _internal_set_sent_at(value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.sent_at)
}

// required .PTP.Common.MsgType msg_type = 7;
inline bool MsgInfoList::_internal_has_msg_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MsgInfoList::has_msg_type() const {
  return _internal_has_msg_type();
}
inline void MsgInfoList::clear_msg_type() {
  _impl_.msg_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::PTP::Common::MsgType MsgInfoList::_internal_msg_type() const {
  return static_cast< ::PTP::Common::MsgType >(_impl_.msg_type_);
}
inline ::PTP::Common::MsgType MsgInfoList::msg_type() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.msg_type)
  return _internal_msg_type();
}
inline void MsgInfoList::_internal_set_msg_type(::PTP::Common::MsgType value) {
  assert(::PTP::Common::MsgType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.msg_type_ = value;
}
inline void MsgInfoList::set_msg_type(::PTP::Common::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.msg_type)
}

// required string msg_data = 8;
inline bool MsgInfoList::_internal_has_msg_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgInfoList::has_msg_data() const {
  return _internal_has_msg_data();
}
inline void MsgInfoList::clear_msg_data() {
  _impl_.msg_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgInfoList::msg_data() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfoList.msg_data)
  return _internal_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfoList::set_msg_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfoList.msg_data)
}
inline std::string* MsgInfoList::mutable_msg_data() {
  std::string* _s = _internal_mutable_msg_data();
  // @@protoc_insertion_point(field_mutable:PTP.Common.MsgInfoList.msg_data)
  return _s;
}
inline const std::string& MsgInfoList::_internal_msg_data() const {
  return _impl_.msg_data_.Get();
}
inline void MsgInfoList::_internal_set_msg_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfoList::_internal_mutable_msg_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfoList::release_msg_data() {
  // @@protoc_insertion_point(field_release:PTP.Common.MsgInfoList.msg_data)
  if (!_internal_has_msg_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_data_.IsDefault()) {
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgInfoList::set_allocated_msg_data(std::string* msg_data) {
  if (msg_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_data_.SetAllocated(msg_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_data_.IsDefault()) {
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.MsgInfoList.msg_data)
}

// -------------------------------------------------------------------

// GroupMember

// required uint32 uid = 1;
inline bool GroupMember::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupMember::has_uid() const {
  return _internal_has_uid();
}
inline void GroupMember::clear_uid() {
  _impl_.uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t GroupMember::_internal_uid() const {
  return _impl_.uid_;
}
inline uint32_t GroupMember::uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupMember.uid)
  return _internal_uid();
}
inline void GroupMember::_internal_set_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uid_ = value;
}
inline void GroupMember::set_uid(uint32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupMember.uid)
}

// required .PTP.Common.GroupMemberStatus member_status = 2;
inline bool GroupMember::_internal_has_member_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupMember::has_member_status() const {
  return _internal_has_member_status();
}
inline void GroupMember::clear_member_status() {
  _impl_.member_status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::PTP::Common::GroupMemberStatus GroupMember::_internal_member_status() const {
  return static_cast< ::PTP::Common::GroupMemberStatus >(_impl_.member_status_);
}
inline ::PTP::Common::GroupMemberStatus GroupMember::member_status() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupMember.member_status)
  return _internal_member_status();
}
inline void GroupMember::_internal_set_member_status(::PTP::Common::GroupMemberStatus value) {
  assert(::PTP::Common::GroupMemberStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.member_status_ = value;
}
inline void GroupMember::set_member_status(::PTP::Common::GroupMemberStatus value) {
  _internal_set_member_status(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupMember.member_status)
}

// -------------------------------------------------------------------

// GroupRecord

// required string name = 1;
inline bool GroupRecord::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupRecord::has_name() const {
  return _internal_has_name();
}
inline void GroupRecord::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupRecord::name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupRecord::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.name)
}
inline std::string* GroupRecord::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupRecord.name)
  return _s;
}
inline const std::string& GroupRecord::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GroupRecord::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupRecord::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupRecord::release_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupRecord.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupRecord::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupRecord.name)
}

// required string avatar = 2;
inline bool GroupRecord::_internal_has_avatar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupRecord::has_avatar() const {
  return _internal_has_avatar();
}
inline void GroupRecord::clear_avatar() {
  _impl_.avatar_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupRecord::avatar() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupRecord::set_avatar(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.avatar_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.avatar)
}
inline std::string* GroupRecord::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupRecord.avatar)
  return _s;
}
inline const std::string& GroupRecord::_internal_avatar() const {
  return _impl_.avatar_.Get();
}
inline void GroupRecord::_internal_set_avatar(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupRecord::_internal_mutable_avatar() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupRecord::release_avatar() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupRecord.avatar)
  if (!_internal_has_avatar()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.avatar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupRecord::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.avatar_.SetAllocated(avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupRecord.avatar)
}

// required string group_adr = 3;
inline bool GroupRecord::_internal_has_group_adr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GroupRecord::has_group_adr() const {
  return _internal_has_group_adr();
}
inline void GroupRecord::clear_group_adr() {
  _impl_.group_adr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GroupRecord::group_adr() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.group_adr)
  return _internal_group_adr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupRecord::set_group_adr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.group_adr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.group_adr)
}
inline std::string* GroupRecord::mutable_group_adr() {
  std::string* _s = _internal_mutable_group_adr();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupRecord.group_adr)
  return _s;
}
inline const std::string& GroupRecord::_internal_group_adr() const {
  return _impl_.group_adr_.Get();
}
inline void GroupRecord::_internal_set_group_adr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.group_adr_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupRecord::_internal_mutable_group_adr() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.group_adr_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupRecord::release_group_adr() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupRecord.group_adr)
  if (!_internal_has_group_adr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.group_adr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_adr_.IsDefault()) {
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupRecord::set_allocated_group_adr(std::string* group_adr) {
  if (group_adr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.group_adr_.SetAllocated(group_adr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_adr_.IsDefault()) {
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupRecord.group_adr)
}

// required .PTP.Common.GroupType group_type = 4;
inline bool GroupRecord::_internal_has_group_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool GroupRecord::has_group_type() const {
  return _internal_has_group_type();
}
inline void GroupRecord::clear_group_type() {
  _impl_.group_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::PTP::Common::GroupType GroupRecord::_internal_group_type() const {
  return static_cast< ::PTP::Common::GroupType >(_impl_.group_type_);
}
inline ::PTP::Common::GroupType GroupRecord::group_type() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.group_type)
  return _internal_group_type();
}
inline void GroupRecord::_internal_set_group_type(::PTP::Common::GroupType value) {
  assert(::PTP::Common::GroupType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.group_type_ = value;
}
inline void GroupRecord::set_group_type(::PTP::Common::GroupType value) {
  _internal_set_group_type(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.group_type)
}

// optional uint32 pair_uid = 5;
inline bool GroupRecord::_internal_has_pair_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GroupRecord::has_pair_uid() const {
  return _internal_has_pair_uid();
}
inline void GroupRecord::clear_pair_uid() {
  _impl_.pair_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t GroupRecord::_internal_pair_uid() const {
  return _impl_.pair_uid_;
}
inline uint32_t GroupRecord::pair_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.pair_uid)
  return _internal_pair_uid();
}
inline void GroupRecord::_internal_set_pair_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.pair_uid_ = value;
}
inline void GroupRecord::set_pair_uid(uint32_t value) {
  _internal_set_pair_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.pair_uid)
}

// optional uint32 owner_uid = 6;
inline bool GroupRecord::_internal_has_owner_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GroupRecord::has_owner_uid() const {
  return _internal_has_owner_uid();
}
inline void GroupRecord::clear_owner_uid() {
  _impl_.owner_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t GroupRecord::_internal_owner_uid() const {
  return _impl_.owner_uid_;
}
inline uint32_t GroupRecord::owner_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.owner_uid)
  return _internal_owner_uid();
}
inline void GroupRecord::_internal_set_owner_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.owner_uid_ = value;
}
inline void GroupRecord::set_owner_uid(uint32_t value) {
  _internal_set_owner_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.owner_uid)
}

// required uint32 group_id = 7;
inline bool GroupRecord::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GroupRecord::has_group_id() const {
  return _internal_has_group_id();
}
inline void GroupRecord::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t GroupRecord::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t GroupRecord::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.group_id)
  return _internal_group_id();
}
inline void GroupRecord::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.group_id_ = value;
}
inline void GroupRecord::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.group_id)
}

// required uint32 unReadCnt = 8;
inline bool GroupRecord::_internal_has_unreadcnt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GroupRecord::has_unreadcnt() const {
  return _internal_has_unreadcnt();
}
inline void GroupRecord::clear_unreadcnt() {
  _impl_.unreadcnt_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t GroupRecord::_internal_unreadcnt() const {
  return _impl_.unreadcnt_;
}
inline uint32_t GroupRecord::unreadcnt() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.unReadCnt)
  return _internal_unreadcnt();
}
inline void GroupRecord::_internal_set_unreadcnt(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.unreadcnt_ = value;
}
inline void GroupRecord::set_unreadcnt(uint32_t value) {
  _internal_set_unreadcnt(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.unReadCnt)
}

// optional uint32 lastMsgId = 9;
inline bool GroupRecord::_internal_has_lastmsgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GroupRecord::has_lastmsgid() const {
  return _internal_has_lastmsgid();
}
inline void GroupRecord::clear_lastmsgid() {
  _impl_.lastmsgid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t GroupRecord::_internal_lastmsgid() const {
  return _impl_.lastmsgid_;
}
inline uint32_t GroupRecord::lastmsgid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.lastMsgId)
  return _internal_lastmsgid();
}
inline void GroupRecord::_internal_set_lastmsgid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.lastmsgid_ = value;
}
inline void GroupRecord::set_lastmsgid(uint32_t value) {
  _internal_set_lastmsgid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.lastMsgId)
}

// required uint32 msgUpTime = 11;
inline bool GroupRecord::_internal_has_msguptime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool GroupRecord::has_msguptime() const {
  return _internal_has_msguptime();
}
inline void GroupRecord::clear_msguptime() {
  _impl_.msguptime_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t GroupRecord::_internal_msguptime() const {
  return _impl_.msguptime_;
}
inline uint32_t GroupRecord::msguptime() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.msgUpTime)
  return _internal_msguptime();
}
inline void GroupRecord::_internal_set_msguptime(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.msguptime_ = value;
}
inline void GroupRecord::set_msguptime(uint32_t value) {
  _internal_set_msguptime(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.msgUpTime)
}

// required uint32 memberUpTime = 12;
inline bool GroupRecord::_internal_has_memberuptime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool GroupRecord::has_memberuptime() const {
  return _internal_has_memberuptime();
}
inline void GroupRecord::clear_memberuptime() {
  _impl_.memberuptime_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t GroupRecord::_internal_memberuptime() const {
  return _impl_.memberuptime_;
}
inline uint32_t GroupRecord::memberuptime() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupRecord.memberUpTime)
  return _internal_memberuptime();
}
inline void GroupRecord::_internal_set_memberuptime(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.memberuptime_ = value;
}
inline void GroupRecord::set_memberuptime(uint32_t value) {
  _internal_set_memberuptime(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupRecord.memberUpTime)
}

// -------------------------------------------------------------------

// GroupInfo

// required string group_adr = 1;
inline bool GroupInfo::_internal_has_group_adr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GroupInfo::has_group_adr() const {
  return _internal_has_group_adr();
}
inline void GroupInfo::clear_group_adr() {
  _impl_.group_adr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GroupInfo::group_adr() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.group_adr)
  return _internal_group_adr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInfo::set_group_adr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.group_adr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.group_adr)
}
inline std::string* GroupInfo::mutable_group_adr() {
  std::string* _s = _internal_mutable_group_adr();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupInfo.group_adr)
  return _s;
}
inline const std::string& GroupInfo::_internal_group_adr() const {
  return _impl_.group_adr_.Get();
}
inline void GroupInfo::_internal_set_group_adr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_adr_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupInfo::_internal_mutable_group_adr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.group_adr_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupInfo::release_group_adr() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupInfo.group_adr)
  if (!_internal_has_group_adr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.group_adr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_adr_.IsDefault()) {
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupInfo::set_allocated_group_adr(std::string* group_adr) {
  if (group_adr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_adr_.SetAllocated(group_adr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_adr_.IsDefault()) {
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupInfo.group_adr)
}

// required uint32 group_id = 9;
inline bool GroupInfo::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GroupInfo::has_group_id() const {
  return _internal_has_group_id();
}
inline void GroupInfo::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t GroupInfo::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t GroupInfo::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.group_id)
  return _internal_group_id();
}
inline void GroupInfo::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.group_id_ = value;
}
inline void GroupInfo::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.group_id)
}

// required string name = 2;
inline bool GroupInfo::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GroupInfo::has_name() const {
  return _internal_has_name();
}
inline void GroupInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GroupInfo::name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.name)
}
inline std::string* GroupInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupInfo.name)
  return _s;
}
inline const std::string& GroupInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GroupInfo::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupInfo::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupInfo::release_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupInfo.name)
}

// required string avatar = 3;
inline bool GroupInfo::_internal_has_avatar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GroupInfo::has_avatar() const {
  return _internal_has_avatar();
}
inline void GroupInfo::clear_avatar() {
  _impl_.avatar_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GroupInfo::avatar() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupInfo::set_avatar(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.avatar_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.avatar)
}
inline std::string* GroupInfo::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:PTP.Common.GroupInfo.avatar)
  return _s;
}
inline const std::string& GroupInfo::_internal_avatar() const {
  return _impl_.avatar_.Get();
}
inline void GroupInfo::_internal_set_avatar(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.avatar_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupInfo::_internal_mutable_avatar() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.avatar_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupInfo::release_avatar() {
  // @@protoc_insertion_point(field_release:PTP.Common.GroupInfo.avatar)
  if (!_internal_has_avatar()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.avatar_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GroupInfo::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.avatar_.SetAllocated(avatar, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.avatar_.IsDefault()) {
    _impl_.avatar_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.GroupInfo.avatar)
}

// required uint32 owner_uid = 4;
inline bool GroupInfo::_internal_has_owner_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GroupInfo::has_owner_uid() const {
  return _internal_has_owner_uid();
}
inline void GroupInfo::clear_owner_uid() {
  _impl_.owner_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t GroupInfo::_internal_owner_uid() const {
  return _impl_.owner_uid_;
}
inline uint32_t GroupInfo::owner_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.owner_uid)
  return _internal_owner_uid();
}
inline void GroupInfo::_internal_set_owner_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.owner_uid_ = value;
}
inline void GroupInfo::set_owner_uid(uint32_t value) {
  _internal_set_owner_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.owner_uid)
}

// optional uint32 pair_uid = 5;
inline bool GroupInfo::_internal_has_pair_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GroupInfo::has_pair_uid() const {
  return _internal_has_pair_uid();
}
inline void GroupInfo::clear_pair_uid() {
  _impl_.pair_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t GroupInfo::_internal_pair_uid() const {
  return _impl_.pair_uid_;
}
inline uint32_t GroupInfo::pair_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.pair_uid)
  return _internal_pair_uid();
}
inline void GroupInfo::_internal_set_pair_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pair_uid_ = value;
}
inline void GroupInfo::set_pair_uid(uint32_t value) {
  _internal_set_pair_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.pair_uid)
}

// required .PTP.Common.GroupType group_type = 6;
inline bool GroupInfo::_internal_has_group_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool GroupInfo::has_group_type() const {
  return _internal_has_group_type();
}
inline void GroupInfo::clear_group_type() {
  _impl_.group_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::PTP::Common::GroupType GroupInfo::_internal_group_type() const {
  return static_cast< ::PTP::Common::GroupType >(_impl_.group_type_);
}
inline ::PTP::Common::GroupType GroupInfo::group_type() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.group_type)
  return _internal_group_type();
}
inline void GroupInfo::_internal_set_group_type(::PTP::Common::GroupType value) {
  assert(::PTP::Common::GroupType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.group_type_ = value;
}
inline void GroupInfo::set_group_type(::PTP::Common::GroupType value) {
  _internal_set_group_type(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.group_type)
}

// required uint32 group_idx = 7;
inline bool GroupInfo::_internal_has_group_idx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GroupInfo::has_group_idx() const {
  return _internal_has_group_idx();
}
inline void GroupInfo::clear_group_idx() {
  _impl_.group_idx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t GroupInfo::_internal_group_idx() const {
  return _impl_.group_idx_;
}
inline uint32_t GroupInfo::group_idx() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.group_idx)
  return _internal_group_idx();
}
inline void GroupInfo::_internal_set_group_idx(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.group_idx_ = value;
}
inline void GroupInfo::set_group_idx(uint32_t value) {
  _internal_set_group_idx(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.group_idx)
}

// required uint32 created_time = 8;
inline bool GroupInfo::_internal_has_created_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GroupInfo::has_created_time() const {
  return _internal_has_created_time();
}
inline void GroupInfo::clear_created_time() {
  _impl_.created_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t GroupInfo::_internal_created_time() const {
  return _impl_.created_time_;
}
inline uint32_t GroupInfo::created_time() const {
  // @@protoc_insertion_point(field_get:PTP.Common.GroupInfo.created_time)
  return _internal_created_time();
}
inline void GroupInfo::_internal_set_created_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.created_time_ = value;
}
inline void GroupInfo::set_created_time(uint32_t value) {
  _internal_set_created_time(value);
  // @@protoc_insertion_point(field_set:PTP.Common.GroupInfo.created_time)
}

// -------------------------------------------------------------------

// MsgInfo

// required uint32 group_id = 1;
inline bool MsgInfo::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgInfo::has_group_id() const {
  return _internal_has_group_id();
}
inline void MsgInfo::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgInfo::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t MsgInfo::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.group_id)
  return _internal_group_id();
}
inline void MsgInfo::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_id_ = value;
}
inline void MsgInfo::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.group_id)
}

// required uint32 from_uid = 2;
inline bool MsgInfo::_internal_has_from_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgInfo::has_from_uid() const {
  return _internal_has_from_uid();
}
inline void MsgInfo::clear_from_uid() {
  _impl_.from_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgInfo::_internal_from_uid() const {
  return _impl_.from_uid_;
}
inline uint32_t MsgInfo::from_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.from_uid)
  return _internal_from_uid();
}
inline void MsgInfo::_internal_set_from_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.from_uid_ = value;
}
inline void MsgInfo::set_from_uid(uint32_t value) {
  _internal_set_from_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.from_uid)
}

// required uint32 sent_at = 3;
inline bool MsgInfo::_internal_has_sent_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgInfo::has_sent_at() const {
  return _internal_has_sent_at();
}
inline void MsgInfo::clear_sent_at() {
  _impl_.sent_at_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MsgInfo::_internal_sent_at() const {
  return _impl_.sent_at_;
}
inline uint32_t MsgInfo::sent_at() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.sent_at)
  return _internal_sent_at();
}
inline void MsgInfo::_internal_set_sent_at(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sent_at_ = value;
}
inline void MsgInfo::set_sent_at(uint32_t value) {
  _internal_set_sent_at(value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.sent_at)
}

// required uint32 msg_id = 4;
inline bool MsgInfo::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MsgInfo::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgInfo::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MsgInfo::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.msg_id)
  return _internal_msg_id();
}
inline void MsgInfo::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.msg_id_ = value;
}
inline void MsgInfo::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.msg_id)
}

// required .PTP.Common.MsgType msg_type = 6;
inline bool MsgInfo::_internal_has_msg_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MsgInfo::has_msg_type() const {
  return _internal_has_msg_type();
}
inline void MsgInfo::clear_msg_type() {
  _impl_.msg_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::PTP::Common::MsgType MsgInfo::_internal_msg_type() const {
  return static_cast< ::PTP::Common::MsgType >(_impl_.msg_type_);
}
inline ::PTP::Common::MsgType MsgInfo::msg_type() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.msg_type)
  return _internal_msg_type();
}
inline void MsgInfo::_internal_set_msg_type(::PTP::Common::MsgType value) {
  assert(::PTP::Common::MsgType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.msg_type_ = value;
}
inline void MsgInfo::set_msg_type(::PTP::Common::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.msg_type)
}

// required string msg_data = 7;
inline bool MsgInfo::_internal_has_msg_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgInfo::has_msg_data() const {
  return _internal_has_msg_data();
}
inline void MsgInfo::clear_msg_data() {
  _impl_.msg_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgInfo::msg_data() const {
  // @@protoc_insertion_point(field_get:PTP.Common.MsgInfo.msg_data)
  return _internal_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgInfo::set_msg_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.MsgInfo.msg_data)
}
inline std::string* MsgInfo::mutable_msg_data() {
  std::string* _s = _internal_mutable_msg_data();
  // @@protoc_insertion_point(field_mutable:PTP.Common.MsgInfo.msg_data)
  return _s;
}
inline const std::string& MsgInfo::_internal_msg_data() const {
  return _impl_.msg_data_.Get();
}
inline void MsgInfo::_internal_set_msg_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgInfo::_internal_mutable_msg_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgInfo::release_msg_data() {
  // @@protoc_insertion_point(field_release:PTP.Common.MsgInfo.msg_data)
  if (!_internal_has_msg_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_data_.IsDefault()) {
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgInfo::set_allocated_msg_data(std::string* msg_data) {
  if (msg_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_data_.SetAllocated(msg_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_data_.IsDefault()) {
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.MsgInfo.msg_data)
}

// -------------------------------------------------------------------

// DevicesInfo

// required .PTP.Common.ClientType client_type = 1;
inline bool DevicesInfo::_internal_has_client_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DevicesInfo::has_client_type() const {
  return _internal_has_client_type();
}
inline void DevicesInfo::clear_client_type() {
  _impl_.client_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::PTP::Common::ClientType DevicesInfo::_internal_client_type() const {
  return static_cast< ::PTP::Common::ClientType >(_impl_.client_type_);
}
inline ::PTP::Common::ClientType DevicesInfo::client_type() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.client_type)
  return _internal_client_type();
}
inline void DevicesInfo::_internal_set_client_type(::PTP::Common::ClientType value) {
  assert(::PTP::Common::ClientType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.client_type_ = value;
}
inline void DevicesInfo::set_client_type(::PTP::Common::ClientType value) {
  _internal_set_client_type(value);
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.client_type)
}

// required string client_version = 2;
inline bool DevicesInfo::_internal_has_client_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DevicesInfo::has_client_version() const {
  return _internal_has_client_version();
}
inline void DevicesInfo::clear_client_version() {
  _impl_.client_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DevicesInfo::client_version() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.client_version)
  return _internal_client_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicesInfo::set_client_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.client_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.client_version)
}
inline std::string* DevicesInfo::mutable_client_version() {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.client_version)
  return _s;
}
inline const std::string& DevicesInfo::_internal_client_version() const {
  return _impl_.client_version_.Get();
}
inline void DevicesInfo::_internal_set_client_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.client_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DevicesInfo::_internal_mutable_client_version() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.client_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DevicesInfo::release_client_version() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.client_version)
  if (!_internal_has_client_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.client_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_version_.IsDefault()) {
    _impl_.client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DevicesInfo::set_allocated_client_version(std::string* client_version) {
  if (client_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.client_version_.SetAllocated(client_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_version_.IsDefault()) {
    _impl_.client_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.client_version)
}

// required uint32 login_time = 3;
inline bool DevicesInfo::_internal_has_login_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DevicesInfo::has_login_time() const {
  return _internal_has_login_time();
}
inline void DevicesInfo::clear_login_time() {
  _impl_.login_time_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t DevicesInfo::_internal_login_time() const {
  return _impl_.login_time_;
}
inline uint32_t DevicesInfo::login_time() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.login_time)
  return _internal_login_time();
}
inline void DevicesInfo::_internal_set_login_time(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.login_time_ = value;
}
inline void DevicesInfo::set_login_time(uint32_t value) {
  _internal_set_login_time(value);
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.login_time)
}

// required string browser_name = 4;
inline bool DevicesInfo::_internal_has_browser_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DevicesInfo::has_browser_name() const {
  return _internal_has_browser_name();
}
inline void DevicesInfo::clear_browser_name() {
  _impl_.browser_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DevicesInfo::browser_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.browser_name)
  return _internal_browser_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicesInfo::set_browser_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.browser_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.browser_name)
}
inline std::string* DevicesInfo::mutable_browser_name() {
  std::string* _s = _internal_mutable_browser_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.browser_name)
  return _s;
}
inline const std::string& DevicesInfo::_internal_browser_name() const {
  return _impl_.browser_name_.Get();
}
inline void DevicesInfo::_internal_set_browser_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.browser_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DevicesInfo::_internal_mutable_browser_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.browser_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DevicesInfo::release_browser_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.browser_name)
  if (!_internal_has_browser_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.browser_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browser_name_.IsDefault()) {
    _impl_.browser_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DevicesInfo::set_allocated_browser_name(std::string* browser_name) {
  if (browser_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.browser_name_.SetAllocated(browser_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browser_name_.IsDefault()) {
    _impl_.browser_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.browser_name)
}

// required string browser_version = 5;
inline bool DevicesInfo::_internal_has_browser_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DevicesInfo::has_browser_version() const {
  return _internal_has_browser_version();
}
inline void DevicesInfo::clear_browser_version() {
  _impl_.browser_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DevicesInfo::browser_version() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.browser_version)
  return _internal_browser_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicesInfo::set_browser_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.browser_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.browser_version)
}
inline std::string* DevicesInfo::mutable_browser_version() {
  std::string* _s = _internal_mutable_browser_version();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.browser_version)
  return _s;
}
inline const std::string& DevicesInfo::_internal_browser_version() const {
  return _impl_.browser_version_.Get();
}
inline void DevicesInfo::_internal_set_browser_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.browser_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DevicesInfo::_internal_mutable_browser_version() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.browser_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DevicesInfo::release_browser_version() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.browser_version)
  if (!_internal_has_browser_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.browser_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browser_version_.IsDefault()) {
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DevicesInfo::set_allocated_browser_version(std::string* browser_version) {
  if (browser_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.browser_version_.SetAllocated(browser_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.browser_version_.IsDefault()) {
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.browser_version)
}

// required string os_name = 6;
inline bool DevicesInfo::_internal_has_os_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DevicesInfo::has_os_name() const {
  return _internal_has_os_name();
}
inline void DevicesInfo::clear_os_name() {
  _impl_.os_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DevicesInfo::os_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.os_name)
  return _internal_os_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicesInfo::set_os_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.os_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.os_name)
}
inline std::string* DevicesInfo::mutable_os_name() {
  std::string* _s = _internal_mutable_os_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.os_name)
  return _s;
}
inline const std::string& DevicesInfo::_internal_os_name() const {
  return _impl_.os_name_.Get();
}
inline void DevicesInfo::_internal_set_os_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.os_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DevicesInfo::_internal_mutable_os_name() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.os_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DevicesInfo::release_os_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.os_name)
  if (!_internal_has_os_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.os_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_name_.IsDefault()) {
    _impl_.os_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DevicesInfo::set_allocated_os_name(std::string* os_name) {
  if (os_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.os_name_.SetAllocated(os_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_name_.IsDefault()) {
    _impl_.os_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.os_name)
}

// required string os_version = 7;
inline bool DevicesInfo::_internal_has_os_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DevicesInfo::has_os_version() const {
  return _internal_has_os_version();
}
inline void DevicesInfo::clear_os_version() {
  _impl_.os_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DevicesInfo::os_version() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.os_version)
  return _internal_os_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicesInfo::set_os_version(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000010u;
 _impl_.os_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.os_version)
}
inline std::string* DevicesInfo::mutable_os_version() {
  std::string* _s = _internal_mutable_os_version();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.os_version)
  return _s;
}
inline const std::string& DevicesInfo::_internal_os_version() const {
  return _impl_.os_version_.Get();
}
inline void DevicesInfo::_internal_set_os_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.os_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DevicesInfo::_internal_mutable_os_version() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.os_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DevicesInfo::release_os_version() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.os_version)
  if (!_internal_has_os_version()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* p = _impl_.os_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_version_.IsDefault()) {
    _impl_.os_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DevicesInfo::set_allocated_os_version(std::string* os_version) {
  if (os_version != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.os_version_.SetAllocated(os_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_version_.IsDefault()) {
    _impl_.os_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.os_version)
}

// required bool is_intel = 8;
inline bool DevicesInfo::_internal_has_is_intel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DevicesInfo::has_is_intel() const {
  return _internal_has_is_intel();
}
inline void DevicesInfo::clear_is_intel() {
  _impl_.is_intel_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool DevicesInfo::_internal_is_intel() const {
  return _impl_.is_intel_;
}
inline bool DevicesInfo::is_intel() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.is_intel)
  return _internal_is_intel();
}
inline void DevicesInfo::_internal_set_is_intel(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.is_intel_ = value;
}
inline void DevicesInfo::set_is_intel(bool value) {
  _internal_set_is_intel(value);
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.is_intel)
}

// required uint32 uid = 9;
inline bool DevicesInfo::_internal_has_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DevicesInfo::has_uid() const {
  return _internal_has_uid();
}
inline void DevicesInfo::clear_uid() {
  _impl_.uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline uint32_t DevicesInfo::_internal_uid() const {
  return _impl_.uid_;
}
inline uint32_t DevicesInfo::uid() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.uid)
  return _internal_uid();
}
inline void DevicesInfo::_internal_set_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.uid_ = value;
}
inline void DevicesInfo::set_uid(uint32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.uid)
}

// required string client_id = 10;
inline bool DevicesInfo::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DevicesInfo::has_client_id() const {
  return _internal_has_client_id();
}
inline void DevicesInfo::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DevicesInfo::client_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.DevicesInfo.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DevicesInfo::set_client_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000020u;
 _impl_.client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.DevicesInfo.client_id)
}
inline std::string* DevicesInfo::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:PTP.Common.DevicesInfo.client_id)
  return _s;
}
inline const std::string& DevicesInfo::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void DevicesInfo::_internal_set_client_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DevicesInfo::_internal_mutable_client_id() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DevicesInfo::release_client_id() {
  // @@protoc_insertion_point(field_release:PTP.Common.DevicesInfo.client_id)
  if (!_internal_has_client_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* p = _impl_.client_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_id_.IsDefault()) {
    _impl_.client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DevicesInfo::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_id_.IsDefault()) {
    _impl_.client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.DevicesInfo.client_id)
}

// -------------------------------------------------------------------

// InputPhoneContact

// required uint64 client_id = 1;
inline bool InputPhoneContact::_internal_has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InputPhoneContact::has_client_id() const {
  return _internal_has_client_id();
}
inline void InputPhoneContact::clear_client_id() {
  _impl_.client_id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t InputPhoneContact::_internal_client_id() const {
  return _impl_.client_id_;
}
inline uint64_t InputPhoneContact::client_id() const {
  // @@protoc_insertion_point(field_get:PTP.Common.InputPhoneContact.client_id)
  return _internal_client_id();
}
inline void InputPhoneContact::_internal_set_client_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.client_id_ = value;
}
inline void InputPhoneContact::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:PTP.Common.InputPhoneContact.client_id)
}

// optional string phone = 2;
inline bool InputPhoneContact::_internal_has_phone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InputPhoneContact::has_phone() const {
  return _internal_has_phone();
}
inline void InputPhoneContact::clear_phone() {
  _impl_.phone_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputPhoneContact::phone() const {
  // @@protoc_insertion_point(field_get:PTP.Common.InputPhoneContact.phone)
  return _internal_phone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputPhoneContact::set_phone(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.phone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.InputPhoneContact.phone)
}
inline std::string* InputPhoneContact::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:PTP.Common.InputPhoneContact.phone)
  return _s;
}
inline const std::string& InputPhoneContact::_internal_phone() const {
  return _impl_.phone_.Get();
}
inline void InputPhoneContact::_internal_set_phone(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.phone_.Set(value, GetArenaForAllocation());
}
inline std::string* InputPhoneContact::_internal_mutable_phone() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.phone_.Mutable(GetArenaForAllocation());
}
inline std::string* InputPhoneContact::release_phone() {
  // @@protoc_insertion_point(field_release:PTP.Common.InputPhoneContact.phone)
  if (!_internal_has_phone()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.phone_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phone_.IsDefault()) {
    _impl_.phone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InputPhoneContact::set_allocated_phone(std::string* phone) {
  if (phone != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.phone_.SetAllocated(phone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phone_.IsDefault()) {
    _impl_.phone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.InputPhoneContact.phone)
}

// optional string first_name = 3;
inline bool InputPhoneContact::_internal_has_first_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InputPhoneContact::has_first_name() const {
  return _internal_has_first_name();
}
inline void InputPhoneContact::clear_first_name() {
  _impl_.first_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InputPhoneContact::first_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.InputPhoneContact.first_name)
  return _internal_first_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputPhoneContact::set_first_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.first_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.InputPhoneContact.first_name)
}
inline std::string* InputPhoneContact::mutable_first_name() {
  std::string* _s = _internal_mutable_first_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.InputPhoneContact.first_name)
  return _s;
}
inline const std::string& InputPhoneContact::_internal_first_name() const {
  return _impl_.first_name_.Get();
}
inline void InputPhoneContact::_internal_set_first_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.first_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InputPhoneContact::_internal_mutable_first_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.first_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InputPhoneContact::release_first_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.InputPhoneContact.first_name)
  if (!_internal_has_first_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.first_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.first_name_.IsDefault()) {
    _impl_.first_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InputPhoneContact::set_allocated_first_name(std::string* first_name) {
  if (first_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.first_name_.SetAllocated(first_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.first_name_.IsDefault()) {
    _impl_.first_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.InputPhoneContact.first_name)
}

// optional string last_name = 4;
inline bool InputPhoneContact::_internal_has_last_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InputPhoneContact::has_last_name() const {
  return _internal_has_last_name();
}
inline void InputPhoneContact::clear_last_name() {
  _impl_.last_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InputPhoneContact::last_name() const {
  // @@protoc_insertion_point(field_get:PTP.Common.InputPhoneContact.last_name)
  return _internal_last_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InputPhoneContact::set_last_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.last_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Common.InputPhoneContact.last_name)
}
inline std::string* InputPhoneContact::mutable_last_name() {
  std::string* _s = _internal_mutable_last_name();
  // @@protoc_insertion_point(field_mutable:PTP.Common.InputPhoneContact.last_name)
  return _s;
}
inline const std::string& InputPhoneContact::_internal_last_name() const {
  return _impl_.last_name_.Get();
}
inline void InputPhoneContact::_internal_set_last_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.last_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InputPhoneContact::_internal_mutable_last_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.last_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InputPhoneContact::release_last_name() {
  // @@protoc_insertion_point(field_release:PTP.Common.InputPhoneContact.last_name)
  if (!_internal_has_last_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.last_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_name_.IsDefault()) {
    _impl_.last_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InputPhoneContact::set_allocated_last_name(std::string* last_name) {
  if (last_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.last_name_.SetAllocated(last_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_name_.IsDefault()) {
    _impl_.last_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Common.InputPhoneContact.last_name)
}

// -------------------------------------------------------------------

// BuddyQueryParam

// repeated string addressList = 1;
inline int BuddyQueryParam::_internal_addresslist_size() const {
  return _impl_.addresslist_.size();
}
inline int BuddyQueryParam::addresslist_size() const {
  return _internal_addresslist_size();
}
inline void BuddyQueryParam::clear_addresslist() {
  _impl_.addresslist_.Clear();
}
inline std::string* BuddyQueryParam::add_addresslist() {
  std::string* _s = _internal_add_addresslist();
  // @@protoc_insertion_point(field_add_mutable:PTP.Common.BuddyQueryParam.addressList)
  return _s;
}
inline const std::string& BuddyQueryParam::_internal_addresslist(int index) const {
  return _impl_.addresslist_.Get(index);
}
inline const std::string& BuddyQueryParam::addresslist(int index) const {
  // @@protoc_insertion_point(field_get:PTP.Common.BuddyQueryParam.addressList)
  return _internal_addresslist(index);
}
inline std::string* BuddyQueryParam::mutable_addresslist(int index) {
  // @@protoc_insertion_point(field_mutable:PTP.Common.BuddyQueryParam.addressList)
  return _impl_.addresslist_.Mutable(index);
}
inline void BuddyQueryParam::set_addresslist(int index, const std::string& value) {
  _impl_.addresslist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PTP.Common.BuddyQueryParam.addressList)
}
inline void BuddyQueryParam::set_addresslist(int index, std::string&& value) {
  _impl_.addresslist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PTP.Common.BuddyQueryParam.addressList)
}
inline void BuddyQueryParam::set_addresslist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addresslist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PTP.Common.BuddyQueryParam.addressList)
}
inline void BuddyQueryParam::set_addresslist(int index, const char* value, size_t size) {
  _impl_.addresslist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.BuddyQueryParam.addressList)
}
inline std::string* BuddyQueryParam::_internal_add_addresslist() {
  return _impl_.addresslist_.Add();
}
inline void BuddyQueryParam::add_addresslist(const std::string& value) {
  _impl_.addresslist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PTP.Common.BuddyQueryParam.addressList)
}
inline void BuddyQueryParam::add_addresslist(std::string&& value) {
  _impl_.addresslist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PTP.Common.BuddyQueryParam.addressList)
}
inline void BuddyQueryParam::add_addresslist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.addresslist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PTP.Common.BuddyQueryParam.addressList)
}
inline void BuddyQueryParam::add_addresslist(const char* value, size_t size) {
  _impl_.addresslist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PTP.Common.BuddyQueryParam.addressList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BuddyQueryParam::addresslist() const {
  // @@protoc_insertion_point(field_list:PTP.Common.BuddyQueryParam.addressList)
  return _impl_.addresslist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BuddyQueryParam::mutable_addresslist() {
  // @@protoc_insertion_point(field_mutable_list:PTP.Common.BuddyQueryParam.addressList)
  return &_impl_.addresslist_;
}

// repeated string usernameList = 2;
inline int BuddyQueryParam::_internal_usernamelist_size() const {
  return _impl_.usernamelist_.size();
}
inline int BuddyQueryParam::usernamelist_size() const {
  return _internal_usernamelist_size();
}
inline void BuddyQueryParam::clear_usernamelist() {
  _impl_.usernamelist_.Clear();
}
inline std::string* BuddyQueryParam::add_usernamelist() {
  std::string* _s = _internal_add_usernamelist();
  // @@protoc_insertion_point(field_add_mutable:PTP.Common.BuddyQueryParam.usernameList)
  return _s;
}
inline const std::string& BuddyQueryParam::_internal_usernamelist(int index) const {
  return _impl_.usernamelist_.Get(index);
}
inline const std::string& BuddyQueryParam::usernamelist(int index) const {
  // @@protoc_insertion_point(field_get:PTP.Common.BuddyQueryParam.usernameList)
  return _internal_usernamelist(index);
}
inline std::string* BuddyQueryParam::mutable_usernamelist(int index) {
  // @@protoc_insertion_point(field_mutable:PTP.Common.BuddyQueryParam.usernameList)
  return _impl_.usernamelist_.Mutable(index);
}
inline void BuddyQueryParam::set_usernamelist(int index, const std::string& value) {
  _impl_.usernamelist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:PTP.Common.BuddyQueryParam.usernameList)
}
inline void BuddyQueryParam::set_usernamelist(int index, std::string&& value) {
  _impl_.usernamelist_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:PTP.Common.BuddyQueryParam.usernameList)
}
inline void BuddyQueryParam::set_usernamelist(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.usernamelist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:PTP.Common.BuddyQueryParam.usernameList)
}
inline void BuddyQueryParam::set_usernamelist(int index, const char* value, size_t size) {
  _impl_.usernamelist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PTP.Common.BuddyQueryParam.usernameList)
}
inline std::string* BuddyQueryParam::_internal_add_usernamelist() {
  return _impl_.usernamelist_.Add();
}
inline void BuddyQueryParam::add_usernamelist(const std::string& value) {
  _impl_.usernamelist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:PTP.Common.BuddyQueryParam.usernameList)
}
inline void BuddyQueryParam::add_usernamelist(std::string&& value) {
  _impl_.usernamelist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:PTP.Common.BuddyQueryParam.usernameList)
}
inline void BuddyQueryParam::add_usernamelist(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.usernamelist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:PTP.Common.BuddyQueryParam.usernameList)
}
inline void BuddyQueryParam::add_usernamelist(const char* value, size_t size) {
  _impl_.usernamelist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:PTP.Common.BuddyQueryParam.usernameList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BuddyQueryParam::usernamelist() const {
  // @@protoc_insertion_point(field_list:PTP.Common.BuddyQueryParam.usernameList)
  return _impl_.usernamelist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BuddyQueryParam::mutable_usernamelist() {
  // @@protoc_insertion_point(field_mutable_list:PTP.Common.BuddyQueryParam.usernameList)
  return &_impl_.usernamelist_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Common
}  // namespace PTP

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::PTP::Common::ERR> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::SwitchType> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::UserStat> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::MsgType> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::ClientType> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::SessionStat> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::ShieldStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::BuddyModifyAction> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::GroupType> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::GroupMemberStatus> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::GroupModifyAction> : ::std::true_type {};
template <> struct is_proto_enum< ::PTP::Common::GroupMemberModifyAction> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_PTP_2eCommon_2eproto
