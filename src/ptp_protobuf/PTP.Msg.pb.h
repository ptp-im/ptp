// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PTP.Msg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_PTP_2eMsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_PTP_2eMsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "PTP.Common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_PTP_2eMsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_PTP_2eMsg_2eproto {
  static const uint32_t offsets[];
};
namespace PTP {
namespace Msg {
class MsgGetByIdsReq;
struct MsgGetByIdsReqDefaultTypeInternal;
extern MsgGetByIdsReqDefaultTypeInternal _MsgGetByIdsReq_default_instance_;
class MsgGetByIdsRes;
struct MsgGetByIdsResDefaultTypeInternal;
extern MsgGetByIdsResDefaultTypeInternal _MsgGetByIdsRes_default_instance_;
class MsgGetMaxIdReq;
struct MsgGetMaxIdReqDefaultTypeInternal;
extern MsgGetMaxIdReqDefaultTypeInternal _MsgGetMaxIdReq_default_instance_;
class MsgGetMaxIdRes;
struct MsgGetMaxIdResDefaultTypeInternal;
extern MsgGetMaxIdResDefaultTypeInternal _MsgGetMaxIdRes_default_instance_;
class MsgNotify;
struct MsgNotifyDefaultTypeInternal;
extern MsgNotifyDefaultTypeInternal _MsgNotify_default_instance_;
class MsgReadAckReq;
struct MsgReadAckReqDefaultTypeInternal;
extern MsgReadAckReqDefaultTypeInternal _MsgReadAckReq_default_instance_;
class MsgReadNotify;
struct MsgReadNotifyDefaultTypeInternal;
extern MsgReadNotifyDefaultTypeInternal _MsgReadNotify_default_instance_;
class MsgReq;
struct MsgReqDefaultTypeInternal;
extern MsgReqDefaultTypeInternal _MsgReq_default_instance_;
class MsgRes;
struct MsgResDefaultTypeInternal;
extern MsgResDefaultTypeInternal _MsgRes_default_instance_;
class MsgUnNotify;
struct MsgUnNotifyDefaultTypeInternal;
extern MsgUnNotifyDefaultTypeInternal _MsgUnNotify_default_instance_;
}  // namespace Msg
}  // namespace PTP
PROTOBUF_NAMESPACE_OPEN
template<> ::PTP::Msg::MsgGetByIdsReq* Arena::CreateMaybeMessage<::PTP::Msg::MsgGetByIdsReq>(Arena*);
template<> ::PTP::Msg::MsgGetByIdsRes* Arena::CreateMaybeMessage<::PTP::Msg::MsgGetByIdsRes>(Arena*);
template<> ::PTP::Msg::MsgGetMaxIdReq* Arena::CreateMaybeMessage<::PTP::Msg::MsgGetMaxIdReq>(Arena*);
template<> ::PTP::Msg::MsgGetMaxIdRes* Arena::CreateMaybeMessage<::PTP::Msg::MsgGetMaxIdRes>(Arena*);
template<> ::PTP::Msg::MsgNotify* Arena::CreateMaybeMessage<::PTP::Msg::MsgNotify>(Arena*);
template<> ::PTP::Msg::MsgReadAckReq* Arena::CreateMaybeMessage<::PTP::Msg::MsgReadAckReq>(Arena*);
template<> ::PTP::Msg::MsgReadNotify* Arena::CreateMaybeMessage<::PTP::Msg::MsgReadNotify>(Arena*);
template<> ::PTP::Msg::MsgReq* Arena::CreateMaybeMessage<::PTP::Msg::MsgReq>(Arena*);
template<> ::PTP::Msg::MsgRes* Arena::CreateMaybeMessage<::PTP::Msg::MsgRes>(Arena*);
template<> ::PTP::Msg::MsgUnNotify* Arena::CreateMaybeMessage<::PTP::Msg::MsgUnNotify>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace PTP {
namespace Msg {

// ===================================================================

class MsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Msg.MsgReq) */ {
 public:
  inline MsgReq() : MsgReq(nullptr) {}
  ~MsgReq() override;
  explicit PROTOBUF_CONSTEXPR MsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgReq(const MsgReq& from);
  MsgReq(MsgReq&& from) noexcept
    : MsgReq() {
    *this = ::std::move(from);
  }

  inline MsgReq& operator=(const MsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgReq& operator=(MsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgReq* internal_default_instance() {
    return reinterpret_cast<const MsgReq*>(
               &_MsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgReq& a, MsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgReq& from);
  void MergeFrom(const MsgReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Msg.MsgReq";
  }
  protected:
  explicit MsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupAdrFieldNumber = 1,
    kMsgDataFieldNumber = 7,
    kAttachDataFieldNumber = 20,
    kSentAtFieldNumber = 3,
    kAuthUidFieldNumber = 21,
    kMsgTypeFieldNumber = 6,
  };
  // required string group_adr = 1;
  bool has_group_adr() const;
  private:
  bool _internal_has_group_adr() const;
  public:
  void clear_group_adr();
  const std::string& group_adr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_adr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_adr();
  PROTOBUF_NODISCARD std::string* release_group_adr();
  void set_allocated_group_adr(std::string* group_adr);
  private:
  const std::string& _internal_group_adr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_adr(const std::string& value);
  std::string* _internal_mutable_group_adr();
  public:

  // optional string msg_data = 7;
  bool has_msg_data() const;
  private:
  bool _internal_has_msg_data() const;
  public:
  void clear_msg_data();
  const std::string& msg_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg_data();
  PROTOBUF_NODISCARD std::string* release_msg_data();
  void set_allocated_msg_data(std::string* msg_data);
  private:
  const std::string& _internal_msg_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg_data(const std::string& value);
  std::string* _internal_mutable_msg_data();
  public:

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 sent_at = 3;
  bool has_sent_at() const;
  private:
  bool _internal_has_sent_at() const;
  public:
  void clear_sent_at();
  uint32_t sent_at() const;
  void set_sent_at(uint32_t value);
  private:
  uint32_t _internal_sent_at() const;
  void _internal_set_sent_at(uint32_t value);
  public:

  // optional uint32 auth_uid = 21;
  bool has_auth_uid() const;
  private:
  bool _internal_has_auth_uid() const;
  public:
  void clear_auth_uid();
  uint32_t auth_uid() const;
  void set_auth_uid(uint32_t value);
  private:
  uint32_t _internal_auth_uid() const;
  void _internal_set_auth_uid(uint32_t value);
  public:

  // required .PTP.Common.MsgType msg_type = 6;
  bool has_msg_type() const;
  private:
  bool _internal_has_msg_type() const;
  public:
  void clear_msg_type();
  ::PTP::Common::MsgType msg_type() const;
  void set_msg_type(::PTP::Common::MsgType value);
  private:
  ::PTP::Common::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::PTP::Common::MsgType value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Msg.MsgReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_adr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t sent_at_;
    uint32_t auth_uid_;
    int msg_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eMsg_2eproto;
};
// -------------------------------------------------------------------

class MsgRes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Msg.MsgRes) */ {
 public:
  inline MsgRes() : MsgRes(nullptr) {}
  ~MsgRes() override;
  explicit PROTOBUF_CONSTEXPR MsgRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgRes(const MsgRes& from);
  MsgRes(MsgRes&& from) noexcept
    : MsgRes() {
    *this = ::std::move(from);
  }

  inline MsgRes& operator=(const MsgRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgRes& operator=(MsgRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgRes* internal_default_instance() {
    return reinterpret_cast<const MsgRes*>(
               &_MsgRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MsgRes& a, MsgRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgRes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgRes& from);
  void MergeFrom(const MsgRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Msg.MsgRes";
  }
  protected:
  explicit MsgRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kGroupIdFieldNumber = 1,
    kMsgIdFieldNumber = 3,
    kSentAtFieldNumber = 4,
    kErrorFieldNumber = 7,
    kAuthUidFieldNumber = 21,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // optional uint32 group_id = 1;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // optional uint32 msg_id = 3;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // optional uint32 sent_at = 4;
  bool has_sent_at() const;
  private:
  bool _internal_has_sent_at() const;
  public:
  void clear_sent_at();
  uint32_t sent_at() const;
  void set_sent_at(uint32_t value);
  private:
  uint32_t _internal_sent_at() const;
  void _internal_set_sent_at(uint32_t value);
  public:

  // optional .PTP.Common.ERR error = 7;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::PTP::Common::ERR error() const;
  void set_error(::PTP::Common::ERR value);
  private:
  ::PTP::Common::ERR _internal_error() const;
  void _internal_set_error(::PTP::Common::ERR value);
  public:

  // optional uint32 auth_uid = 21;
  bool has_auth_uid() const;
  private:
  bool _internal_has_auth_uid() const;
  public:
  void clear_auth_uid();
  uint32_t auth_uid() const;
  void set_auth_uid(uint32_t value);
  private:
  uint32_t _internal_auth_uid() const;
  void _internal_set_auth_uid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Msg.MsgRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t group_id_;
    uint32_t msg_id_;
    uint32_t sent_at_;
    int error_;
    uint32_t auth_uid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eMsg_2eproto;
};
// -------------------------------------------------------------------

class MsgNotify final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Msg.MsgNotify) */ {
 public:
  inline MsgNotify() : MsgNotify(nullptr) {}
  ~MsgNotify() override;
  explicit PROTOBUF_CONSTEXPR MsgNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgNotify(const MsgNotify& from);
  MsgNotify(MsgNotify&& from) noexcept
    : MsgNotify() {
    *this = ::std::move(from);
  }

  inline MsgNotify& operator=(const MsgNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgNotify& operator=(MsgNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgNotify* internal_default_instance() {
    return reinterpret_cast<const MsgNotify*>(
               &_MsgNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MsgNotify& a, MsgNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgNotify& from);
  void MergeFrom(const MsgNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Msg.MsgNotify";
  }
  protected:
  explicit MsgNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotifyUsersFieldNumber = 2,
    kAttachDataFieldNumber = 20,
    kMsgInfoFieldNumber = 1,
    kAuthUidFieldNumber = 21,
  };
  // repeated uint32 notify_users = 2;
  int notify_users_size() const;
  private:
  int _internal_notify_users_size() const;
  public:
  void clear_notify_users();
  private:
  uint32_t _internal_notify_users(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_notify_users() const;
  void _internal_add_notify_users(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_notify_users();
  public:
  uint32_t notify_users(int index) const;
  void set_notify_users(int index, uint32_t value);
  void add_notify_users(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      notify_users() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_notify_users();

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required .PTP.Common.MsgInfo msg_info = 1;
  bool has_msg_info() const;
  private:
  bool _internal_has_msg_info() const;
  public:
  void clear_msg_info();
  const ::PTP::Common::MsgInfo& msg_info() const;
  PROTOBUF_NODISCARD ::PTP::Common::MsgInfo* release_msg_info();
  ::PTP::Common::MsgInfo* mutable_msg_info();
  void set_allocated_msg_info(::PTP::Common::MsgInfo* msg_info);
  private:
  const ::PTP::Common::MsgInfo& _internal_msg_info() const;
  ::PTP::Common::MsgInfo* _internal_mutable_msg_info();
  public:
  void unsafe_arena_set_allocated_msg_info(
      ::PTP::Common::MsgInfo* msg_info);
  ::PTP::Common::MsgInfo* unsafe_arena_release_msg_info();

  // optional uint32 auth_uid = 21;
  bool has_auth_uid() const;
  private:
  bool _internal_has_auth_uid() const;
  public:
  void clear_auth_uid();
  uint32_t auth_uid() const;
  void set_auth_uid(uint32_t value);
  private:
  uint32_t _internal_auth_uid() const;
  void _internal_set_auth_uid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Msg.MsgNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > notify_users_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    ::PTP::Common::MsgInfo* msg_info_;
    uint32_t auth_uid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eMsg_2eproto;
};
// -------------------------------------------------------------------

class MsgUnNotify final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Msg.MsgUnNotify) */ {
 public:
  inline MsgUnNotify() : MsgUnNotify(nullptr) {}
  ~MsgUnNotify() override;
  explicit PROTOBUF_CONSTEXPR MsgUnNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgUnNotify(const MsgUnNotify& from);
  MsgUnNotify(MsgUnNotify&& from) noexcept
    : MsgUnNotify() {
    *this = ::std::move(from);
  }

  inline MsgUnNotify& operator=(const MsgUnNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgUnNotify& operator=(MsgUnNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgUnNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgUnNotify* internal_default_instance() {
    return reinterpret_cast<const MsgUnNotify*>(
               &_MsgUnNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MsgUnNotify& a, MsgUnNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgUnNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgUnNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgUnNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgUnNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgUnNotify& from);
  void MergeFrom(const MsgUnNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgUnNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Msg.MsgUnNotify";
  }
  protected:
  explicit MsgUnNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnNotifyUsersFieldNumber = 1,
    kSentAtFieldNumber = 2,
    kGroupIdFieldNumber = 3,
    kFromUidFieldNumber = 4,
  };
  // repeated uint32 un_notify_users = 1;
  int un_notify_users_size() const;
  private:
  int _internal_un_notify_users_size() const;
  public:
  void clear_un_notify_users();
  private:
  uint32_t _internal_un_notify_users(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_un_notify_users() const;
  void _internal_add_un_notify_users(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_un_notify_users();
  public:
  uint32_t un_notify_users(int index) const;
  void set_un_notify_users(int index, uint32_t value);
  void add_un_notify_users(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      un_notify_users() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_un_notify_users();

  // required uint32 sent_at = 2;
  bool has_sent_at() const;
  private:
  bool _internal_has_sent_at() const;
  public:
  void clear_sent_at();
  uint32_t sent_at() const;
  void set_sent_at(uint32_t value);
  private:
  uint32_t _internal_sent_at() const;
  void _internal_set_sent_at(uint32_t value);
  public:

  // required uint32 group_id = 3;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required uint32 from_uid = 4;
  bool has_from_uid() const;
  private:
  bool _internal_has_from_uid() const;
  public:
  void clear_from_uid();
  uint32_t from_uid() const;
  void set_from_uid(uint32_t value);
  private:
  uint32_t _internal_from_uid() const;
  void _internal_set_from_uid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Msg.MsgUnNotify)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > un_notify_users_;
    uint32_t sent_at_;
    uint32_t group_id_;
    uint32_t from_uid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eMsg_2eproto;
};
// -------------------------------------------------------------------

class MsgReadAckReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Msg.MsgReadAckReq) */ {
 public:
  inline MsgReadAckReq() : MsgReadAckReq(nullptr) {}
  ~MsgReadAckReq() override;
  explicit PROTOBUF_CONSTEXPR MsgReadAckReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgReadAckReq(const MsgReadAckReq& from);
  MsgReadAckReq(MsgReadAckReq&& from) noexcept
    : MsgReadAckReq() {
    *this = ::std::move(from);
  }

  inline MsgReadAckReq& operator=(const MsgReadAckReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgReadAckReq& operator=(MsgReadAckReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgReadAckReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgReadAckReq* internal_default_instance() {
    return reinterpret_cast<const MsgReadAckReq*>(
               &_MsgReadAckReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MsgReadAckReq& a, MsgReadAckReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgReadAckReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgReadAckReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgReadAckReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgReadAckReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgReadAckReq& from);
  void MergeFrom(const MsgReadAckReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgReadAckReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Msg.MsgReadAckReq";
  }
  protected:
  explicit MsgReadAckReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kGroupIdFieldNumber = 1,
    kMsgIdFieldNumber = 3,
    kAuthUidFieldNumber = 21,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 group_id = 1;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required uint32 msg_id = 3;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // optional uint32 auth_uid = 21;
  bool has_auth_uid() const;
  private:
  bool _internal_has_auth_uid() const;
  public:
  void clear_auth_uid();
  uint32_t auth_uid() const;
  void set_auth_uid(uint32_t value);
  private:
  uint32_t _internal_auth_uid() const;
  void _internal_set_auth_uid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Msg.MsgReadAckReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t group_id_;
    uint32_t msg_id_;
    uint32_t auth_uid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eMsg_2eproto;
};
// -------------------------------------------------------------------

class MsgReadNotify final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Msg.MsgReadNotify) */ {
 public:
  inline MsgReadNotify() : MsgReadNotify(nullptr) {}
  ~MsgReadNotify() override;
  explicit PROTOBUF_CONSTEXPR MsgReadNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgReadNotify(const MsgReadNotify& from);
  MsgReadNotify(MsgReadNotify&& from) noexcept
    : MsgReadNotify() {
    *this = ::std::move(from);
  }

  inline MsgReadNotify& operator=(const MsgReadNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgReadNotify& operator=(MsgReadNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgReadNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgReadNotify* internal_default_instance() {
    return reinterpret_cast<const MsgReadNotify*>(
               &_MsgReadNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MsgReadNotify& a, MsgReadNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgReadNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgReadNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgReadNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgReadNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgReadNotify& from);
  void MergeFrom(const MsgReadNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgReadNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Msg.MsgReadNotify";
  }
  protected:
  explicit MsgReadNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotifyUsersFieldNumber = 3,
    kAttachDataFieldNumber = 20,
    kGroupIdFieldNumber = 1,
    kFromUidFieldNumber = 2,
    kMsgIdFieldNumber = 4,
    kAuthUidFieldNumber = 21,
  };
  // repeated uint32 notify_users = 3;
  int notify_users_size() const;
  private:
  int _internal_notify_users_size() const;
  public:
  void clear_notify_users();
  private:
  uint32_t _internal_notify_users(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_notify_users() const;
  void _internal_add_notify_users(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_notify_users();
  public:
  uint32_t notify_users(int index) const;
  void set_notify_users(int index, uint32_t value);
  void add_notify_users(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      notify_users() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_notify_users();

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 group_id = 1;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required uint32 from_uid = 2;
  bool has_from_uid() const;
  private:
  bool _internal_has_from_uid() const;
  public:
  void clear_from_uid();
  uint32_t from_uid() const;
  void set_from_uid(uint32_t value);
  private:
  uint32_t _internal_from_uid() const;
  void _internal_set_from_uid(uint32_t value);
  public:

  // required uint32 msg_id = 4;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // optional uint32 auth_uid = 21;
  bool has_auth_uid() const;
  private:
  bool _internal_has_auth_uid() const;
  public:
  void clear_auth_uid();
  uint32_t auth_uid() const;
  void set_auth_uid(uint32_t value);
  private:
  uint32_t _internal_auth_uid() const;
  void _internal_set_auth_uid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Msg.MsgReadNotify)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > notify_users_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t group_id_;
    uint32_t from_uid_;
    uint32_t msg_id_;
    uint32_t auth_uid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eMsg_2eproto;
};
// -------------------------------------------------------------------

class MsgGetMaxIdReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Msg.MsgGetMaxIdReq) */ {
 public:
  inline MsgGetMaxIdReq() : MsgGetMaxIdReq(nullptr) {}
  ~MsgGetMaxIdReq() override;
  explicit PROTOBUF_CONSTEXPR MsgGetMaxIdReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgGetMaxIdReq(const MsgGetMaxIdReq& from);
  MsgGetMaxIdReq(MsgGetMaxIdReq&& from) noexcept
    : MsgGetMaxIdReq() {
    *this = ::std::move(from);
  }

  inline MsgGetMaxIdReq& operator=(const MsgGetMaxIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgGetMaxIdReq& operator=(MsgGetMaxIdReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgGetMaxIdReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgGetMaxIdReq* internal_default_instance() {
    return reinterpret_cast<const MsgGetMaxIdReq*>(
               &_MsgGetMaxIdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MsgGetMaxIdReq& a, MsgGetMaxIdReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgGetMaxIdReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgGetMaxIdReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgGetMaxIdReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgGetMaxIdReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgGetMaxIdReq& from);
  void MergeFrom(const MsgGetMaxIdReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgGetMaxIdReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Msg.MsgGetMaxIdReq";
  }
  protected:
  explicit MsgGetMaxIdReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kGroupIdFieldNumber = 1,
    kAuthUidFieldNumber = 21,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 group_id = 1;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // optional uint32 auth_uid = 21;
  bool has_auth_uid() const;
  private:
  bool _internal_has_auth_uid() const;
  public:
  void clear_auth_uid();
  uint32_t auth_uid() const;
  void set_auth_uid(uint32_t value);
  private:
  uint32_t _internal_auth_uid() const;
  void _internal_set_auth_uid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Msg.MsgGetMaxIdReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t group_id_;
    uint32_t auth_uid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eMsg_2eproto;
};
// -------------------------------------------------------------------

class MsgGetMaxIdRes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Msg.MsgGetMaxIdRes) */ {
 public:
  inline MsgGetMaxIdRes() : MsgGetMaxIdRes(nullptr) {}
  ~MsgGetMaxIdRes() override;
  explicit PROTOBUF_CONSTEXPR MsgGetMaxIdRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgGetMaxIdRes(const MsgGetMaxIdRes& from);
  MsgGetMaxIdRes(MsgGetMaxIdRes&& from) noexcept
    : MsgGetMaxIdRes() {
    *this = ::std::move(from);
  }

  inline MsgGetMaxIdRes& operator=(const MsgGetMaxIdRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgGetMaxIdRes& operator=(MsgGetMaxIdRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgGetMaxIdRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgGetMaxIdRes* internal_default_instance() {
    return reinterpret_cast<const MsgGetMaxIdRes*>(
               &_MsgGetMaxIdRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MsgGetMaxIdRes& a, MsgGetMaxIdRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgGetMaxIdRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgGetMaxIdRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgGetMaxIdRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgGetMaxIdRes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgGetMaxIdRes& from);
  void MergeFrom(const MsgGetMaxIdRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgGetMaxIdRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Msg.MsgGetMaxIdRes";
  }
  protected:
  explicit MsgGetMaxIdRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachDataFieldNumber = 20,
    kGroupIdFieldNumber = 1,
    kMsgIdFieldNumber = 2,
    kErrorFieldNumber = 3,
    kAuthUidFieldNumber = 21,
  };
  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 group_id = 1;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // required uint32 msg_id = 2;
  bool has_msg_id() const;
  private:
  bool _internal_has_msg_id() const;
  public:
  void clear_msg_id();
  uint32_t msg_id() const;
  void set_msg_id(uint32_t value);
  private:
  uint32_t _internal_msg_id() const;
  void _internal_set_msg_id(uint32_t value);
  public:

  // optional .PTP.Common.ERR error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::PTP::Common::ERR error() const;
  void set_error(::PTP::Common::ERR value);
  private:
  ::PTP::Common::ERR _internal_error() const;
  void _internal_set_error(::PTP::Common::ERR value);
  public:

  // optional uint32 auth_uid = 21;
  bool has_auth_uid() const;
  private:
  bool _internal_has_auth_uid() const;
  public:
  void clear_auth_uid();
  uint32_t auth_uid() const;
  void set_auth_uid(uint32_t value);
  private:
  uint32_t _internal_auth_uid() const;
  void _internal_set_auth_uid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Msg.MsgGetMaxIdRes)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t group_id_;
    uint32_t msg_id_;
    int error_;
    uint32_t auth_uid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eMsg_2eproto;
};
// -------------------------------------------------------------------

class MsgGetByIdsReq final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Msg.MsgGetByIdsReq) */ {
 public:
  inline MsgGetByIdsReq() : MsgGetByIdsReq(nullptr) {}
  ~MsgGetByIdsReq() override;
  explicit PROTOBUF_CONSTEXPR MsgGetByIdsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgGetByIdsReq(const MsgGetByIdsReq& from);
  MsgGetByIdsReq(MsgGetByIdsReq&& from) noexcept
    : MsgGetByIdsReq() {
    *this = ::std::move(from);
  }

  inline MsgGetByIdsReq& operator=(const MsgGetByIdsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgGetByIdsReq& operator=(MsgGetByIdsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgGetByIdsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgGetByIdsReq* internal_default_instance() {
    return reinterpret_cast<const MsgGetByIdsReq*>(
               &_MsgGetByIdsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MsgGetByIdsReq& a, MsgGetByIdsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgGetByIdsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgGetByIdsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgGetByIdsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgGetByIdsReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgGetByIdsReq& from);
  void MergeFrom(const MsgGetByIdsReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgGetByIdsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Msg.MsgGetByIdsReq";
  }
  protected:
  explicit MsgGetByIdsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgIdsFieldNumber = 2,
    kAttachDataFieldNumber = 20,
    kGroupIdFieldNumber = 1,
    kAuthUidFieldNumber = 21,
  };
  // repeated uint32 msg_ids = 2;
  int msg_ids_size() const;
  private:
  int _internal_msg_ids_size() const;
  public:
  void clear_msg_ids();
  private:
  uint32_t _internal_msg_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_msg_ids() const;
  void _internal_add_msg_ids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_msg_ids();
  public:
  uint32_t msg_ids(int index) const;
  void set_msg_ids(int index, uint32_t value);
  void add_msg_ids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      msg_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_msg_ids();

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // required uint32 group_id = 1;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // optional uint32 auth_uid = 21;
  bool has_auth_uid() const;
  private:
  bool _internal_has_auth_uid() const;
  public:
  void clear_auth_uid();
  uint32_t auth_uid() const;
  void set_auth_uid(uint32_t value);
  private:
  uint32_t _internal_auth_uid() const;
  void _internal_set_auth_uid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Msg.MsgGetByIdsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > msg_ids_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t group_id_;
    uint32_t auth_uid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eMsg_2eproto;
};
// -------------------------------------------------------------------

class MsgGetByIdsRes final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:PTP.Msg.MsgGetByIdsRes) */ {
 public:
  inline MsgGetByIdsRes() : MsgGetByIdsRes(nullptr) {}
  ~MsgGetByIdsRes() override;
  explicit PROTOBUF_CONSTEXPR MsgGetByIdsRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgGetByIdsRes(const MsgGetByIdsRes& from);
  MsgGetByIdsRes(MsgGetByIdsRes&& from) noexcept
    : MsgGetByIdsRes() {
    *this = ::std::move(from);
  }

  inline MsgGetByIdsRes& operator=(const MsgGetByIdsRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgGetByIdsRes& operator=(MsgGetByIdsRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MsgGetByIdsRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgGetByIdsRes* internal_default_instance() {
    return reinterpret_cast<const MsgGetByIdsRes*>(
               &_MsgGetByIdsRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MsgGetByIdsRes& a, MsgGetByIdsRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgGetByIdsRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgGetByIdsRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgGetByIdsRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgGetByIdsRes>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MsgGetByIdsRes& from);
  void MergeFrom(const MsgGetByIdsRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MsgGetByIdsRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PTP.Msg.MsgGetByIdsRes";
  }
  protected:
  explicit MsgGetByIdsRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgListFieldNumber = 2,
    kAttachDataFieldNumber = 20,
    kGroupIdFieldNumber = 1,
    kErrorFieldNumber = 3,
    kAuthUidFieldNumber = 21,
  };
  // repeated .PTP.Common.MsgInfo msg_list = 2;
  int msg_list_size() const;
  private:
  int _internal_msg_list_size() const;
  public:
  void clear_msg_list();
  ::PTP::Common::MsgInfo* mutable_msg_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PTP::Common::MsgInfo >*
      mutable_msg_list();
  private:
  const ::PTP::Common::MsgInfo& _internal_msg_list(int index) const;
  ::PTP::Common::MsgInfo* _internal_add_msg_list();
  public:
  const ::PTP::Common::MsgInfo& msg_list(int index) const;
  ::PTP::Common::MsgInfo* add_msg_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PTP::Common::MsgInfo >&
      msg_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  private:
  bool _internal_has_attach_data() const;
  public:
  void clear_attach_data();
  const std::string& attach_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attach_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attach_data();
  PROTOBUF_NODISCARD std::string* release_attach_data();
  void set_allocated_attach_data(std::string* attach_data);
  private:
  const std::string& _internal_attach_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_data(const std::string& value);
  std::string* _internal_mutable_attach_data();
  public:

  // optional uint32 group_id = 1;
  bool has_group_id() const;
  private:
  bool _internal_has_group_id() const;
  public:
  void clear_group_id();
  uint32_t group_id() const;
  void set_group_id(uint32_t value);
  private:
  uint32_t _internal_group_id() const;
  void _internal_set_group_id(uint32_t value);
  public:

  // optional .PTP.Common.ERR error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::PTP::Common::ERR error() const;
  void set_error(::PTP::Common::ERR value);
  private:
  ::PTP::Common::ERR _internal_error() const;
  void _internal_set_error(::PTP::Common::ERR value);
  public:

  // optional uint32 auth_uid = 21;
  bool has_auth_uid() const;
  private:
  bool _internal_has_auth_uid() const;
  public:
  void clear_auth_uid();
  uint32_t auth_uid() const;
  void set_auth_uid(uint32_t value);
  private:
  uint32_t _internal_auth_uid() const;
  void _internal_set_auth_uid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PTP.Msg.MsgGetByIdsRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PTP::Common::MsgInfo > msg_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attach_data_;
    uint32_t group_id_;
    int error_;
    uint32_t auth_uid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PTP_2eMsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgReq

// required string group_adr = 1;
inline bool MsgReq::_internal_has_group_adr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgReq::has_group_adr() const {
  return _internal_has_group_adr();
}
inline void MsgReq::clear_group_adr() {
  _impl_.group_adr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgReq::group_adr() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReq.group_adr)
  return _internal_group_adr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgReq::set_group_adr(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.group_adr_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReq.group_adr)
}
inline std::string* MsgReq::mutable_group_adr() {
  std::string* _s = _internal_mutable_group_adr();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgReq.group_adr)
  return _s;
}
inline const std::string& MsgReq::_internal_group_adr() const {
  return _impl_.group_adr_.Get();
}
inline void MsgReq::_internal_set_group_adr(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.group_adr_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgReq::_internal_mutable_group_adr() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.group_adr_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgReq::release_group_adr() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgReq.group_adr)
  if (!_internal_has_group_adr()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.group_adr_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_adr_.IsDefault()) {
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgReq::set_allocated_group_adr(std::string* group_adr) {
  if (group_adr != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.group_adr_.SetAllocated(group_adr, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_adr_.IsDefault()) {
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgReq.group_adr)
}

// required uint32 sent_at = 3;
inline bool MsgReq::_internal_has_sent_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgReq::has_sent_at() const {
  return _internal_has_sent_at();
}
inline void MsgReq::clear_sent_at() {
  _impl_.sent_at_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MsgReq::_internal_sent_at() const {
  return _impl_.sent_at_;
}
inline uint32_t MsgReq::sent_at() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReq.sent_at)
  return _internal_sent_at();
}
inline void MsgReq::_internal_set_sent_at(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sent_at_ = value;
}
inline void MsgReq::set_sent_at(uint32_t value) {
  _internal_set_sent_at(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReq.sent_at)
}

// required .PTP.Common.MsgType msg_type = 6;
inline bool MsgReq::_internal_has_msg_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MsgReq::has_msg_type() const {
  return _internal_has_msg_type();
}
inline void MsgReq::clear_msg_type() {
  _impl_.msg_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::PTP::Common::MsgType MsgReq::_internal_msg_type() const {
  return static_cast< ::PTP::Common::MsgType >(_impl_.msg_type_);
}
inline ::PTP::Common::MsgType MsgReq::msg_type() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReq.msg_type)
  return _internal_msg_type();
}
inline void MsgReq::_internal_set_msg_type(::PTP::Common::MsgType value) {
  assert(::PTP::Common::MsgType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.msg_type_ = value;
}
inline void MsgReq::set_msg_type(::PTP::Common::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReq.msg_type)
}

// optional string msg_data = 7;
inline bool MsgReq::_internal_has_msg_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgReq::has_msg_data() const {
  return _internal_has_msg_data();
}
inline void MsgReq::clear_msg_data() {
  _impl_.msg_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MsgReq::msg_data() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReq.msg_data)
  return _internal_msg_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgReq::set_msg_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.msg_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReq.msg_data)
}
inline std::string* MsgReq::mutable_msg_data() {
  std::string* _s = _internal_mutable_msg_data();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgReq.msg_data)
  return _s;
}
inline const std::string& MsgReq::_internal_msg_data() const {
  return _impl_.msg_data_.Get();
}
inline void MsgReq::_internal_set_msg_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.msg_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgReq::_internal_mutable_msg_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.msg_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgReq::release_msg_data() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgReq.msg_data)
  if (!_internal_has_msg_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.msg_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_data_.IsDefault()) {
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgReq::set_allocated_msg_data(std::string* msg_data) {
  if (msg_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.msg_data_.SetAllocated(msg_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_data_.IsDefault()) {
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgReq.msg_data)
}

// optional bytes attach_data = 20;
inline bool MsgReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void MsgReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MsgReq::attach_data() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReq.attach_data)
}
inline std::string* MsgReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgReq.attach_data)
  return _s;
}
inline const std::string& MsgReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void MsgReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgReq.attach_data)
}

// optional uint32 auth_uid = 21;
inline bool MsgReq::_internal_has_auth_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MsgReq::has_auth_uid() const {
  return _internal_has_auth_uid();
}
inline void MsgReq::clear_auth_uid() {
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MsgReq::_internal_auth_uid() const {
  return _impl_.auth_uid_;
}
inline uint32_t MsgReq::auth_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReq.auth_uid)
  return _internal_auth_uid();
}
inline void MsgReq::_internal_set_auth_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.auth_uid_ = value;
}
inline void MsgReq::set_auth_uid(uint32_t value) {
  _internal_set_auth_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReq.auth_uid)
}

// -------------------------------------------------------------------

// MsgRes

// optional uint32 group_id = 1;
inline bool MsgRes::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgRes::has_group_id() const {
  return _internal_has_group_id();
}
inline void MsgRes::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgRes::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t MsgRes::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgRes.group_id)
  return _internal_group_id();
}
inline void MsgRes::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_id_ = value;
}
inline void MsgRes::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgRes.group_id)
}

// optional uint32 msg_id = 3;
inline bool MsgRes::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgRes::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgRes::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgRes::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgRes::msg_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgRes.msg_id)
  return _internal_msg_id();
}
inline void MsgRes::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msg_id_ = value;
}
inline void MsgRes::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgRes.msg_id)
}

// optional uint32 sent_at = 4;
inline bool MsgRes::_internal_has_sent_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgRes::has_sent_at() const {
  return _internal_has_sent_at();
}
inline void MsgRes::clear_sent_at() {
  _impl_.sent_at_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MsgRes::_internal_sent_at() const {
  return _impl_.sent_at_;
}
inline uint32_t MsgRes::sent_at() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgRes.sent_at)
  return _internal_sent_at();
}
inline void MsgRes::_internal_set_sent_at(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sent_at_ = value;
}
inline void MsgRes::set_sent_at(uint32_t value) {
  _internal_set_sent_at(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgRes.sent_at)
}

// optional .PTP.Common.ERR error = 7;
inline bool MsgRes::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MsgRes::has_error() const {
  return _internal_has_error();
}
inline void MsgRes::clear_error() {
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::PTP::Common::ERR MsgRes::_internal_error() const {
  return static_cast< ::PTP::Common::ERR >(_impl_.error_);
}
inline ::PTP::Common::ERR MsgRes::error() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgRes.error)
  return _internal_error();
}
inline void MsgRes::_internal_set_error(::PTP::Common::ERR value) {
  assert(::PTP::Common::ERR_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_ = value;
}
inline void MsgRes::set_error(::PTP::Common::ERR value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgRes.error)
}

// optional bytes attach_data = 20;
inline bool MsgRes::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgRes::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void MsgRes::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgRes::attach_data() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgRes.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgRes::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgRes.attach_data)
}
inline std::string* MsgRes::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgRes.attach_data)
  return _s;
}
inline const std::string& MsgRes::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void MsgRes::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgRes::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgRes::release_attach_data() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgRes.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgRes::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgRes.attach_data)
}

// optional uint32 auth_uid = 21;
inline bool MsgRes::_internal_has_auth_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MsgRes::has_auth_uid() const {
  return _internal_has_auth_uid();
}
inline void MsgRes::clear_auth_uid() {
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t MsgRes::_internal_auth_uid() const {
  return _impl_.auth_uid_;
}
inline uint32_t MsgRes::auth_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgRes.auth_uid)
  return _internal_auth_uid();
}
inline void MsgRes::_internal_set_auth_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.auth_uid_ = value;
}
inline void MsgRes::set_auth_uid(uint32_t value) {
  _internal_set_auth_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgRes.auth_uid)
}

// -------------------------------------------------------------------

// MsgNotify

// required .PTP.Common.MsgInfo msg_info = 1;
inline bool MsgNotify::_internal_has_msg_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.msg_info_ != nullptr);
  return value;
}
inline bool MsgNotify::has_msg_info() const {
  return _internal_has_msg_info();
}
inline const ::PTP::Common::MsgInfo& MsgNotify::_internal_msg_info() const {
  const ::PTP::Common::MsgInfo* p = _impl_.msg_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::PTP::Common::MsgInfo&>(
      ::PTP::Common::_MsgInfo_default_instance_);
}
inline const ::PTP::Common::MsgInfo& MsgNotify::msg_info() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgNotify.msg_info)
  return _internal_msg_info();
}
inline void MsgNotify::unsafe_arena_set_allocated_msg_info(
    ::PTP::Common::MsgInfo* msg_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msg_info_);
  }
  _impl_.msg_info_ = msg_info;
  if (msg_info) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PTP.Msg.MsgNotify.msg_info)
}
inline ::PTP::Common::MsgInfo* MsgNotify::release_msg_info() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PTP::Common::MsgInfo* temp = _impl_.msg_info_;
  _impl_.msg_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PTP::Common::MsgInfo* MsgNotify::unsafe_arena_release_msg_info() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgNotify.msg_info)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::PTP::Common::MsgInfo* temp = _impl_.msg_info_;
  _impl_.msg_info_ = nullptr;
  return temp;
}
inline ::PTP::Common::MsgInfo* MsgNotify::_internal_mutable_msg_info() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.msg_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::PTP::Common::MsgInfo>(GetArenaForAllocation());
    _impl_.msg_info_ = p;
  }
  return _impl_.msg_info_;
}
inline ::PTP::Common::MsgInfo* MsgNotify::mutable_msg_info() {
  ::PTP::Common::MsgInfo* _msg = _internal_mutable_msg_info();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgNotify.msg_info)
  return _msg;
}
inline void MsgNotify::set_allocated_msg_info(::PTP::Common::MsgInfo* msg_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.msg_info_);
  }
  if (msg_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(msg_info));
    if (message_arena != submessage_arena) {
      msg_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, msg_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.msg_info_ = msg_info;
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgNotify.msg_info)
}

// repeated uint32 notify_users = 2;
inline int MsgNotify::_internal_notify_users_size() const {
  return _impl_.notify_users_.size();
}
inline int MsgNotify::notify_users_size() const {
  return _internal_notify_users_size();
}
inline void MsgNotify::clear_notify_users() {
  _impl_.notify_users_.Clear();
}
inline uint32_t MsgNotify::_internal_notify_users(int index) const {
  return _impl_.notify_users_.Get(index);
}
inline uint32_t MsgNotify::notify_users(int index) const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgNotify.notify_users)
  return _internal_notify_users(index);
}
inline void MsgNotify::set_notify_users(int index, uint32_t value) {
  _impl_.notify_users_.Set(index, value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgNotify.notify_users)
}
inline void MsgNotify::_internal_add_notify_users(uint32_t value) {
  _impl_.notify_users_.Add(value);
}
inline void MsgNotify::add_notify_users(uint32_t value) {
  _internal_add_notify_users(value);
  // @@protoc_insertion_point(field_add:PTP.Msg.MsgNotify.notify_users)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MsgNotify::_internal_notify_users() const {
  return _impl_.notify_users_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MsgNotify::notify_users() const {
  // @@protoc_insertion_point(field_list:PTP.Msg.MsgNotify.notify_users)
  return _internal_notify_users();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MsgNotify::_internal_mutable_notify_users() {
  return &_impl_.notify_users_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MsgNotify::mutable_notify_users() {
  // @@protoc_insertion_point(field_mutable_list:PTP.Msg.MsgNotify.notify_users)
  return _internal_mutable_notify_users();
}

// optional bytes attach_data = 20;
inline bool MsgNotify::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgNotify::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void MsgNotify::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgNotify::attach_data() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgNotify.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgNotify::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgNotify.attach_data)
}
inline std::string* MsgNotify::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgNotify.attach_data)
  return _s;
}
inline const std::string& MsgNotify::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void MsgNotify::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgNotify::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgNotify::release_attach_data() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgNotify.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgNotify::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgNotify.attach_data)
}

// optional uint32 auth_uid = 21;
inline bool MsgNotify::_internal_has_auth_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgNotify::has_auth_uid() const {
  return _internal_has_auth_uid();
}
inline void MsgNotify::clear_auth_uid() {
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgNotify::_internal_auth_uid() const {
  return _impl_.auth_uid_;
}
inline uint32_t MsgNotify::auth_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgNotify.auth_uid)
  return _internal_auth_uid();
}
inline void MsgNotify::_internal_set_auth_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.auth_uid_ = value;
}
inline void MsgNotify::set_auth_uid(uint32_t value) {
  _internal_set_auth_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgNotify.auth_uid)
}

// -------------------------------------------------------------------

// MsgUnNotify

// repeated uint32 un_notify_users = 1;
inline int MsgUnNotify::_internal_un_notify_users_size() const {
  return _impl_.un_notify_users_.size();
}
inline int MsgUnNotify::un_notify_users_size() const {
  return _internal_un_notify_users_size();
}
inline void MsgUnNotify::clear_un_notify_users() {
  _impl_.un_notify_users_.Clear();
}
inline uint32_t MsgUnNotify::_internal_un_notify_users(int index) const {
  return _impl_.un_notify_users_.Get(index);
}
inline uint32_t MsgUnNotify::un_notify_users(int index) const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgUnNotify.un_notify_users)
  return _internal_un_notify_users(index);
}
inline void MsgUnNotify::set_un_notify_users(int index, uint32_t value) {
  _impl_.un_notify_users_.Set(index, value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgUnNotify.un_notify_users)
}
inline void MsgUnNotify::_internal_add_un_notify_users(uint32_t value) {
  _impl_.un_notify_users_.Add(value);
}
inline void MsgUnNotify::add_un_notify_users(uint32_t value) {
  _internal_add_un_notify_users(value);
  // @@protoc_insertion_point(field_add:PTP.Msg.MsgUnNotify.un_notify_users)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MsgUnNotify::_internal_un_notify_users() const {
  return _impl_.un_notify_users_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MsgUnNotify::un_notify_users() const {
  // @@protoc_insertion_point(field_list:PTP.Msg.MsgUnNotify.un_notify_users)
  return _internal_un_notify_users();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MsgUnNotify::_internal_mutable_un_notify_users() {
  return &_impl_.un_notify_users_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MsgUnNotify::mutable_un_notify_users() {
  // @@protoc_insertion_point(field_mutable_list:PTP.Msg.MsgUnNotify.un_notify_users)
  return _internal_mutable_un_notify_users();
}

// required uint32 sent_at = 2;
inline bool MsgUnNotify::_internal_has_sent_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgUnNotify::has_sent_at() const {
  return _internal_has_sent_at();
}
inline void MsgUnNotify::clear_sent_at() {
  _impl_.sent_at_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t MsgUnNotify::_internal_sent_at() const {
  return _impl_.sent_at_;
}
inline uint32_t MsgUnNotify::sent_at() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgUnNotify.sent_at)
  return _internal_sent_at();
}
inline void MsgUnNotify::_internal_set_sent_at(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sent_at_ = value;
}
inline void MsgUnNotify::set_sent_at(uint32_t value) {
  _internal_set_sent_at(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgUnNotify.sent_at)
}

// required uint32 group_id = 3;
inline bool MsgUnNotify::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgUnNotify::has_group_id() const {
  return _internal_has_group_id();
}
inline void MsgUnNotify::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgUnNotify::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t MsgUnNotify::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgUnNotify.group_id)
  return _internal_group_id();
}
inline void MsgUnNotify::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_id_ = value;
}
inline void MsgUnNotify::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgUnNotify.group_id)
}

// required uint32 from_uid = 4;
inline bool MsgUnNotify::_internal_has_from_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgUnNotify::has_from_uid() const {
  return _internal_has_from_uid();
}
inline void MsgUnNotify::clear_from_uid() {
  _impl_.from_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgUnNotify::_internal_from_uid() const {
  return _impl_.from_uid_;
}
inline uint32_t MsgUnNotify::from_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgUnNotify.from_uid)
  return _internal_from_uid();
}
inline void MsgUnNotify::_internal_set_from_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.from_uid_ = value;
}
inline void MsgUnNotify::set_from_uid(uint32_t value) {
  _internal_set_from_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgUnNotify.from_uid)
}

// -------------------------------------------------------------------

// MsgReadAckReq

// required uint32 group_id = 1;
inline bool MsgReadAckReq::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgReadAckReq::has_group_id() const {
  return _internal_has_group_id();
}
inline void MsgReadAckReq::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgReadAckReq::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t MsgReadAckReq::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReadAckReq.group_id)
  return _internal_group_id();
}
inline void MsgReadAckReq::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_id_ = value;
}
inline void MsgReadAckReq::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReadAckReq.group_id)
}

// required uint32 msg_id = 3;
inline bool MsgReadAckReq::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgReadAckReq::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgReadAckReq::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgReadAckReq::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgReadAckReq::msg_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReadAckReq.msg_id)
  return _internal_msg_id();
}
inline void MsgReadAckReq::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msg_id_ = value;
}
inline void MsgReadAckReq::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReadAckReq.msg_id)
}

// optional bytes attach_data = 20;
inline bool MsgReadAckReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgReadAckReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void MsgReadAckReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgReadAckReq::attach_data() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReadAckReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgReadAckReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReadAckReq.attach_data)
}
inline std::string* MsgReadAckReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgReadAckReq.attach_data)
  return _s;
}
inline const std::string& MsgReadAckReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void MsgReadAckReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgReadAckReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgReadAckReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgReadAckReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgReadAckReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgReadAckReq.attach_data)
}

// optional uint32 auth_uid = 21;
inline bool MsgReadAckReq::_internal_has_auth_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgReadAckReq::has_auth_uid() const {
  return _internal_has_auth_uid();
}
inline void MsgReadAckReq::clear_auth_uid() {
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MsgReadAckReq::_internal_auth_uid() const {
  return _impl_.auth_uid_;
}
inline uint32_t MsgReadAckReq::auth_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReadAckReq.auth_uid)
  return _internal_auth_uid();
}
inline void MsgReadAckReq::_internal_set_auth_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.auth_uid_ = value;
}
inline void MsgReadAckReq::set_auth_uid(uint32_t value) {
  _internal_set_auth_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReadAckReq.auth_uid)
}

// -------------------------------------------------------------------

// MsgReadNotify

// required uint32 group_id = 1;
inline bool MsgReadNotify::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgReadNotify::has_group_id() const {
  return _internal_has_group_id();
}
inline void MsgReadNotify::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgReadNotify::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t MsgReadNotify::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReadNotify.group_id)
  return _internal_group_id();
}
inline void MsgReadNotify::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_id_ = value;
}
inline void MsgReadNotify::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReadNotify.group_id)
}

// required uint32 from_uid = 2;
inline bool MsgReadNotify::_internal_has_from_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgReadNotify::has_from_uid() const {
  return _internal_has_from_uid();
}
inline void MsgReadNotify::clear_from_uid() {
  _impl_.from_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgReadNotify::_internal_from_uid() const {
  return _impl_.from_uid_;
}
inline uint32_t MsgReadNotify::from_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReadNotify.from_uid)
  return _internal_from_uid();
}
inline void MsgReadNotify::_internal_set_from_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.from_uid_ = value;
}
inline void MsgReadNotify::set_from_uid(uint32_t value) {
  _internal_set_from_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReadNotify.from_uid)
}

// repeated uint32 notify_users = 3;
inline int MsgReadNotify::_internal_notify_users_size() const {
  return _impl_.notify_users_.size();
}
inline int MsgReadNotify::notify_users_size() const {
  return _internal_notify_users_size();
}
inline void MsgReadNotify::clear_notify_users() {
  _impl_.notify_users_.Clear();
}
inline uint32_t MsgReadNotify::_internal_notify_users(int index) const {
  return _impl_.notify_users_.Get(index);
}
inline uint32_t MsgReadNotify::notify_users(int index) const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReadNotify.notify_users)
  return _internal_notify_users(index);
}
inline void MsgReadNotify::set_notify_users(int index, uint32_t value) {
  _impl_.notify_users_.Set(index, value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReadNotify.notify_users)
}
inline void MsgReadNotify::_internal_add_notify_users(uint32_t value) {
  _impl_.notify_users_.Add(value);
}
inline void MsgReadNotify::add_notify_users(uint32_t value) {
  _internal_add_notify_users(value);
  // @@protoc_insertion_point(field_add:PTP.Msg.MsgReadNotify.notify_users)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MsgReadNotify::_internal_notify_users() const {
  return _impl_.notify_users_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MsgReadNotify::notify_users() const {
  // @@protoc_insertion_point(field_list:PTP.Msg.MsgReadNotify.notify_users)
  return _internal_notify_users();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MsgReadNotify::_internal_mutable_notify_users() {
  return &_impl_.notify_users_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MsgReadNotify::mutable_notify_users() {
  // @@protoc_insertion_point(field_mutable_list:PTP.Msg.MsgReadNotify.notify_users)
  return _internal_mutable_notify_users();
}

// required uint32 msg_id = 4;
inline bool MsgReadNotify::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgReadNotify::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgReadNotify::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MsgReadNotify::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgReadNotify::msg_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReadNotify.msg_id)
  return _internal_msg_id();
}
inline void MsgReadNotify::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.msg_id_ = value;
}
inline void MsgReadNotify::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReadNotify.msg_id)
}

// optional bytes attach_data = 20;
inline bool MsgReadNotify::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgReadNotify::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void MsgReadNotify::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgReadNotify::attach_data() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReadNotify.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgReadNotify::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReadNotify.attach_data)
}
inline std::string* MsgReadNotify::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgReadNotify.attach_data)
  return _s;
}
inline const std::string& MsgReadNotify::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void MsgReadNotify::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgReadNotify::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgReadNotify::release_attach_data() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgReadNotify.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgReadNotify::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgReadNotify.attach_data)
}

// optional uint32 auth_uid = 21;
inline bool MsgReadNotify::_internal_has_auth_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MsgReadNotify::has_auth_uid() const {
  return _internal_has_auth_uid();
}
inline void MsgReadNotify::clear_auth_uid() {
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MsgReadNotify::_internal_auth_uid() const {
  return _impl_.auth_uid_;
}
inline uint32_t MsgReadNotify::auth_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgReadNotify.auth_uid)
  return _internal_auth_uid();
}
inline void MsgReadNotify::_internal_set_auth_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.auth_uid_ = value;
}
inline void MsgReadNotify::set_auth_uid(uint32_t value) {
  _internal_set_auth_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgReadNotify.auth_uid)
}

// -------------------------------------------------------------------

// MsgGetMaxIdReq

// required uint32 group_id = 1;
inline bool MsgGetMaxIdReq::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgGetMaxIdReq::has_group_id() const {
  return _internal_has_group_id();
}
inline void MsgGetMaxIdReq::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgGetMaxIdReq::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t MsgGetMaxIdReq::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetMaxIdReq.group_id)
  return _internal_group_id();
}
inline void MsgGetMaxIdReq::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_id_ = value;
}
inline void MsgGetMaxIdReq::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetMaxIdReq.group_id)
}

// optional bytes attach_data = 20;
inline bool MsgGetMaxIdReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgGetMaxIdReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void MsgGetMaxIdReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgGetMaxIdReq::attach_data() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetMaxIdReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgGetMaxIdReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetMaxIdReq.attach_data)
}
inline std::string* MsgGetMaxIdReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgGetMaxIdReq.attach_data)
  return _s;
}
inline const std::string& MsgGetMaxIdReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void MsgGetMaxIdReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgGetMaxIdReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgGetMaxIdReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgGetMaxIdReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgGetMaxIdReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgGetMaxIdReq.attach_data)
}

// optional uint32 auth_uid = 21;
inline bool MsgGetMaxIdReq::_internal_has_auth_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgGetMaxIdReq::has_auth_uid() const {
  return _internal_has_auth_uid();
}
inline void MsgGetMaxIdReq::clear_auth_uid() {
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgGetMaxIdReq::_internal_auth_uid() const {
  return _impl_.auth_uid_;
}
inline uint32_t MsgGetMaxIdReq::auth_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetMaxIdReq.auth_uid)
  return _internal_auth_uid();
}
inline void MsgGetMaxIdReq::_internal_set_auth_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.auth_uid_ = value;
}
inline void MsgGetMaxIdReq::set_auth_uid(uint32_t value) {
  _internal_set_auth_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetMaxIdReq.auth_uid)
}

// -------------------------------------------------------------------

// MsgGetMaxIdRes

// required uint32 group_id = 1;
inline bool MsgGetMaxIdRes::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgGetMaxIdRes::has_group_id() const {
  return _internal_has_group_id();
}
inline void MsgGetMaxIdRes::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgGetMaxIdRes::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t MsgGetMaxIdRes::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetMaxIdRes.group_id)
  return _internal_group_id();
}
inline void MsgGetMaxIdRes::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_id_ = value;
}
inline void MsgGetMaxIdRes::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetMaxIdRes.group_id)
}

// required uint32 msg_id = 2;
inline bool MsgGetMaxIdRes::_internal_has_msg_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgGetMaxIdRes::has_msg_id() const {
  return _internal_has_msg_id();
}
inline void MsgGetMaxIdRes::clear_msg_id() {
  _impl_.msg_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgGetMaxIdRes::_internal_msg_id() const {
  return _impl_.msg_id_;
}
inline uint32_t MsgGetMaxIdRes::msg_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetMaxIdRes.msg_id)
  return _internal_msg_id();
}
inline void MsgGetMaxIdRes::_internal_set_msg_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msg_id_ = value;
}
inline void MsgGetMaxIdRes::set_msg_id(uint32_t value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetMaxIdRes.msg_id)
}

// optional .PTP.Common.ERR error = 3;
inline bool MsgGetMaxIdRes::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgGetMaxIdRes::has_error() const {
  return _internal_has_error();
}
inline void MsgGetMaxIdRes::clear_error() {
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::PTP::Common::ERR MsgGetMaxIdRes::_internal_error() const {
  return static_cast< ::PTP::Common::ERR >(_impl_.error_);
}
inline ::PTP::Common::ERR MsgGetMaxIdRes::error() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetMaxIdRes.error)
  return _internal_error();
}
inline void MsgGetMaxIdRes::_internal_set_error(::PTP::Common::ERR value) {
  assert(::PTP::Common::ERR_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.error_ = value;
}
inline void MsgGetMaxIdRes::set_error(::PTP::Common::ERR value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetMaxIdRes.error)
}

// optional bytes attach_data = 20;
inline bool MsgGetMaxIdRes::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgGetMaxIdRes::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void MsgGetMaxIdRes::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgGetMaxIdRes::attach_data() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetMaxIdRes.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgGetMaxIdRes::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetMaxIdRes.attach_data)
}
inline std::string* MsgGetMaxIdRes::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgGetMaxIdRes.attach_data)
  return _s;
}
inline const std::string& MsgGetMaxIdRes::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void MsgGetMaxIdRes::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgGetMaxIdRes::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgGetMaxIdRes::release_attach_data() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgGetMaxIdRes.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgGetMaxIdRes::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgGetMaxIdRes.attach_data)
}

// optional uint32 auth_uid = 21;
inline bool MsgGetMaxIdRes::_internal_has_auth_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MsgGetMaxIdRes::has_auth_uid() const {
  return _internal_has_auth_uid();
}
inline void MsgGetMaxIdRes::clear_auth_uid() {
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t MsgGetMaxIdRes::_internal_auth_uid() const {
  return _impl_.auth_uid_;
}
inline uint32_t MsgGetMaxIdRes::auth_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetMaxIdRes.auth_uid)
  return _internal_auth_uid();
}
inline void MsgGetMaxIdRes::_internal_set_auth_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.auth_uid_ = value;
}
inline void MsgGetMaxIdRes::set_auth_uid(uint32_t value) {
  _internal_set_auth_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetMaxIdRes.auth_uid)
}

// -------------------------------------------------------------------

// MsgGetByIdsReq

// required uint32 group_id = 1;
inline bool MsgGetByIdsReq::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgGetByIdsReq::has_group_id() const {
  return _internal_has_group_id();
}
inline void MsgGetByIdsReq::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgGetByIdsReq::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t MsgGetByIdsReq::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetByIdsReq.group_id)
  return _internal_group_id();
}
inline void MsgGetByIdsReq::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_id_ = value;
}
inline void MsgGetByIdsReq::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetByIdsReq.group_id)
}

// repeated uint32 msg_ids = 2;
inline int MsgGetByIdsReq::_internal_msg_ids_size() const {
  return _impl_.msg_ids_.size();
}
inline int MsgGetByIdsReq::msg_ids_size() const {
  return _internal_msg_ids_size();
}
inline void MsgGetByIdsReq::clear_msg_ids() {
  _impl_.msg_ids_.Clear();
}
inline uint32_t MsgGetByIdsReq::_internal_msg_ids(int index) const {
  return _impl_.msg_ids_.Get(index);
}
inline uint32_t MsgGetByIdsReq::msg_ids(int index) const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetByIdsReq.msg_ids)
  return _internal_msg_ids(index);
}
inline void MsgGetByIdsReq::set_msg_ids(int index, uint32_t value) {
  _impl_.msg_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetByIdsReq.msg_ids)
}
inline void MsgGetByIdsReq::_internal_add_msg_ids(uint32_t value) {
  _impl_.msg_ids_.Add(value);
}
inline void MsgGetByIdsReq::add_msg_ids(uint32_t value) {
  _internal_add_msg_ids(value);
  // @@protoc_insertion_point(field_add:PTP.Msg.MsgGetByIdsReq.msg_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MsgGetByIdsReq::_internal_msg_ids() const {
  return _impl_.msg_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MsgGetByIdsReq::msg_ids() const {
  // @@protoc_insertion_point(field_list:PTP.Msg.MsgGetByIdsReq.msg_ids)
  return _internal_msg_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MsgGetByIdsReq::_internal_mutable_msg_ids() {
  return &_impl_.msg_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MsgGetByIdsReq::mutable_msg_ids() {
  // @@protoc_insertion_point(field_mutable_list:PTP.Msg.MsgGetByIdsReq.msg_ids)
  return _internal_mutable_msg_ids();
}

// optional bytes attach_data = 20;
inline bool MsgGetByIdsReq::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgGetByIdsReq::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void MsgGetByIdsReq::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgGetByIdsReq::attach_data() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetByIdsReq.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgGetByIdsReq::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetByIdsReq.attach_data)
}
inline std::string* MsgGetByIdsReq::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgGetByIdsReq.attach_data)
  return _s;
}
inline const std::string& MsgGetByIdsReq::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void MsgGetByIdsReq::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgGetByIdsReq::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgGetByIdsReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgGetByIdsReq.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgGetByIdsReq::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgGetByIdsReq.attach_data)
}

// optional uint32 auth_uid = 21;
inline bool MsgGetByIdsReq::_internal_has_auth_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgGetByIdsReq::has_auth_uid() const {
  return _internal_has_auth_uid();
}
inline void MsgGetByIdsReq::clear_auth_uid() {
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t MsgGetByIdsReq::_internal_auth_uid() const {
  return _impl_.auth_uid_;
}
inline uint32_t MsgGetByIdsReq::auth_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetByIdsReq.auth_uid)
  return _internal_auth_uid();
}
inline void MsgGetByIdsReq::_internal_set_auth_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.auth_uid_ = value;
}
inline void MsgGetByIdsReq::set_auth_uid(uint32_t value) {
  _internal_set_auth_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetByIdsReq.auth_uid)
}

// -------------------------------------------------------------------

// MsgGetByIdsRes

// optional uint32 group_id = 1;
inline bool MsgGetByIdsRes::_internal_has_group_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MsgGetByIdsRes::has_group_id() const {
  return _internal_has_group_id();
}
inline void MsgGetByIdsRes::clear_group_id() {
  _impl_.group_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t MsgGetByIdsRes::_internal_group_id() const {
  return _impl_.group_id_;
}
inline uint32_t MsgGetByIdsRes::group_id() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetByIdsRes.group_id)
  return _internal_group_id();
}
inline void MsgGetByIdsRes::_internal_set_group_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.group_id_ = value;
}
inline void MsgGetByIdsRes::set_group_id(uint32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetByIdsRes.group_id)
}

// repeated .PTP.Common.MsgInfo msg_list = 2;
inline int MsgGetByIdsRes::_internal_msg_list_size() const {
  return _impl_.msg_list_.size();
}
inline int MsgGetByIdsRes::msg_list_size() const {
  return _internal_msg_list_size();
}
inline ::PTP::Common::MsgInfo* MsgGetByIdsRes::mutable_msg_list(int index) {
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgGetByIdsRes.msg_list)
  return _impl_.msg_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PTP::Common::MsgInfo >*
MsgGetByIdsRes::mutable_msg_list() {
  // @@protoc_insertion_point(field_mutable_list:PTP.Msg.MsgGetByIdsRes.msg_list)
  return &_impl_.msg_list_;
}
inline const ::PTP::Common::MsgInfo& MsgGetByIdsRes::_internal_msg_list(int index) const {
  return _impl_.msg_list_.Get(index);
}
inline const ::PTP::Common::MsgInfo& MsgGetByIdsRes::msg_list(int index) const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetByIdsRes.msg_list)
  return _internal_msg_list(index);
}
inline ::PTP::Common::MsgInfo* MsgGetByIdsRes::_internal_add_msg_list() {
  return _impl_.msg_list_.Add();
}
inline ::PTP::Common::MsgInfo* MsgGetByIdsRes::add_msg_list() {
  ::PTP::Common::MsgInfo* _add = _internal_add_msg_list();
  // @@protoc_insertion_point(field_add:PTP.Msg.MsgGetByIdsRes.msg_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PTP::Common::MsgInfo >&
MsgGetByIdsRes::msg_list() const {
  // @@protoc_insertion_point(field_list:PTP.Msg.MsgGetByIdsRes.msg_list)
  return _impl_.msg_list_;
}

// optional .PTP.Common.ERR error = 3;
inline bool MsgGetByIdsRes::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MsgGetByIdsRes::has_error() const {
  return _internal_has_error();
}
inline void MsgGetByIdsRes::clear_error() {
  _impl_.error_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::PTP::Common::ERR MsgGetByIdsRes::_internal_error() const {
  return static_cast< ::PTP::Common::ERR >(_impl_.error_);
}
inline ::PTP::Common::ERR MsgGetByIdsRes::error() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetByIdsRes.error)
  return _internal_error();
}
inline void MsgGetByIdsRes::_internal_set_error(::PTP::Common::ERR value) {
  assert(::PTP::Common::ERR_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.error_ = value;
}
inline void MsgGetByIdsRes::set_error(::PTP::Common::ERR value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetByIdsRes.error)
}

// optional bytes attach_data = 20;
inline bool MsgGetByIdsRes::_internal_has_attach_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MsgGetByIdsRes::has_attach_data() const {
  return _internal_has_attach_data();
}
inline void MsgGetByIdsRes::clear_attach_data() {
  _impl_.attach_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MsgGetByIdsRes::attach_data() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetByIdsRes.attach_data)
  return _internal_attach_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgGetByIdsRes::set_attach_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attach_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetByIdsRes.attach_data)
}
inline std::string* MsgGetByIdsRes::mutable_attach_data() {
  std::string* _s = _internal_mutable_attach_data();
  // @@protoc_insertion_point(field_mutable:PTP.Msg.MsgGetByIdsRes.attach_data)
  return _s;
}
inline const std::string& MsgGetByIdsRes::_internal_attach_data() const {
  return _impl_.attach_data_.Get();
}
inline void MsgGetByIdsRes::_internal_set_attach_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attach_data_.Set(value, GetArenaForAllocation());
}
inline std::string* MsgGetByIdsRes::_internal_mutable_attach_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attach_data_.Mutable(GetArenaForAllocation());
}
inline std::string* MsgGetByIdsRes::release_attach_data() {
  // @@protoc_insertion_point(field_release:PTP.Msg.MsgGetByIdsRes.attach_data)
  if (!_internal_has_attach_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attach_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MsgGetByIdsRes::set_allocated_attach_data(std::string* attach_data) {
  if (attach_data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attach_data_.SetAllocated(attach_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attach_data_.IsDefault()) {
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PTP.Msg.MsgGetByIdsRes.attach_data)
}

// optional uint32 auth_uid = 21;
inline bool MsgGetByIdsRes::_internal_has_auth_uid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MsgGetByIdsRes::has_auth_uid() const {
  return _internal_has_auth_uid();
}
inline void MsgGetByIdsRes::clear_auth_uid() {
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t MsgGetByIdsRes::_internal_auth_uid() const {
  return _impl_.auth_uid_;
}
inline uint32_t MsgGetByIdsRes::auth_uid() const {
  // @@protoc_insertion_point(field_get:PTP.Msg.MsgGetByIdsRes.auth_uid)
  return _internal_auth_uid();
}
inline void MsgGetByIdsRes::_internal_set_auth_uid(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.auth_uid_ = value;
}
inline void MsgGetByIdsRes::set_auth_uid(uint32_t value) {
  _internal_set_auth_uid(value);
  // @@protoc_insertion_point(field_set:PTP.Msg.MsgGetByIdsRes.auth_uid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Msg
}  // namespace PTP

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_PTP_2eMsg_2eproto
