// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PTP.Group.proto

#include "PTP.Group.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace PTP {
namespace Group {
PROTOBUF_CONSTEXPR GroupPreCreateReq::GroupPreCreateReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.auth_uid_)*/0u
  , /*decltype(_impl_.group_type_)*/1} {}
struct GroupPreCreateReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupPreCreateReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupPreCreateReqDefaultTypeInternal() {}
  union {
    GroupPreCreateReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupPreCreateReqDefaultTypeInternal _GroupPreCreateReq_default_instance_;
PROTOBUF_CONSTEXPR GroupPreCreateRes::GroupPreCreateRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_adr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.captcha_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_idx_)*/0u
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct GroupPreCreateResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupPreCreateResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupPreCreateResDefaultTypeInternal() {}
  union {
    GroupPreCreateRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupPreCreateResDefaultTypeInternal _GroupPreCreateRes_default_instance_;
PROTOBUF_CONSTEXPR GroupCreateReq::GroupCreateReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.sign_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.captcha_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.avatar_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.about_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_idx_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u
  , /*decltype(_impl_.group_type_)*/1} {}
struct GroupCreateReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupCreateReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupCreateReqDefaultTypeInternal() {}
  union {
    GroupCreateReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupCreateReqDefaultTypeInternal _GroupCreateReq_default_instance_;
PROTOBUF_CONSTEXPR GroupCreateRes::GroupCreateRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_members_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_)*/nullptr
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct GroupCreateResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupCreateResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupCreateResDefaultTypeInternal() {}
  union {
    GroupCreateRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupCreateResDefaultTypeInternal _GroupCreateRes_default_instance_;
PROTOBUF_CONSTEXPR GroupModifyReq::GroupModifyReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u
  , /*decltype(_impl_.group_modify_action_)*/1} {}
struct GroupModifyReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupModifyReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupModifyReqDefaultTypeInternal() {}
  union {
    GroupModifyReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupModifyReqDefaultTypeInternal _GroupModifyReq_default_instance_;
PROTOBUF_CONSTEXPR GroupModifyRes::GroupModifyRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.notify_members_)*/{}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.auth_uid_)*/0u
  , /*decltype(_impl_.group_modify_action_)*/1} {}
struct GroupModifyResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupModifyResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupModifyResDefaultTypeInternal() {}
  union {
    GroupModifyRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupModifyResDefaultTypeInternal _GroupModifyRes_default_instance_;
PROTOBUF_CONSTEXPR GroupModifyNotify::GroupModifyNotify(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.group_modify_action_)*/1} {}
struct GroupModifyNotifyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupModifyNotifyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupModifyNotifyDefaultTypeInternal() {}
  union {
    GroupModifyNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupModifyNotifyDefaultTypeInternal _GroupModifyNotify_default_instance_;
PROTOBUF_CONSTEXPR GroupChangeMemberReq::GroupChangeMemberReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u
  , /*decltype(_impl_.group_member_modify_action_)*/1} {}
struct GroupChangeMemberReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupChangeMemberReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupChangeMemberReqDefaultTypeInternal() {}
  union {
    GroupChangeMemberReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupChangeMemberReqDefaultTypeInternal _GroupChangeMemberReq_default_instance_;
PROTOBUF_CONSTEXPR GroupChangeMemberRes::GroupChangeMemberRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_chang_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.auth_uid_)*/0u
  , /*decltype(_impl_.group_member_modify_action_)*/1} {}
struct GroupChangeMemberResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupChangeMemberResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupChangeMemberResDefaultTypeInternal() {}
  union {
    GroupChangeMemberRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupChangeMemberResDefaultTypeInternal _GroupChangeMemberRes_default_instance_;
PROTOBUF_CONSTEXPR GroupChangeMemberNotify::GroupChangeMemberNotify(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_chang_)*/{}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.group_member_modify_action_)*/1} {}
struct GroupChangeMemberNotifyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupChangeMemberNotifyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupChangeMemberNotifyDefaultTypeInternal() {}
  union {
    GroupChangeMemberNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupChangeMemberNotifyDefaultTypeInternal _GroupChangeMemberNotify_default_instance_;
PROTOBUF_CONSTEXPR GroupGetListReq::GroupGetListReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_info_updated_time_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct GroupGetListReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupGetListReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupGetListReqDefaultTypeInternal() {}
  union {
    GroupGetListReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupGetListReqDefaultTypeInternal _GroupGetListReq_default_instance_;
PROTOBUF_CONSTEXPR GroupGetListRes::GroupGetListRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.groups_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_info_updated_time_)*/0u
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct GroupGetListResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupGetListResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupGetListResDefaultTypeInternal() {}
  union {
    GroupGetListRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupGetListResDefaultTypeInternal _GroupGetListRes_default_instance_;
PROTOBUF_CONSTEXPR GroupGetMembersListReq::GroupGetMembersListReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_members_updated_time_)*/0u
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct GroupGetMembersListReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupGetMembersListReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupGetMembersListReqDefaultTypeInternal() {}
  union {
    GroupGetMembersListReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupGetMembersListReqDefaultTypeInternal _GroupGetMembersListReq_default_instance_;
PROTOBUF_CONSTEXPR GroupGetMembersListRes::GroupGetMembersListRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.members_)*/{}
  , /*decltype(_impl_.group_members_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_members_updated_time_)*/0u
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct GroupGetMembersListResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupGetMembersListResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupGetMembersListResDefaultTypeInternal() {}
  union {
    GroupGetMembersListRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupGetMembersListResDefaultTypeInternal _GroupGetMembersListRes_default_instance_;
PROTOBUF_CONSTEXPR GroupUnreadMsgReq::GroupUnreadMsgReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct GroupUnreadMsgReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupUnreadMsgReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupUnreadMsgReqDefaultTypeInternal() {}
  union {
    GroupUnreadMsgReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupUnreadMsgReqDefaultTypeInternal _GroupUnreadMsgReq_default_instance_;
PROTOBUF_CONSTEXPR GroupUnreadMsgRes::GroupUnreadMsgRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.unread_list_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.unread_cnt_)*/0u
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct GroupUnreadMsgResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupUnreadMsgResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupUnreadMsgResDefaultTypeInternal() {}
  union {
    GroupUnreadMsgRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupUnreadMsgResDefaultTypeInternal _GroupUnreadMsgRes_default_instance_;
PROTOBUF_CONSTEXPR GroupRemoveSessionReq::GroupRemoveSessionReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct GroupRemoveSessionReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupRemoveSessionReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupRemoveSessionReqDefaultTypeInternal() {}
  union {
    GroupRemoveSessionReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupRemoveSessionReqDefaultTypeInternal _GroupRemoveSessionReq_default_instance_;
PROTOBUF_CONSTEXPR GroupRemoveSessionRes::GroupRemoveSessionRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct GroupRemoveSessionResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupRemoveSessionResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupRemoveSessionResDefaultTypeInternal() {}
  union {
    GroupRemoveSessionRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupRemoveSessionResDefaultTypeInternal _GroupRemoveSessionRes_default_instance_;
PROTOBUF_CONSTEXPR GroupRemoveSessionNotify::GroupRemoveSessionNotify(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.from_uid_)*/0u} {}
struct GroupRemoveSessionNotifyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupRemoveSessionNotifyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupRemoveSessionNotifyDefaultTypeInternal() {}
  union {
    GroupRemoveSessionNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupRemoveSessionNotifyDefaultTypeInternal _GroupRemoveSessionNotify_default_instance_;
}  // namespace Group
}  // namespace PTP
namespace PTP {
namespace Group {

// ===================================================================

class GroupPreCreateReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupPreCreateReq>()._impl_._has_bits_);
  static void set_has_group_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

GroupPreCreateReq::GroupPreCreateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupPreCreateReq)
}
GroupPreCreateReq::GroupPreCreateReq(const GroupPreCreateReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupPreCreateReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.auth_uid_){}
    , decltype(_impl_.group_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.auth_uid_, &from._impl_.auth_uid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.group_type_) -
    reinterpret_cast<char*>(&_impl_.auth_uid_)) + sizeof(_impl_.group_type_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupPreCreateReq)
}

inline void GroupPreCreateReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.auth_uid_){0u}
    , decltype(_impl_.group_type_){1}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupPreCreateReq::~GroupPreCreateReq() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupPreCreateReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupPreCreateReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.members_.~RepeatedField();
  _impl_.attach_data_.Destroy();
}

void GroupPreCreateReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupPreCreateReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupPreCreateReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.members_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    _impl_.auth_uid_ = 0u;
    _impl_.group_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupPreCreateReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PTP.Common.GroupType group_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupType_IsValid(val))) {
            _internal_set_group_type(static_cast<::PTP::Common::GroupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 members = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_members(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_members(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupPreCreateReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupPreCreateReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .PTP.Common.GroupType group_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_group_type(), target);
  }

  // repeated uint32 members = 7;
  for (int i = 0, n = this->_internal_members_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_members(i), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupPreCreateReq)
  return target;
}

size_t GroupPreCreateReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupPreCreateReq)
  size_t total_size = 0;

  // required .PTP.Common.GroupType group_type = 1;
  if (_internal_has_group_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 members = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.members_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_members_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes attach_data = 20;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_attach_data());
    }

    // optional uint32 auth_uid = 21;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_auth_uid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupPreCreateReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupPreCreateReq*>(
      &from));
}

void GroupPreCreateReq::MergeFrom(const GroupPreCreateReq& from) {
  GroupPreCreateReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupPreCreateReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.members_.MergeFrom(from._impl_.members_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.group_type_ = from._impl_.group_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupPreCreateReq::CopyFrom(const GroupPreCreateReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupPreCreateReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPreCreateReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupPreCreateReq::InternalSwap(GroupPreCreateReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.members_.InternalSwap(&other->_impl_.members_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  swap(_impl_.auth_uid_, other->_impl_.auth_uid_);
  swap(_impl_.group_type_, other->_impl_.group_type_);
}

std::string GroupPreCreateReq::GetTypeName() const {
  return "PTP.Group.GroupPreCreateReq";
}


// ===================================================================

class GroupPreCreateRes::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupPreCreateRes>()._impl_._has_bits_);
  static void set_has_group_adr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_captcha(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000018) ^ 0x00000018) != 0;
  }
};

GroupPreCreateRes::GroupPreCreateRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupPreCreateRes)
}
GroupPreCreateRes::GroupPreCreateRes(const GroupPreCreateRes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupPreCreateRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_adr_){}
    , decltype(_impl_.captcha_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_idx_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.group_adr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_adr()) {
    _this->_impl_.group_adr_.Set(from._internal_group_adr(), 
      _this->GetArenaForAllocation());
  }
  _impl_.captcha_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.captcha_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_captcha()) {
    _this->_impl_.captcha_.Set(from._internal_captcha(), 
      _this->GetArenaForAllocation());
  }
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_idx_, &from._impl_.group_idx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_idx_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupPreCreateRes)
}

inline void GroupPreCreateRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_adr_){}
    , decltype(_impl_.captcha_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_idx_){0u}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.group_adr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.captcha_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.captcha_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupPreCreateRes::~GroupPreCreateRes() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupPreCreateRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupPreCreateRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.group_adr_.Destroy();
  _impl_.captcha_.Destroy();
  _impl_.attach_data_.Destroy();
}

void GroupPreCreateRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupPreCreateRes::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupPreCreateRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.group_adr_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.captcha_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.attach_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.group_idx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_idx_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupPreCreateRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string group_adr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_group_adr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_idx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_idx(&has_bits);
          _impl_.group_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.ERR error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ERR_IsValid(val))) {
            _internal_set_error(static_cast<::PTP::Common::ERR>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string captcha = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_captcha();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupPreCreateRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupPreCreateRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string group_adr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_group_adr(), target);
  }

  // required uint32 group_idx = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_idx(), target);
  }

  // required .PTP.Common.ERR error = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_error(), target);
  }

  // optional string captcha = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_captcha(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupPreCreateRes)
  return target;
}

size_t GroupPreCreateRes::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupPreCreateRes)
  size_t total_size = 0;

  if (_internal_has_group_idx()) {
    // required uint32 group_idx = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_idx());
  }

  if (_internal_has_error()) {
    // required .PTP.Common.ERR error = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }

  return total_size;
}
size_t GroupPreCreateRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupPreCreateRes)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000018) ^ 0x00000018) == 0) {  // All required fields are present.
    // required uint32 group_idx = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_idx());

    // required .PTP.Common.ERR error = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string group_adr = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_group_adr());
    }

    // optional string captcha = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_captcha());
    }

    // optional bytes attach_data = 20;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_attach_data());
    }

  }
  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000020u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupPreCreateRes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupPreCreateRes*>(
      &from));
}

void GroupPreCreateRes::MergeFrom(const GroupPreCreateRes& from) {
  GroupPreCreateRes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupPreCreateRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_group_adr(from._internal_group_adr());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_captcha(from._internal_captcha());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.group_idx_ = from._impl_.group_idx_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupPreCreateRes::CopyFrom(const GroupPreCreateRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupPreCreateRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupPreCreateRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupPreCreateRes::InternalSwap(GroupPreCreateRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.group_adr_, lhs_arena,
      &other->_impl_.group_adr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.captcha_, lhs_arena,
      &other->_impl_.captcha_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupPreCreateRes, _impl_.auth_uid_)
      + sizeof(GroupPreCreateRes::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupPreCreateRes, _impl_.group_idx_)>(
          reinterpret_cast<char*>(&_impl_.group_idx_),
          reinterpret_cast<char*>(&other->_impl_.group_idx_));
}

std::string GroupPreCreateRes::GetTypeName() const {
  return "PTP.Group.GroupPreCreateRes";
}


// ===================================================================

class GroupCreateReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupCreateReq>()._impl_._has_bits_);
  static void set_has_group_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_captcha(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_avatar(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_about(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000143) ^ 0x00000143) != 0;
  }
};

GroupCreateReq::GroupCreateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupCreateReq)
}
GroupCreateReq::GroupCreateReq(const GroupCreateReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupCreateReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.sign_){}
    , decltype(_impl_.captcha_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.avatar_){}
    , decltype(_impl_.about_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_idx_){}
    , decltype(_impl_.auth_uid_){}
    , decltype(_impl_.group_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.sign_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sign_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sign()) {
    _this->_impl_.sign_.Set(from._internal_sign(), 
      _this->GetArenaForAllocation());
  }
  _impl_.captcha_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.captcha_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_captcha()) {
    _this->_impl_.captcha_.Set(from._internal_captcha(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar()) {
    _this->_impl_.avatar_.Set(from._internal_avatar(), 
      _this->GetArenaForAllocation());
  }
  _impl_.about_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.about_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_about()) {
    _this->_impl_.about_.Set(from._internal_about(), 
      _this->GetArenaForAllocation());
  }
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_idx_, &from._impl_.group_idx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.group_type_) -
    reinterpret_cast<char*>(&_impl_.group_idx_)) + sizeof(_impl_.group_type_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupCreateReq)
}

inline void GroupCreateReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.sign_){}
    , decltype(_impl_.captcha_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.avatar_){}
    , decltype(_impl_.about_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_idx_){0u}
    , decltype(_impl_.auth_uid_){0u}
    , decltype(_impl_.group_type_){1}
  };
  _impl_.sign_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sign_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.captcha_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.captcha_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.about_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.about_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupCreateReq::~GroupCreateReq() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupCreateReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupCreateReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.members_.~RepeatedField();
  _impl_.sign_.Destroy();
  _impl_.captcha_.Destroy();
  _impl_.name_.Destroy();
  _impl_.avatar_.Destroy();
  _impl_.about_.Destroy();
  _impl_.attach_data_.Destroy();
}

void GroupCreateReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupCreateReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupCreateReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.members_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.sign_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.captcha_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.avatar_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.about_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.attach_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.group_idx_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_idx_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_.group_type_ = 1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupCreateReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_idx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_idx(&has_bits);
          _impl_.group_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes sign = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sign();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string captcha = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_captcha();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.GroupType group_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupType_IsValid(val))) {
            _internal_set_group_type(static_cast<::PTP::Common::GroupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string avatar = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_avatar();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 members = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_members(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_members(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string about = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_about();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupCreateReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupCreateReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_idx = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_idx(), target);
  }

  // required bytes sign = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sign(), target);
  }

  // required string captcha = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_captcha(), target);
  }

  // required .PTP.Common.GroupType group_type = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_group_type(), target);
  }

  // optional string name = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  // optional string avatar = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_avatar(), target);
  }

  // repeated uint32 members = 7;
  for (int i = 0, n = this->_internal_members_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_members(i), target);
  }

  // optional string about = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_about(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupCreateReq)
  return target;
}

size_t GroupCreateReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupCreateReq)
  size_t total_size = 0;

  if (_internal_has_sign()) {
    // required bytes sign = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sign());
  }

  if (_internal_has_captcha()) {
    // required string captcha = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_captcha());
  }

  if (_internal_has_group_idx()) {
    // required uint32 group_idx = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_idx());
  }

  if (_internal_has_group_type()) {
    // required .PTP.Common.GroupType group_type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_type());
  }

  return total_size;
}
size_t GroupCreateReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupCreateReq)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000143) ^ 0x00000143) == 0) {  // All required fields are present.
    // required bytes sign = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sign());

    // required string captcha = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_captcha());

    // required uint32 group_idx = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_idx());

    // required .PTP.Common.GroupType group_type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 members = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.members_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_members_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003cu) {
    // optional string name = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string avatar = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_avatar());
    }

    // optional string about = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_about());
    }

    // optional bytes attach_data = 20;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_attach_data());
    }

  }
  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000080u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupCreateReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupCreateReq*>(
      &from));
}

void GroupCreateReq::MergeFrom(const GroupCreateReq& from) {
  GroupCreateReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupCreateReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.members_.MergeFrom(from._impl_.members_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_sign(from._internal_sign());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_captcha(from._internal_captcha());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_avatar(from._internal_avatar());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_about(from._internal_about());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.group_idx_ = from._impl_.group_idx_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_group_type(from._internal_group_type());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupCreateReq::CopyFrom(const GroupCreateReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupCreateReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupCreateReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupCreateReq::InternalSwap(GroupCreateReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.members_.InternalSwap(&other->_impl_.members_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sign_, lhs_arena,
      &other->_impl_.sign_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.captcha_, lhs_arena,
      &other->_impl_.captcha_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.avatar_, lhs_arena,
      &other->_impl_.avatar_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.about_, lhs_arena,
      &other->_impl_.about_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupCreateReq, _impl_.auth_uid_)
      + sizeof(GroupCreateReq::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupCreateReq, _impl_.group_idx_)>(
          reinterpret_cast<char*>(&_impl_.group_idx_),
          reinterpret_cast<char*>(&other->_impl_.group_idx_));
  swap(_impl_.group_type_, other->_impl_.group_type_);
}

std::string GroupCreateReq::GetTypeName() const {
  return "PTP.Group.GroupCreateReq";
}


// ===================================================================

class GroupCreateRes::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupCreateRes>()._impl_._has_bits_);
  static const ::PTP::Common::GroupInfo& group(const GroupCreateRes* msg);
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

const ::PTP::Common::GroupInfo&
GroupCreateRes::_Internal::group(const GroupCreateRes* msg) {
  return *msg->_impl_.group_;
}
void GroupCreateRes::clear_group() {
  if (_impl_.group_ != nullptr) _impl_.group_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void GroupCreateRes::clear_group_members() {
  _impl_.group_members_.Clear();
}
GroupCreateRes::GroupCreateRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupCreateRes)
}
GroupCreateRes::GroupCreateRes(const GroupCreateRes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupCreateRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_members_){from._impl_.group_members_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_){nullptr}
    , decltype(_impl_.error_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_group()) {
    _this->_impl_.group_ = new ::PTP::Common::GroupInfo(*from._impl_.group_);
  }
  ::memcpy(&_impl_.error_, &from._impl_.error_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupCreateRes)
}

inline void GroupCreateRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_members_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_){nullptr}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupCreateRes::~GroupCreateRes() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupCreateRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupCreateRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.group_members_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
  if (this != internal_default_instance()) delete _impl_.group_;
}

void GroupCreateRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupCreateRes::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupCreateRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.group_members_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.attach_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.group_ != nullptr);
      _impl_.group_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupCreateRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .PTP.Common.GroupInfo group = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_group(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PTP.Common.GroupMember group_members = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_group_members(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.ERR error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ERR_IsValid(val))) {
            _internal_set_error(static_cast<::PTP::Common::ERR>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupCreateRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupCreateRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .PTP.Common.GroupInfo group = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::group(this),
        _Internal::group(this).GetCachedSize(), target, stream);
  }

  // repeated .PTP.Common.GroupMember group_members = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_group_members_size()); i < n; i++) {
    const auto& repfield = this->_internal_group_members(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required .PTP.Common.ERR error = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_error(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupCreateRes)
  return target;
}

size_t GroupCreateRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupCreateRes)
  size_t total_size = 0;

  // required .PTP.Common.ERR error = 3;
  if (_internal_has_error()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PTP.Common.GroupMember group_members = 2;
  total_size += 1UL * this->_internal_group_members_size();
  for (const auto& msg : this->_impl_.group_members_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes attach_data = 20;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_attach_data());
    }

    // optional .PTP.Common.GroupInfo group = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.group_);
    }

  }
  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupCreateRes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupCreateRes*>(
      &from));
}

void GroupCreateRes::MergeFrom(const GroupCreateRes& from) {
  GroupCreateRes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupCreateRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.group_members_.MergeFrom(from._impl_.group_members_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_group()->::PTP::Common::GroupInfo::MergeFrom(
          from._internal_group());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupCreateRes::CopyFrom(const GroupCreateRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupCreateRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupCreateRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.group_members_))
    return false;
  if (_internal_has_group()) {
    if (!_impl_.group_->IsInitialized()) return false;
  }
  return true;
}

void GroupCreateRes::InternalSwap(GroupCreateRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.group_members_.InternalSwap(&other->_impl_.group_members_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupCreateRes, _impl_.auth_uid_)
      + sizeof(GroupCreateRes::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupCreateRes, _impl_.group_)>(
          reinterpret_cast<char*>(&_impl_.group_),
          reinterpret_cast<char*>(&other->_impl_.group_));
}

std::string GroupCreateRes::GetTypeName() const {
  return "PTP.Group.GroupCreateRes";
}


// ===================================================================

class GroupModifyReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupModifyReq>()._impl_._has_bits_);
  static void set_has_group_modify_action(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000015) ^ 0x00000015) != 0;
  }
};

GroupModifyReq::GroupModifyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupModifyReq)
}
GroupModifyReq::GroupModifyReq(const GroupModifyReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupModifyReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.auth_uid_){}
    , decltype(_impl_.group_modify_action_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.group_modify_action_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.group_modify_action_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupModifyReq)
}

inline void GroupModifyReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.auth_uid_){0u}
    , decltype(_impl_.group_modify_action_){1}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupModifyReq::~GroupModifyReq() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupModifyReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupModifyReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
  _impl_.attach_data_.Destroy();
}

void GroupModifyReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupModifyReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupModifyReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.attach_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
    _impl_.group_modify_action_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupModifyReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PTP.Common.GroupModifyAction group_modify_action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupModifyAction_IsValid(val))) {
            _internal_set_group_modify_action(static_cast<::PTP::Common::GroupModifyAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupModifyReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupModifyReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .PTP.Common.GroupModifyAction group_modify_action = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_group_modify_action(), target);
  }

  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // required string value = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_value(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupModifyReq)
  return target;
}

size_t GroupModifyReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupModifyReq)
  size_t total_size = 0;

  if (_internal_has_value()) {
    // required string value = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_group_modify_action()) {
    // required .PTP.Common.GroupModifyAction group_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_modify_action());
  }

  return total_size;
}
size_t GroupModifyReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupModifyReq)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000015) ^ 0x00000015) == 0) {  // All required fields are present.
    // required string value = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());

    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required .PTP.Common.GroupModifyAction group_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_modify_action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupModifyReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupModifyReq*>(
      &from));
}

void GroupModifyReq::MergeFrom(const GroupModifyReq& from) {
  GroupModifyReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupModifyReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.group_modify_action_ = from._impl_.group_modify_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupModifyReq::CopyFrom(const GroupModifyReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupModifyReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupModifyReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupModifyReq::InternalSwap(GroupModifyReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupModifyReq, _impl_.auth_uid_)
      + sizeof(GroupModifyReq::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupModifyReq, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
  swap(_impl_.group_modify_action_, other->_impl_.group_modify_action_);
}

std::string GroupModifyReq::GetTypeName() const {
  return "PTP.Group.GroupModifyReq";
}


// ===================================================================

class GroupModifyRes::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupModifyRes>()._impl_._has_bits_);
  static void set_has_group_modify_action(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000002d) ^ 0x0000002d) != 0;
  }
};

GroupModifyRes::GroupModifyRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupModifyRes)
}
GroupModifyRes::GroupModifyRes(const GroupModifyRes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupModifyRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.notify_members_){from._impl_.notify_members_}
    , decltype(_impl_.value_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.auth_uid_){}
    , decltype(_impl_.group_modify_action_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.group_modify_action_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.group_modify_action_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupModifyRes)
}

inline void GroupModifyRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.notify_members_){arena}
    , decltype(_impl_.value_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.auth_uid_){0u}
    , decltype(_impl_.group_modify_action_){1}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupModifyRes::~GroupModifyRes() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupModifyRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupModifyRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.notify_members_.~RepeatedField();
  _impl_.value_.Destroy();
  _impl_.attach_data_.Destroy();
}

void GroupModifyRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupModifyRes::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupModifyRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.notify_members_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.attach_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
    _impl_.group_modify_action_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupModifyRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PTP.Common.GroupModifyAction group_modify_action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupModifyAction_IsValid(val))) {
            _internal_set_group_modify_action(static_cast<::PTP::Common::GroupModifyAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.ERR error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ERR_IsValid(val))) {
            _internal_set_error(static_cast<::PTP::Common::ERR>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 notify_members = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_notify_members(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_notify_members(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupModifyRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupModifyRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .PTP.Common.GroupModifyAction group_modify_action = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_group_modify_action(), target);
  }

  // required string value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  // required uint32 group_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_group_id(), target);
  }

  // required .PTP.Common.ERR error = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  // repeated uint32 notify_members = 5;
  for (int i = 0, n = this->_internal_notify_members_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_notify_members(i), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupModifyRes)
  return target;
}

size_t GroupModifyRes::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupModifyRes)
  size_t total_size = 0;

  if (_internal_has_value()) {
    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_error()) {
    // required .PTP.Common.ERR error = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }

  if (_internal_has_group_modify_action()) {
    // required .PTP.Common.GroupModifyAction group_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_modify_action());
  }

  return total_size;
}
size_t GroupModifyRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupModifyRes)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000002d) ^ 0x0000002d) == 0) {  // All required fields are present.
    // required string value = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());

    // required uint32 group_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required .PTP.Common.ERR error = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());

    // required .PTP.Common.GroupModifyAction group_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_modify_action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 notify_members = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.notify_members_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_notify_members_size());
    total_size += data_size;
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000010u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupModifyRes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupModifyRes*>(
      &from));
}

void GroupModifyRes::MergeFrom(const GroupModifyRes& from) {
  GroupModifyRes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupModifyRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.notify_members_.MergeFrom(from._impl_.notify_members_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.group_modify_action_ = from._impl_.group_modify_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupModifyRes::CopyFrom(const GroupModifyRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupModifyRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupModifyRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupModifyRes::InternalSwap(GroupModifyRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.notify_members_.InternalSwap(&other->_impl_.notify_members_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupModifyRes, _impl_.auth_uid_)
      + sizeof(GroupModifyRes::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupModifyRes, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
  swap(_impl_.group_modify_action_, other->_impl_.group_modify_action_);
}

std::string GroupModifyRes::GetTypeName() const {
  return "PTP.Group.GroupModifyRes";
}


// ===================================================================

class GroupModifyNotify::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupModifyNotify>()._impl_._has_bits_);
  static void set_has_group_modify_action(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

GroupModifyNotify::GroupModifyNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupModifyNotify)
}
GroupModifyNotify::GroupModifyNotify(const GroupModifyNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupModifyNotify* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.group_modify_action_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.group_modify_action_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.group_modify_action_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupModifyNotify)
}

inline void GroupModifyNotify::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.value_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.group_modify_action_){1}
  };
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupModifyNotify::~GroupModifyNotify() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupModifyNotify)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupModifyNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.value_.Destroy();
}

void GroupModifyNotify::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupModifyNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupModifyNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.value_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    _impl_.group_id_ = 0u;
    _impl_.group_modify_action_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupModifyNotify::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PTP.Common.GroupModifyAction group_modify_action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupModifyAction_IsValid(val))) {
            _internal_set_group_modify_action(static_cast<::PTP::Common::GroupModifyAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupModifyNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupModifyNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .PTP.Common.GroupModifyAction group_modify_action = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_group_modify_action(), target);
  }

  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // required string value = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupModifyNotify)
  return target;
}

size_t GroupModifyNotify::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupModifyNotify)
  size_t total_size = 0;

  if (_internal_has_value()) {
    // required string value = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_group_modify_action()) {
    // required .PTP.Common.GroupModifyAction group_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_modify_action());
  }

  return total_size;
}
size_t GroupModifyNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupModifyNotify)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string value = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());

    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required .PTP.Common.GroupModifyAction group_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_modify_action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupModifyNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupModifyNotify*>(
      &from));
}

void GroupModifyNotify::MergeFrom(const GroupModifyNotify& from) {
  GroupModifyNotify* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupModifyNotify)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.group_modify_action_ = from._impl_.group_modify_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupModifyNotify::CopyFrom(const GroupModifyNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupModifyNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupModifyNotify::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupModifyNotify::InternalSwap(GroupModifyNotify* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  swap(_impl_.group_id_, other->_impl_.group_id_);
  swap(_impl_.group_modify_action_, other->_impl_.group_modify_action_);
}

std::string GroupModifyNotify::GetTypeName() const {
  return "PTP.Group.GroupModifyNotify";
}


// ===================================================================

class GroupChangeMemberReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupChangeMemberReq>()._impl_._has_bits_);
  static void set_has_group_member_modify_action(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000a) ^ 0x0000000a) != 0;
  }
};

GroupChangeMemberReq::GroupChangeMemberReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupChangeMemberReq)
}
GroupChangeMemberReq::GroupChangeMemberReq(const GroupChangeMemberReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupChangeMemberReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.auth_uid_){}
    , decltype(_impl_.group_member_modify_action_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.group_member_modify_action_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.group_member_modify_action_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupChangeMemberReq)
}

inline void GroupChangeMemberReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.auth_uid_){0u}
    , decltype(_impl_.group_member_modify_action_){1}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupChangeMemberReq::~GroupChangeMemberReq() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupChangeMemberReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupChangeMemberReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.members_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void GroupChangeMemberReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupChangeMemberReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupChangeMemberReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.members_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
    _impl_.group_member_modify_action_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupChangeMemberReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupMemberModifyAction_IsValid(val))) {
            _internal_set_group_member_modify_action(static_cast<::PTP::Common::GroupMemberModifyAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string members = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_members();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupChangeMemberReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupChangeMemberReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_group_member_modify_action(), target);
  }

  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // repeated string members = 3;
  for (int i = 0, n = this->_internal_members_size(); i < n; i++) {
    const auto& s = this->_internal_members(i);
    target = stream->WriteString(3, s, target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupChangeMemberReq)
  return target;
}

size_t GroupChangeMemberReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupChangeMemberReq)
  size_t total_size = 0;

  if (_internal_has_group_id()) {
    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_group_member_modify_action()) {
    // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_member_modify_action());
  }

  return total_size;
}
size_t GroupChangeMemberReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupChangeMemberReq)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000a) ^ 0x0000000a) == 0) {  // All required fields are present.
    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_member_modify_action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string members = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.members_.size());
  for (int i = 0, n = _impl_.members_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.members_.Get(i));
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000004u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupChangeMemberReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupChangeMemberReq*>(
      &from));
}

void GroupChangeMemberReq::MergeFrom(const GroupChangeMemberReq& from) {
  GroupChangeMemberReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupChangeMemberReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.members_.MergeFrom(from._impl_.members_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.group_member_modify_action_ = from._impl_.group_member_modify_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupChangeMemberReq::CopyFrom(const GroupChangeMemberReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupChangeMemberReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupChangeMemberReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupChangeMemberReq::InternalSwap(GroupChangeMemberReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.members_.InternalSwap(&other->_impl_.members_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupChangeMemberReq, _impl_.auth_uid_)
      + sizeof(GroupChangeMemberReq::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupChangeMemberReq, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
  swap(_impl_.group_member_modify_action_, other->_impl_.group_member_modify_action_);
}

std::string GroupChangeMemberReq::GetTypeName() const {
  return "PTP.Group.GroupChangeMemberReq";
}


// ===================================================================

class GroupChangeMemberRes::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupChangeMemberRes>()._impl_._has_bits_);
  static void set_has_group_member_modify_action(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000016) ^ 0x00000016) != 0;
  }
};

GroupChangeMemberRes::GroupChangeMemberRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupChangeMemberRes)
}
GroupChangeMemberRes::GroupChangeMemberRes(const GroupChangeMemberRes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupChangeMemberRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_chang_){from._impl_.members_chang_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.auth_uid_){}
    , decltype(_impl_.group_member_modify_action_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.group_member_modify_action_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.group_member_modify_action_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupChangeMemberRes)
}

inline void GroupChangeMemberRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_chang_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.auth_uid_){0u}
    , decltype(_impl_.group_member_modify_action_){1}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupChangeMemberRes::~GroupChangeMemberRes() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupChangeMemberRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupChangeMemberRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.members_chang_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void GroupChangeMemberRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupChangeMemberRes::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupChangeMemberRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.members_chang_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
    _impl_.group_member_modify_action_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupChangeMemberRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupMemberModifyAction_IsValid(val))) {
            _internal_set_group_member_modify_action(static_cast<::PTP::Common::GroupMemberModifyAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string members_chang = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_members_chang();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.ERR error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ERR_IsValid(val))) {
            _internal_set_error(static_cast<::PTP::Common::ERR>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupChangeMemberRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupChangeMemberRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_group_member_modify_action(), target);
  }

  // required uint32 group_id = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_group_id(), target);
  }

  // repeated string members_chang = 4;
  for (int i = 0, n = this->_internal_members_chang_size(); i < n; i++) {
    const auto& s = this->_internal_members_chang(i);
    target = stream->WriteString(4, s, target);
  }

  // required .PTP.Common.ERR error = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_error(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupChangeMemberRes)
  return target;
}

size_t GroupChangeMemberRes::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupChangeMemberRes)
  size_t total_size = 0;

  if (_internal_has_group_id()) {
    // required uint32 group_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_error()) {
    // required .PTP.Common.ERR error = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }

  if (_internal_has_group_member_modify_action()) {
    // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_member_modify_action());
  }

  return total_size;
}
size_t GroupChangeMemberRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupChangeMemberRes)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000016) ^ 0x00000016) == 0) {  // All required fields are present.
    // required uint32 group_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required .PTP.Common.ERR error = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());

    // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_member_modify_action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string members_chang = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.members_chang_.size());
  for (int i = 0, n = _impl_.members_chang_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.members_chang_.Get(i));
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupChangeMemberRes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupChangeMemberRes*>(
      &from));
}

void GroupChangeMemberRes::MergeFrom(const GroupChangeMemberRes& from) {
  GroupChangeMemberRes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupChangeMemberRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.members_chang_.MergeFrom(from._impl_.members_chang_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.group_member_modify_action_ = from._impl_.group_member_modify_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupChangeMemberRes::CopyFrom(const GroupChangeMemberRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupChangeMemberRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupChangeMemberRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupChangeMemberRes::InternalSwap(GroupChangeMemberRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.members_chang_.InternalSwap(&other->_impl_.members_chang_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupChangeMemberRes, _impl_.auth_uid_)
      + sizeof(GroupChangeMemberRes::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupChangeMemberRes, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
  swap(_impl_.group_member_modify_action_, other->_impl_.group_member_modify_action_);
}

std::string GroupChangeMemberRes::GetTypeName() const {
  return "PTP.Group.GroupChangeMemberRes";
}


// ===================================================================

class GroupChangeMemberNotify::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupChangeMemberNotify>()._impl_._has_bits_);
  static void set_has_group_member_modify_action(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GroupChangeMemberNotify::GroupChangeMemberNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupChangeMemberNotify)
}
GroupChangeMemberNotify::GroupChangeMemberNotify(const GroupChangeMemberNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupChangeMemberNotify* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_chang_){from._impl_.members_chang_}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.group_member_modify_action_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.group_member_modify_action_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.group_member_modify_action_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupChangeMemberNotify)
}

inline void GroupChangeMemberNotify::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_chang_){arena}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.group_member_modify_action_){1}
  };
}

GroupChangeMemberNotify::~GroupChangeMemberNotify() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupChangeMemberNotify)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupChangeMemberNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.members_chang_.~RepeatedPtrField();
}

void GroupChangeMemberNotify::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupChangeMemberNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupChangeMemberNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.members_chang_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.group_id_ = 0u;
    _impl_.group_member_modify_action_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupChangeMemberNotify::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupMemberModifyAction_IsValid(val))) {
            _internal_set_group_member_modify_action(static_cast<::PTP::Common::GroupMemberModifyAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string members_chang = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_members_chang();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupChangeMemberNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupChangeMemberNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_group_member_modify_action(), target);
  }

  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // repeated string members_chang = 3;
  for (int i = 0, n = this->_internal_members_chang_size(); i < n; i++) {
    const auto& s = this->_internal_members_chang(i);
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupChangeMemberNotify)
  return target;
}

size_t GroupChangeMemberNotify::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupChangeMemberNotify)
  size_t total_size = 0;

  if (_internal_has_group_id()) {
    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_group_member_modify_action()) {
    // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_member_modify_action());
  }

  return total_size;
}
size_t GroupChangeMemberNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupChangeMemberNotify)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required .PTP.Common.GroupMemberModifyAction group_member_modify_action = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_member_modify_action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string members_chang = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.members_chang_.size());
  for (int i = 0, n = _impl_.members_chang_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.members_chang_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupChangeMemberNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupChangeMemberNotify*>(
      &from));
}

void GroupChangeMemberNotify::MergeFrom(const GroupChangeMemberNotify& from) {
  GroupChangeMemberNotify* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupChangeMemberNotify)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.members_chang_.MergeFrom(from._impl_.members_chang_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_member_modify_action_ = from._impl_.group_member_modify_action_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupChangeMemberNotify::CopyFrom(const GroupChangeMemberNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupChangeMemberNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupChangeMemberNotify::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupChangeMemberNotify::InternalSwap(GroupChangeMemberNotify* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.members_chang_.InternalSwap(&other->_impl_.members_chang_);
  swap(_impl_.group_id_, other->_impl_.group_id_);
  swap(_impl_.group_member_modify_action_, other->_impl_.group_member_modify_action_);
}

std::string GroupChangeMemberNotify::GetTypeName() const {
  return "PTP.Group.GroupChangeMemberNotify";
}


// ===================================================================

class GroupGetListReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupGetListReq>()._impl_._has_bits_);
  static void set_has_group_info_updated_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

GroupGetListReq::GroupGetListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupGetListReq)
}
GroupGetListReq::GroupGetListReq(const GroupGetListReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupGetListReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_info_updated_time_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_info_updated_time_, &from._impl_.group_info_updated_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_info_updated_time_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupGetListReq)
}

inline void GroupGetListReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_info_updated_time_){0u}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupGetListReq::~GroupGetListReq() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupGetListReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupGetListReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void GroupGetListReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupGetListReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupGetListReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.group_info_updated_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_info_updated_time_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupGetListReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_info_updated_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_info_updated_time(&has_bits);
          _impl_.group_info_updated_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupGetListReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupGetListReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_info_updated_time = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_info_updated_time(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupGetListReq)
  return target;
}

size_t GroupGetListReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupGetListReq)
  size_t total_size = 0;

  // required uint32 group_info_updated_time = 1;
  if (_internal_has_group_info_updated_time()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_info_updated_time());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000004u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupGetListReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupGetListReq*>(
      &from));
}

void GroupGetListReq::MergeFrom(const GroupGetListReq& from) {
  GroupGetListReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupGetListReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_info_updated_time_ = from._impl_.group_info_updated_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupGetListReq::CopyFrom(const GroupGetListReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupGetListReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupGetListReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupGetListReq::InternalSwap(GroupGetListReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupGetListReq, _impl_.auth_uid_)
      + sizeof(GroupGetListReq::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupGetListReq, _impl_.group_info_updated_time_)>(
          reinterpret_cast<char*>(&_impl_.group_info_updated_time_),
          reinterpret_cast<char*>(&other->_impl_.group_info_updated_time_));
}

std::string GroupGetListReq::GetTypeName() const {
  return "PTP.Group.GroupGetListReq";
}


// ===================================================================

class GroupGetListRes::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupGetListRes>()._impl_._has_bits_);
  static void set_has_group_info_updated_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

void GroupGetListRes::clear_groups() {
  _impl_.groups_.Clear();
}
GroupGetListRes::GroupGetListRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupGetListRes)
}
GroupGetListRes::GroupGetListRes(const GroupGetListRes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupGetListRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.groups_){from._impl_.groups_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_info_updated_time_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_info_updated_time_, &from._impl_.group_info_updated_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_info_updated_time_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupGetListRes)
}

inline void GroupGetListRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.groups_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_info_updated_time_){0u}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupGetListRes::~GroupGetListRes() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupGetListRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupGetListRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.groups_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void GroupGetListRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupGetListRes::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupGetListRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.groups_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.group_info_updated_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_info_updated_time_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupGetListRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_info_updated_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_info_updated_time(&has_bits);
          _impl_.group_info_updated_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PTP.Common.GroupInfo groups = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_groups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.ERR error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ERR_IsValid(val))) {
            _internal_set_error(static_cast<::PTP::Common::ERR>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupGetListRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupGetListRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_info_updated_time = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_info_updated_time(), target);
  }

  // repeated .PTP.Common.GroupInfo groups = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_groups_size()); i < n; i++) {
    const auto& repfield = this->_internal_groups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required .PTP.Common.ERR error = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_error(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupGetListRes)
  return target;
}

size_t GroupGetListRes::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupGetListRes)
  size_t total_size = 0;

  if (_internal_has_group_info_updated_time()) {
    // required uint32 group_info_updated_time = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_info_updated_time());
  }

  if (_internal_has_error()) {
    // required .PTP.Common.ERR error = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }

  return total_size;
}
size_t GroupGetListRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupGetListRes)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 group_info_updated_time = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_info_updated_time());

    // required .PTP.Common.ERR error = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PTP.Common.GroupInfo groups = 2;
  total_size += 1UL * this->_internal_groups_size();
  for (const auto& msg : this->_impl_.groups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupGetListRes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupGetListRes*>(
      &from));
}

void GroupGetListRes::MergeFrom(const GroupGetListRes& from) {
  GroupGetListRes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupGetListRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.groups_.MergeFrom(from._impl_.groups_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_info_updated_time_ = from._impl_.group_info_updated_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupGetListRes::CopyFrom(const GroupGetListRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupGetListRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupGetListRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.groups_))
    return false;
  return true;
}

void GroupGetListRes::InternalSwap(GroupGetListRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.groups_.InternalSwap(&other->_impl_.groups_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupGetListRes, _impl_.auth_uid_)
      + sizeof(GroupGetListRes::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupGetListRes, _impl_.group_info_updated_time_)>(
          reinterpret_cast<char*>(&_impl_.group_info_updated_time_),
          reinterpret_cast<char*>(&other->_impl_.group_info_updated_time_));
}

std::string GroupGetListRes::GetTypeName() const {
  return "PTP.Group.GroupGetListRes";
}


// ===================================================================

class GroupGetMembersListReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupGetMembersListReq>()._impl_._has_bits_);
  static void set_has_group_members_updated_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

GroupGetMembersListReq::GroupGetMembersListReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupGetMembersListReq)
}
GroupGetMembersListReq::GroupGetMembersListReq(const GroupGetMembersListReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupGetMembersListReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_members_updated_time_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_members_updated_time_, &from._impl_.group_members_updated_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_members_updated_time_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupGetMembersListReq)
}

inline void GroupGetMembersListReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_members_updated_time_){0u}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupGetMembersListReq::~GroupGetMembersListReq() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupGetMembersListReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupGetMembersListReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void GroupGetMembersListReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupGetMembersListReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupGetMembersListReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.group_members_updated_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_members_updated_time_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupGetMembersListReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_members_updated_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_members_updated_time(&has_bits);
          _impl_.group_members_updated_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupGetMembersListReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupGetMembersListReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_members_updated_time = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_members_updated_time(), target);
  }

  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupGetMembersListReq)
  return target;
}

size_t GroupGetMembersListReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupGetMembersListReq)
  size_t total_size = 0;

  if (_internal_has_group_members_updated_time()) {
    // required uint32 group_members_updated_time = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_members_updated_time());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  return total_size;
}
size_t GroupGetMembersListReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupGetMembersListReq)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 group_members_updated_time = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_members_updated_time());

    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupGetMembersListReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupGetMembersListReq*>(
      &from));
}

void GroupGetMembersListReq::MergeFrom(const GroupGetMembersListReq& from) {
  GroupGetMembersListReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupGetMembersListReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_members_updated_time_ = from._impl_.group_members_updated_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupGetMembersListReq::CopyFrom(const GroupGetMembersListReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupGetMembersListReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupGetMembersListReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupGetMembersListReq::InternalSwap(GroupGetMembersListReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupGetMembersListReq, _impl_.auth_uid_)
      + sizeof(GroupGetMembersListReq::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupGetMembersListReq, _impl_.group_members_updated_time_)>(
          reinterpret_cast<char*>(&_impl_.group_members_updated_time_),
          reinterpret_cast<char*>(&other->_impl_.group_members_updated_time_));
}

std::string GroupGetMembersListReq::GetTypeName() const {
  return "PTP.Group.GroupGetMembersListReq";
}


// ===================================================================

class GroupGetMembersListRes::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupGetMembersListRes>()._impl_._has_bits_);
  static void set_has_group_members_updated_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000e) ^ 0x0000000e) != 0;
  }
};

void GroupGetMembersListRes::clear_members() {
  _impl_.members_.Clear();
}
void GroupGetMembersListRes::clear_group_members() {
  _impl_.group_members_.Clear();
}
GroupGetMembersListRes::GroupGetMembersListRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupGetMembersListRes)
}
GroupGetMembersListRes::GroupGetMembersListRes(const GroupGetMembersListRes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupGetMembersListRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){from._impl_.members_}
    , decltype(_impl_.group_members_){from._impl_.group_members_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_members_updated_time_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_members_updated_time_, &from._impl_.group_members_updated_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_members_updated_time_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupGetMembersListRes)
}

inline void GroupGetMembersListRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.members_){arena}
    , decltype(_impl_.group_members_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_members_updated_time_){0u}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupGetMembersListRes::~GroupGetMembersListRes() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupGetMembersListRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupGetMembersListRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.members_.~RepeatedPtrField();
  _impl_.group_members_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void GroupGetMembersListRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupGetMembersListRes::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupGetMembersListRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.members_.Clear();
  _impl_.group_members_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.group_members_updated_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_members_updated_time_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupGetMembersListRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_members_updated_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_members_updated_time(&has_bits);
          _impl_.group_members_updated_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PTP.Common.UserInfo members = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_members(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .PTP.Common.GroupMember group_members = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_group_members(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.ERR error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ERR_IsValid(val))) {
            _internal_set_error(static_cast<::PTP::Common::ERR>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupGetMembersListRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupGetMembersListRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_members_updated_time = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_members_updated_time(), target);
  }

  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // repeated .PTP.Common.UserInfo members = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_members_size()); i < n; i++) {
    const auto& repfield = this->_internal_members(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .PTP.Common.GroupMember group_members = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_group_members_size()); i < n; i++) {
    const auto& repfield = this->_internal_group_members(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // required .PTP.Common.ERR error = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_error(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupGetMembersListRes)
  return target;
}

size_t GroupGetMembersListRes::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupGetMembersListRes)
  size_t total_size = 0;

  if (_internal_has_group_members_updated_time()) {
    // required uint32 group_members_updated_time = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_members_updated_time());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_error()) {
    // required .PTP.Common.ERR error = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }

  return total_size;
}
size_t GroupGetMembersListRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupGetMembersListRes)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required uint32 group_members_updated_time = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_members_updated_time());

    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required .PTP.Common.ERR error = 5;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PTP.Common.UserInfo members = 3;
  total_size += 1UL * this->_internal_members_size();
  for (const auto& msg : this->_impl_.members_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .PTP.Common.GroupMember group_members = 4;
  total_size += 1UL * this->_internal_group_members_size();
  for (const auto& msg : this->_impl_.group_members_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000010u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupGetMembersListRes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupGetMembersListRes*>(
      &from));
}

void GroupGetMembersListRes::MergeFrom(const GroupGetMembersListRes& from) {
  GroupGetMembersListRes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupGetMembersListRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.members_.MergeFrom(from._impl_.members_);
  _this->_impl_.group_members_.MergeFrom(from._impl_.group_members_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_members_updated_time_ = from._impl_.group_members_updated_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupGetMembersListRes::CopyFrom(const GroupGetMembersListRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupGetMembersListRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupGetMembersListRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.members_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.group_members_))
    return false;
  return true;
}

void GroupGetMembersListRes::InternalSwap(GroupGetMembersListRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.members_.InternalSwap(&other->_impl_.members_);
  _impl_.group_members_.InternalSwap(&other->_impl_.group_members_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupGetMembersListRes, _impl_.auth_uid_)
      + sizeof(GroupGetMembersListRes::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupGetMembersListRes, _impl_.group_members_updated_time_)>(
          reinterpret_cast<char*>(&_impl_.group_members_updated_time_),
          reinterpret_cast<char*>(&other->_impl_.group_members_updated_time_));
}

std::string GroupGetMembersListRes::GetTypeName() const {
  return "PTP.Group.GroupGetMembersListRes";
}


// ===================================================================

class GroupUnreadMsgReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupUnreadMsgReq>()._impl_._has_bits_);
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

GroupUnreadMsgReq::GroupUnreadMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupUnreadMsgReq)
}
GroupUnreadMsgReq::GroupUnreadMsgReq(const GroupUnreadMsgReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupUnreadMsgReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupUnreadMsgReq)
}

inline void GroupUnreadMsgReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupUnreadMsgReq::~GroupUnreadMsgReq() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupUnreadMsgReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupUnreadMsgReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void GroupUnreadMsgReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupUnreadMsgReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupUnreadMsgReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupUnreadMsgReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupUnreadMsgReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupUnreadMsgReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupUnreadMsgReq)
  return target;
}

size_t GroupUnreadMsgReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupUnreadMsgReq)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes attach_data = 20;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_attach_data());
    }

    // optional uint32 auth_uid = 21;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_auth_uid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupUnreadMsgReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupUnreadMsgReq*>(
      &from));
}

void GroupUnreadMsgReq::MergeFrom(const GroupUnreadMsgReq& from) {
  GroupUnreadMsgReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupUnreadMsgReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupUnreadMsgReq::CopyFrom(const GroupUnreadMsgReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupUnreadMsgReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupUnreadMsgReq::IsInitialized() const {
  return true;
}

void GroupUnreadMsgReq::InternalSwap(GroupUnreadMsgReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  swap(_impl_.auth_uid_, other->_impl_.auth_uid_);
}

std::string GroupUnreadMsgReq::GetTypeName() const {
  return "PTP.Group.GroupUnreadMsgReq";
}


// ===================================================================

class GroupUnreadMsgRes::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupUnreadMsgRes>()._impl_._has_bits_);
  static void set_has_unread_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

void GroupUnreadMsgRes::clear_unread_list() {
  _impl_.unread_list_.Clear();
}
GroupUnreadMsgRes::GroupUnreadMsgRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupUnreadMsgRes)
}
GroupUnreadMsgRes::GroupUnreadMsgRes(const GroupUnreadMsgRes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupUnreadMsgRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unread_list_){from._impl_.unread_list_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.unread_cnt_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.unread_cnt_, &from._impl_.unread_cnt_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.unread_cnt_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupUnreadMsgRes)
}

inline void GroupUnreadMsgRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.unread_list_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.unread_cnt_){0u}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupUnreadMsgRes::~GroupUnreadMsgRes() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupUnreadMsgRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupUnreadMsgRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.unread_list_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void GroupUnreadMsgRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupUnreadMsgRes::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupUnreadMsgRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.unread_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.unread_cnt_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.unread_cnt_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupUnreadMsgRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .PTP.Common.MsgInfo unread_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_unread_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required uint32 unread_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_unread_cnt(&has_bits);
          _impl_.unread_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.ERR error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ERR_IsValid(val))) {
            _internal_set_error(static_cast<::PTP::Common::ERR>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupUnreadMsgRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupUnreadMsgRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .PTP.Common.MsgInfo unread_list = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_unread_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_unread_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 unread_cnt = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_unread_cnt(), target);
  }

  // required .PTP.Common.ERR error = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupUnreadMsgRes)
  return target;
}

size_t GroupUnreadMsgRes::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupUnreadMsgRes)
  size_t total_size = 0;

  if (_internal_has_unread_cnt()) {
    // required uint32 unread_cnt = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unread_cnt());
  }

  if (_internal_has_error()) {
    // required .PTP.Common.ERR error = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }

  return total_size;
}
size_t GroupUnreadMsgRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupUnreadMsgRes)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 unread_cnt = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unread_cnt());

    // required .PTP.Common.ERR error = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PTP.Common.MsgInfo unread_list = 1;
  total_size += 1UL * this->_internal_unread_list_size();
  for (const auto& msg : this->_impl_.unread_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupUnreadMsgRes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupUnreadMsgRes*>(
      &from));
}

void GroupUnreadMsgRes::MergeFrom(const GroupUnreadMsgRes& from) {
  GroupUnreadMsgRes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupUnreadMsgRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.unread_list_.MergeFrom(from._impl_.unread_list_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.unread_cnt_ = from._impl_.unread_cnt_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupUnreadMsgRes::CopyFrom(const GroupUnreadMsgRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupUnreadMsgRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupUnreadMsgRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.unread_list_))
    return false;
  return true;
}

void GroupUnreadMsgRes::InternalSwap(GroupUnreadMsgRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.unread_list_.InternalSwap(&other->_impl_.unread_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupUnreadMsgRes, _impl_.auth_uid_)
      + sizeof(GroupUnreadMsgRes::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupUnreadMsgRes, _impl_.unread_cnt_)>(
          reinterpret_cast<char*>(&_impl_.unread_cnt_),
          reinterpret_cast<char*>(&other->_impl_.unread_cnt_));
}

std::string GroupUnreadMsgRes::GetTypeName() const {
  return "PTP.Group.GroupUnreadMsgRes";
}


// ===================================================================

class GroupRemoveSessionReq::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupRemoveSessionReq>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

GroupRemoveSessionReq::GroupRemoveSessionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupRemoveSessionReq)
}
GroupRemoveSessionReq::GroupRemoveSessionReq(const GroupRemoveSessionReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupRemoveSessionReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupRemoveSessionReq)
}

inline void GroupRemoveSessionReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupRemoveSessionReq::~GroupRemoveSessionReq() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupRemoveSessionReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupRemoveSessionReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void GroupRemoveSessionReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupRemoveSessionReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupRemoveSessionReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupRemoveSessionReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupRemoveSessionReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupRemoveSessionReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupRemoveSessionReq)
  return target;
}

size_t GroupRemoveSessionReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupRemoveSessionReq)
  size_t total_size = 0;

  // required uint32 group_id = 2;
  if (_internal_has_group_id()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000004u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupRemoveSessionReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupRemoveSessionReq*>(
      &from));
}

void GroupRemoveSessionReq::MergeFrom(const GroupRemoveSessionReq& from) {
  GroupRemoveSessionReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupRemoveSessionReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupRemoveSessionReq::CopyFrom(const GroupRemoveSessionReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupRemoveSessionReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupRemoveSessionReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupRemoveSessionReq::InternalSwap(GroupRemoveSessionReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupRemoveSessionReq, _impl_.auth_uid_)
      + sizeof(GroupRemoveSessionReq::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupRemoveSessionReq, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string GroupRemoveSessionReq::GetTypeName() const {
  return "PTP.Group.GroupRemoveSessionReq";
}


// ===================================================================

class GroupRemoveSessionRes::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupRemoveSessionRes>()._impl_._has_bits_);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

GroupRemoveSessionRes::GroupRemoveSessionRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupRemoveSessionRes)
}
GroupRemoveSessionRes::GroupRemoveSessionRes(const GroupRemoveSessionRes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupRemoveSessionRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.error_, &from._impl_.error_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupRemoveSessionRes)
}

inline void GroupRemoveSessionRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupRemoveSessionRes::~GroupRemoveSessionRes() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupRemoveSessionRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupRemoveSessionRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void GroupRemoveSessionRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupRemoveSessionRes::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupRemoveSessionRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.error_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupRemoveSessionRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PTP.Common.ERR error = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ERR_IsValid(val))) {
            _internal_set_error(static_cast<::PTP::Common::ERR>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupRemoveSessionRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupRemoveSessionRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .PTP.Common.ERR error = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_error(), target);
  }

  // required uint32 group_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_group_id(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupRemoveSessionRes)
  return target;
}

size_t GroupRemoveSessionRes::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupRemoveSessionRes)
  size_t total_size = 0;

  if (_internal_has_error()) {
    // required .PTP.Common.ERR error = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  return total_size;
}
size_t GroupRemoveSessionRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupRemoveSessionRes)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required .PTP.Common.ERR error = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error());

    // required uint32 group_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupRemoveSessionRes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupRemoveSessionRes*>(
      &from));
}

void GroupRemoveSessionRes::MergeFrom(const GroupRemoveSessionRes& from) {
  GroupRemoveSessionRes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupRemoveSessionRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupRemoveSessionRes::CopyFrom(const GroupRemoveSessionRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupRemoveSessionRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupRemoveSessionRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupRemoveSessionRes::InternalSwap(GroupRemoveSessionRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupRemoveSessionRes, _impl_.auth_uid_)
      + sizeof(GroupRemoveSessionRes::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupRemoveSessionRes, _impl_.error_)>(
          reinterpret_cast<char*>(&_impl_.error_),
          reinterpret_cast<char*>(&other->_impl_.error_));
}

std::string GroupRemoveSessionRes::GetTypeName() const {
  return "PTP.Group.GroupRemoveSessionRes";
}


// ===================================================================

class GroupRemoveSessionNotify::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupRemoveSessionNotify>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_from_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GroupRemoveSessionNotify::GroupRemoveSessionNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Group.GroupRemoveSessionNotify)
}
GroupRemoveSessionNotify::GroupRemoveSessionNotify(const GroupRemoveSessionNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupRemoveSessionNotify* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.from_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.from_uid_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.from_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Group.GroupRemoveSessionNotify)
}

inline void GroupRemoveSessionNotify::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.from_uid_){0u}
  };
}

GroupRemoveSessionNotify::~GroupRemoveSessionNotify() {
  // @@protoc_insertion_point(destructor:PTP.Group.GroupRemoveSessionNotify)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupRemoveSessionNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GroupRemoveSessionNotify::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupRemoveSessionNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Group.GroupRemoveSessionNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.from_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.from_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupRemoveSessionNotify::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 from_uid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_from_uid(&has_bits);
          _impl_.from_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupRemoveSessionNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Group.GroupRemoveSessionNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // required uint32 from_uid = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_from_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Group.GroupRemoveSessionNotify)
  return target;
}

size_t GroupRemoveSessionNotify::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Group.GroupRemoveSessionNotify)
  size_t total_size = 0;

  if (_internal_has_group_id()) {
    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_from_uid()) {
    // required uint32 from_uid = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_uid());
  }

  return total_size;
}
size_t GroupRemoveSessionNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Group.GroupRemoveSessionNotify)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 from_uid = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_uid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupRemoveSessionNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupRemoveSessionNotify*>(
      &from));
}

void GroupRemoveSessionNotify::MergeFrom(const GroupRemoveSessionNotify& from) {
  GroupRemoveSessionNotify* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Group.GroupRemoveSessionNotify)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.from_uid_ = from._impl_.from_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupRemoveSessionNotify::CopyFrom(const GroupRemoveSessionNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Group.GroupRemoveSessionNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupRemoveSessionNotify::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupRemoveSessionNotify::InternalSwap(GroupRemoveSessionNotify* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupRemoveSessionNotify, _impl_.from_uid_)
      + sizeof(GroupRemoveSessionNotify::_impl_.from_uid_)
      - PROTOBUF_FIELD_OFFSET(GroupRemoveSessionNotify, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string GroupRemoveSessionNotify::GetTypeName() const {
  return "PTP.Group.GroupRemoveSessionNotify";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Group
}  // namespace PTP
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupPreCreateReq*
Arena::CreateMaybeMessage< ::PTP::Group::GroupPreCreateReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupPreCreateReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupPreCreateRes*
Arena::CreateMaybeMessage< ::PTP::Group::GroupPreCreateRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupPreCreateRes >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupCreateReq*
Arena::CreateMaybeMessage< ::PTP::Group::GroupCreateReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupCreateReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupCreateRes*
Arena::CreateMaybeMessage< ::PTP::Group::GroupCreateRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupCreateRes >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupModifyReq*
Arena::CreateMaybeMessage< ::PTP::Group::GroupModifyReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupModifyReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupModifyRes*
Arena::CreateMaybeMessage< ::PTP::Group::GroupModifyRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupModifyRes >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupModifyNotify*
Arena::CreateMaybeMessage< ::PTP::Group::GroupModifyNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupModifyNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupChangeMemberReq*
Arena::CreateMaybeMessage< ::PTP::Group::GroupChangeMemberReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupChangeMemberReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupChangeMemberRes*
Arena::CreateMaybeMessage< ::PTP::Group::GroupChangeMemberRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupChangeMemberRes >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupChangeMemberNotify*
Arena::CreateMaybeMessage< ::PTP::Group::GroupChangeMemberNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupChangeMemberNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupGetListReq*
Arena::CreateMaybeMessage< ::PTP::Group::GroupGetListReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupGetListReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupGetListRes*
Arena::CreateMaybeMessage< ::PTP::Group::GroupGetListRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupGetListRes >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupGetMembersListReq*
Arena::CreateMaybeMessage< ::PTP::Group::GroupGetMembersListReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupGetMembersListReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupGetMembersListRes*
Arena::CreateMaybeMessage< ::PTP::Group::GroupGetMembersListRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupGetMembersListRes >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupUnreadMsgReq*
Arena::CreateMaybeMessage< ::PTP::Group::GroupUnreadMsgReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupUnreadMsgReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupUnreadMsgRes*
Arena::CreateMaybeMessage< ::PTP::Group::GroupUnreadMsgRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupUnreadMsgRes >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupRemoveSessionReq*
Arena::CreateMaybeMessage< ::PTP::Group::GroupRemoveSessionReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupRemoveSessionReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupRemoveSessionRes*
Arena::CreateMaybeMessage< ::PTP::Group::GroupRemoveSessionRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupRemoveSessionRes >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Group::GroupRemoveSessionNotify*
Arena::CreateMaybeMessage< ::PTP::Group::GroupRemoveSessionNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Group::GroupRemoveSessionNotify >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
