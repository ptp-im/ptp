// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PTP.Msg.proto

#include "PTP.Msg.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace PTP {
namespace Msg {
PROTOBUF_CONSTEXPR MsgReq::MsgReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_adr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sent_at_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u
  , /*decltype(_impl_.msg_type_)*/1} {}
struct MsgReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgReqDefaultTypeInternal() {}
  union {
    MsgReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgReqDefaultTypeInternal _MsgReq_default_instance_;
PROTOBUF_CONSTEXPR MsgRes::MsgRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.msg_id_)*/0u
  , /*decltype(_impl_.sent_at_)*/0u
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct MsgResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgResDefaultTypeInternal() {}
  union {
    MsgRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgResDefaultTypeInternal _MsgRes_default_instance_;
PROTOBUF_CONSTEXPR MsgNotify::MsgNotify(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.notify_users_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_info_)*/nullptr
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct MsgNotifyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgNotifyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgNotifyDefaultTypeInternal() {}
  union {
    MsgNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgNotifyDefaultTypeInternal _MsgNotify_default_instance_;
PROTOBUF_CONSTEXPR MsgReadAckReq::MsgReadAckReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.msg_id_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct MsgReadAckReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgReadAckReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgReadAckReqDefaultTypeInternal() {}
  union {
    MsgReadAckReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgReadAckReqDefaultTypeInternal _MsgReadAckReq_default_instance_;
PROTOBUF_CONSTEXPR MsgReadNotify::MsgReadNotify(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.notify_users_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.from_uid_)*/0u
  , /*decltype(_impl_.msg_id_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct MsgReadNotifyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgReadNotifyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgReadNotifyDefaultTypeInternal() {}
  union {
    MsgReadNotify _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgReadNotifyDefaultTypeInternal _MsgReadNotify_default_instance_;
PROTOBUF_CONSTEXPR MsgGetByIdsReq::MsgGetByIdsReq(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_ids_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct MsgGetByIdsReqDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgGetByIdsReqDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgGetByIdsReqDefaultTypeInternal() {}
  union {
    MsgGetByIdsReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgGetByIdsReqDefaultTypeInternal _MsgGetByIdsReq_default_instance_;
PROTOBUF_CONSTEXPR MsgGetByIdsRes::MsgGetByIdsRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_list_)*/{}
  , /*decltype(_impl_.attach_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.error_)*/0
  , /*decltype(_impl_.auth_uid_)*/0u} {}
struct MsgGetByIdsResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgGetByIdsResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgGetByIdsResDefaultTypeInternal() {}
  union {
    MsgGetByIdsRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgGetByIdsResDefaultTypeInternal _MsgGetByIdsRes_default_instance_;
}  // namespace Msg
}  // namespace PTP
namespace PTP {
namespace Msg {

// ===================================================================

class MsgReq::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgReq>()._impl_._has_bits_);
  static void set_has_group_adr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sent_at(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000029) ^ 0x00000029) != 0;
  }
};

MsgReq::MsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Msg.MsgReq)
}
MsgReq::MsgReq(const MsgReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_adr_){}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.sent_at_){}
    , decltype(_impl_.auth_uid_){}
    , decltype(_impl_.msg_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.group_adr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_adr()) {
    _this->_impl_.group_adr_.Set(from._internal_group_adr(), 
      _this->GetArenaForAllocation());
  }
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg_data()) {
    _this->_impl_.msg_data_.Set(from._internal_msg_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.sent_at_, &from._impl_.sent_at_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.msg_type_) -
    reinterpret_cast<char*>(&_impl_.sent_at_)) + sizeof(_impl_.msg_type_));
  // @@protoc_insertion_point(copy_constructor:PTP.Msg.MsgReq)
}

inline void MsgReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_adr_){}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.sent_at_){0u}
    , decltype(_impl_.auth_uid_){0u}
    , decltype(_impl_.msg_type_){1}
  };
  _impl_.group_adr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgReq::~MsgReq() {
  // @@protoc_insertion_point(destructor:PTP.Msg.MsgReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.group_adr_.Destroy();
  _impl_.msg_data_.Destroy();
  _impl_.attach_data_.Destroy();
}

void MsgReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Msg.MsgReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.group_adr_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.msg_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.attach_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&_impl_.sent_at_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.sent_at_)) + sizeof(_impl_.auth_uid_));
    _impl_.msg_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string group_adr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_group_adr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 sent_at = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sent_at(&has_bits);
          _impl_.sent_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.MsgType msg_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::MsgType_IsValid(val))) {
            _internal_set_msg_type(static_cast<::PTP::Common::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string msg_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Msg.MsgReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string group_adr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_group_adr(), target);
  }

  // required uint32 sent_at = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sent_at(), target);
  }

  // required .PTP.Common.MsgType msg_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_msg_type(), target);
  }

  // optional string msg_data = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_msg_data(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Msg.MsgReq)
  return target;
}

size_t MsgReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Msg.MsgReq)
  size_t total_size = 0;

  if (_internal_has_group_adr()) {
    // required string group_adr = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_adr());
  }

  if (_internal_has_sent_at()) {
    // required uint32 sent_at = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sent_at());
  }

  if (_internal_has_msg_type()) {
    // required .PTP.Common.MsgType msg_type = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_type());
  }

  return total_size;
}
size_t MsgReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Msg.MsgReq)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000029) ^ 0x00000029) == 0) {  // All required fields are present.
    // required string group_adr = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_adr());

    // required uint32 sent_at = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sent_at());

    // required .PTP.Common.MsgType msg_type = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string msg_data = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_msg_data());
    }

    // optional bytes attach_data = 20;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_attach_data());
    }

  }
  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000010u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgReq*>(
      &from));
}

void MsgReq::MergeFrom(const MsgReq& from) {
  MsgReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Msg.MsgReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_group_adr(from._internal_group_adr());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_msg_data(from._internal_msg_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sent_at_ = from._impl_.sent_at_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgReq::CopyFrom(const MsgReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Msg.MsgReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MsgReq::InternalSwap(MsgReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.group_adr_, lhs_arena,
      &other->_impl_.group_adr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_data_, lhs_arena,
      &other->_impl_.msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgReq, _impl_.auth_uid_)
      + sizeof(MsgReq::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(MsgReq, _impl_.sent_at_)>(
          reinterpret_cast<char*>(&_impl_.sent_at_),
          reinterpret_cast<char*>(&other->_impl_.sent_at_));
  swap(_impl_.msg_type_, other->_impl_.msg_type_);
}

std::string MsgReq::GetTypeName() const {
  return "PTP.Msg.MsgReq";
}


// ===================================================================

class MsgRes::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgRes>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sent_at(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

MsgRes::MsgRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Msg.MsgRes)
}
MsgRes::MsgRes(const MsgRes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.msg_id_){}
    , decltype(_impl_.sent_at_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Msg.MsgRes)
}

inline void MsgRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.msg_id_){0u}
    , decltype(_impl_.sent_at_){0u}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgRes::~MsgRes() {
  // @@protoc_insertion_point(destructor:PTP.Msg.MsgRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void MsgRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgRes::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Msg.MsgRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 msg_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_msg_id(&has_bits);
          _impl_.msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sent_at = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_sent_at(&has_bits);
          _impl_.sent_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PTP.Common.ERR error = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ERR_IsValid(val))) {
            _internal_set_error(static_cast<::PTP::Common::ERR>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Msg.MsgRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 group_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // optional uint32 msg_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_msg_id(), target);
  }

  // optional uint32 sent_at = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_sent_at(), target);
  }

  // optional .PTP.Common.ERR error = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_error(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Msg.MsgRes)
  return target;
}

size_t MsgRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Msg.MsgRes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes attach_data = 20;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_attach_data());
    }

    // optional uint32 group_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
    }

    // optional uint32 msg_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
    }

    // optional uint32 sent_at = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sent_at());
    }

    // optional .PTP.Common.ERR error = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

    // optional uint32 auth_uid = 21;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_auth_uid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgRes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgRes*>(
      &from));
}

void MsgRes::MergeFrom(const MsgRes& from) {
  MsgRes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Msg.MsgRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.msg_id_ = from._impl_.msg_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sent_at_ = from._impl_.sent_at_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgRes::CopyFrom(const MsgRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Msg.MsgRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgRes::IsInitialized() const {
  return true;
}

void MsgRes::InternalSwap(MsgRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgRes, _impl_.auth_uid_)
      + sizeof(MsgRes::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(MsgRes, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string MsgRes::GetTypeName() const {
  return "PTP.Msg.MsgRes";
}


// ===================================================================

class MsgNotify::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgNotify>()._impl_._has_bits_);
  static const ::PTP::Common::MsgInfo& msg_info(const MsgNotify* msg);
  static void set_has_msg_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::PTP::Common::MsgInfo&
MsgNotify::_Internal::msg_info(const MsgNotify* msg) {
  return *msg->_impl_.msg_info_;
}
void MsgNotify::clear_msg_info() {
  if (_impl_.msg_info_ != nullptr) _impl_.msg_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
MsgNotify::MsgNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Msg.MsgNotify)
}
MsgNotify::MsgNotify(const MsgNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgNotify* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.notify_users_){from._impl_.notify_users_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.msg_info_){nullptr}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_msg_info()) {
    _this->_impl_.msg_info_ = new ::PTP::Common::MsgInfo(*from._impl_.msg_info_);
  }
  _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
  // @@protoc_insertion_point(copy_constructor:PTP.Msg.MsgNotify)
}

inline void MsgNotify::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.notify_users_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.msg_info_){nullptr}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgNotify::~MsgNotify() {
  // @@protoc_insertion_point(destructor:PTP.Msg.MsgNotify)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.notify_users_.~RepeatedField();
  _impl_.attach_data_.Destroy();
  if (this != internal_default_instance()) delete _impl_.msg_info_;
}

void MsgNotify::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Msg.MsgNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.notify_users_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.attach_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.msg_info_ != nullptr);
      _impl_.msg_info_->Clear();
    }
  }
  _impl_.auth_uid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgNotify::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PTP.Common.MsgInfo msg_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_msg_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 notify_users = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_notify_users(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_notify_users(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Msg.MsgNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .PTP.Common.MsgInfo msg_info = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::msg_info(this),
        _Internal::msg_info(this).GetCachedSize(), target, stream);
  }

  // repeated uint32 notify_users = 2;
  for (int i = 0, n = this->_internal_notify_users_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_notify_users(i), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Msg.MsgNotify)
  return target;
}

size_t MsgNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Msg.MsgNotify)
  size_t total_size = 0;

  // required .PTP.Common.MsgInfo msg_info = 1;
  if (_internal_has_msg_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.msg_info_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 notify_users = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.notify_users_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_notify_users_size());
    total_size += data_size;
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000004u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgNotify*>(
      &from));
}

void MsgNotify::MergeFrom(const MsgNotify& from) {
  MsgNotify* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Msg.MsgNotify)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.notify_users_.MergeFrom(from._impl_.notify_users_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_msg_info()->::PTP::Common::MsgInfo::MergeFrom(
          from._internal_msg_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgNotify::CopyFrom(const MsgNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Msg.MsgNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgNotify::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_msg_info()) {
    if (!_impl_.msg_info_->IsInitialized()) return false;
  }
  return true;
}

void MsgNotify::InternalSwap(MsgNotify* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.notify_users_.InternalSwap(&other->_impl_.notify_users_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgNotify, _impl_.auth_uid_)
      + sizeof(MsgNotify::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(MsgNotify, _impl_.msg_info_)>(
          reinterpret_cast<char*>(&_impl_.msg_info_),
          reinterpret_cast<char*>(&other->_impl_.msg_info_));
}

std::string MsgNotify::GetTypeName() const {
  return "PTP.Msg.MsgNotify";
}


// ===================================================================

class MsgReadAckReq::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgReadAckReq>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

MsgReadAckReq::MsgReadAckReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Msg.MsgReadAckReq)
}
MsgReadAckReq::MsgReadAckReq(const MsgReadAckReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgReadAckReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.msg_id_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Msg.MsgReadAckReq)
}

inline void MsgReadAckReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.msg_id_){0u}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgReadAckReq::~MsgReadAckReq() {
  // @@protoc_insertion_point(destructor:PTP.Msg.MsgReadAckReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgReadAckReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attach_data_.Destroy();
}

void MsgReadAckReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgReadAckReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Msg.MsgReadAckReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgReadAckReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 msg_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_msg_id(&has_bits);
          _impl_.msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgReadAckReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Msg.MsgReadAckReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // required uint32 msg_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_msg_id(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Msg.MsgReadAckReq)
  return target;
}

size_t MsgReadAckReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Msg.MsgReadAckReq)
  size_t total_size = 0;

  if (_internal_has_group_id()) {
    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_msg_id()) {
    // required uint32 msg_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
  }

  return total_size;
}
size_t MsgReadAckReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Msg.MsgReadAckReq)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 msg_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgReadAckReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgReadAckReq*>(
      &from));
}

void MsgReadAckReq::MergeFrom(const MsgReadAckReq& from) {
  MsgReadAckReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Msg.MsgReadAckReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.msg_id_ = from._impl_.msg_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgReadAckReq::CopyFrom(const MsgReadAckReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Msg.MsgReadAckReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgReadAckReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MsgReadAckReq::InternalSwap(MsgReadAckReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgReadAckReq, _impl_.auth_uid_)
      + sizeof(MsgReadAckReq::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(MsgReadAckReq, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string MsgReadAckReq::GetTypeName() const {
  return "PTP.Msg.MsgReadAckReq";
}


// ===================================================================

class MsgReadNotify::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgReadNotify>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000e) ^ 0x0000000e) != 0;
  }
};

MsgReadNotify::MsgReadNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Msg.MsgReadNotify)
}
MsgReadNotify::MsgReadNotify(const MsgReadNotify& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgReadNotify* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.notify_users_){from._impl_.notify_users_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.from_uid_){}
    , decltype(_impl_.msg_id_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Msg.MsgReadNotify)
}

inline void MsgReadNotify::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.notify_users_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.from_uid_){0u}
    , decltype(_impl_.msg_id_){0u}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgReadNotify::~MsgReadNotify() {
  // @@protoc_insertion_point(destructor:PTP.Msg.MsgReadNotify)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgReadNotify::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.notify_users_.~RepeatedField();
  _impl_.attach_data_.Destroy();
}

void MsgReadNotify::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgReadNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Msg.MsgReadNotify)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.notify_users_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgReadNotify::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 from_uid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_from_uid(&has_bits);
          _impl_.from_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 notify_users = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_notify_users(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_notify_users(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 msg_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_msg_id(&has_bits);
          _impl_.msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgReadNotify::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Msg.MsgReadNotify)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // required uint32 from_uid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_from_uid(), target);
  }

  // repeated uint32 notify_users = 3;
  for (int i = 0, n = this->_internal_notify_users_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_notify_users(i), target);
  }

  // required uint32 msg_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_msg_id(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Msg.MsgReadNotify)
  return target;
}

size_t MsgReadNotify::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Msg.MsgReadNotify)
  size_t total_size = 0;

  if (_internal_has_group_id()) {
    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_from_uid()) {
    // required uint32 from_uid = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_uid());
  }

  if (_internal_has_msg_id()) {
    // required uint32 msg_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
  }

  return total_size;
}
size_t MsgReadNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Msg.MsgReadNotify)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 from_uid = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_uid());

    // required uint32 msg_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 notify_users = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.notify_users_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_notify_users_size());
    total_size += data_size;
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000010u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgReadNotify::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgReadNotify*>(
      &from));
}

void MsgReadNotify::MergeFrom(const MsgReadNotify& from) {
  MsgReadNotify* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Msg.MsgReadNotify)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.notify_users_.MergeFrom(from._impl_.notify_users_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.from_uid_ = from._impl_.from_uid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.msg_id_ = from._impl_.msg_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgReadNotify::CopyFrom(const MsgReadNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Msg.MsgReadNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgReadNotify::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MsgReadNotify::InternalSwap(MsgReadNotify* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.notify_users_.InternalSwap(&other->_impl_.notify_users_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgReadNotify, _impl_.auth_uid_)
      + sizeof(MsgReadNotify::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(MsgReadNotify, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string MsgReadNotify::GetTypeName() const {
  return "PTP.Msg.MsgReadNotify";
}


// ===================================================================

class MsgGetByIdsReq::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgGetByIdsReq>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

MsgGetByIdsReq::MsgGetByIdsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Msg.MsgGetByIdsReq)
}
MsgGetByIdsReq::MsgGetByIdsReq(const MsgGetByIdsReq& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgGetByIdsReq* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_ids_){from._impl_.msg_ids_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Msg.MsgGetByIdsReq)
}

inline void MsgGetByIdsReq::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_ids_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgGetByIdsReq::~MsgGetByIdsReq() {
  // @@protoc_insertion_point(destructor:PTP.Msg.MsgGetByIdsReq)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgGetByIdsReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_ids_.~RepeatedField();
  _impl_.attach_data_.Destroy();
}

void MsgGetByIdsReq::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgGetByIdsReq::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Msg.MsgGetByIdsReq)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.msg_ids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgGetByIdsReq::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 msg_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_msg_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_msg_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgGetByIdsReq::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Msg.MsgGetByIdsReq)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // repeated uint32 msg_ids = 2;
  for (int i = 0, n = this->_internal_msg_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_msg_ids(i), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Msg.MsgGetByIdsReq)
  return target;
}

size_t MsgGetByIdsReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Msg.MsgGetByIdsReq)
  size_t total_size = 0;

  // required uint32 group_id = 1;
  if (_internal_has_group_id()) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 msg_ids = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.msg_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_msg_ids_size());
    total_size += data_size;
  }

  // optional bytes attach_data = 20;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_attach_data());
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000004u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_auth_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgGetByIdsReq::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgGetByIdsReq*>(
      &from));
}

void MsgGetByIdsReq::MergeFrom(const MsgGetByIdsReq& from) {
  MsgGetByIdsReq* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Msg.MsgGetByIdsReq)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.msg_ids_.MergeFrom(from._impl_.msg_ids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgGetByIdsReq::CopyFrom(const MsgGetByIdsReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Msg.MsgGetByIdsReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgGetByIdsReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MsgGetByIdsReq::InternalSwap(MsgGetByIdsReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.msg_ids_.InternalSwap(&other->_impl_.msg_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgGetByIdsReq, _impl_.auth_uid_)
      + sizeof(MsgGetByIdsReq::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(MsgGetByIdsReq, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string MsgGetByIdsReq::GetTypeName() const {
  return "PTP.Msg.MsgGetByIdsReq";
}


// ===================================================================

class MsgGetByIdsRes::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgGetByIdsRes>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_attach_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

void MsgGetByIdsRes::clear_msg_list() {
  _impl_.msg_list_.Clear();
}
MsgGetByIdsRes::MsgGetByIdsRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Msg.MsgGetByIdsRes)
}
MsgGetByIdsRes::MsgGetByIdsRes(const MsgGetByIdsRes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgGetByIdsRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_list_){from._impl_.msg_list_}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.error_){}
    , decltype(_impl_.auth_uid_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attach_data()) {
    _this->_impl_.attach_data_.Set(from._internal_attach_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auth_uid_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  // @@protoc_insertion_point(copy_constructor:PTP.Msg.MsgGetByIdsRes)
}

inline void MsgGetByIdsRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_list_){arena}
    , decltype(_impl_.attach_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.error_){0}
    , decltype(_impl_.auth_uid_){0u}
  };
  _impl_.attach_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attach_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgGetByIdsRes::~MsgGetByIdsRes() {
  // @@protoc_insertion_point(destructor:PTP.Msg.MsgGetByIdsRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgGetByIdsRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_list_.~RepeatedPtrField();
  _impl_.attach_data_.Destroy();
}

void MsgGetByIdsRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgGetByIdsRes::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Msg.MsgGetByIdsRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.msg_list_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.attach_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.auth_uid_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.auth_uid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgGetByIdsRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .PTP.Common.MsgInfo msg_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_msg_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .PTP.Common.ERR error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ERR_IsValid(val))) {
            _internal_set_error(static_cast<::PTP::Common::ERR>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes attach_data = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_attach_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_uid = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_auth_uid(&has_bits);
          _impl_.auth_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgGetByIdsRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Msg.MsgGetByIdsRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 group_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // repeated .PTP.Common.MsgInfo msg_list = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_msg_list_size()); i < n; i++) {
    const auto& repfield = this->_internal_msg_list(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .PTP.Common.ERR error = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_error(), target);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_attach_data(), target);
  }

  // optional uint32 auth_uid = 21;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_auth_uid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Msg.MsgGetByIdsRes)
  return target;
}

size_t MsgGetByIdsRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Msg.MsgGetByIdsRes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .PTP.Common.MsgInfo msg_list = 2;
  total_size += 1UL * this->_internal_msg_list_size();
  for (const auto& msg : this->_impl_.msg_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes attach_data = 20;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_attach_data());
    }

    // optional uint32 group_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
    }

    // optional .PTP.Common.ERR error = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_error());
    }

    // optional uint32 auth_uid = 21;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_auth_uid());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgGetByIdsRes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgGetByIdsRes*>(
      &from));
}

void MsgGetByIdsRes::MergeFrom(const MsgGetByIdsRes& from) {
  MsgGetByIdsRes* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Msg.MsgGetByIdsRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.msg_list_.MergeFrom(from._impl_.msg_list_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attach_data(from._internal_attach_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.error_ = from._impl_.error_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.auth_uid_ = from._impl_.auth_uid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgGetByIdsRes::CopyFrom(const MsgGetByIdsRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Msg.MsgGetByIdsRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgGetByIdsRes::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.msg_list_))
    return false;
  return true;
}

void MsgGetByIdsRes::InternalSwap(MsgGetByIdsRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.msg_list_.InternalSwap(&other->_impl_.msg_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attach_data_, lhs_arena,
      &other->_impl_.attach_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgGetByIdsRes, _impl_.auth_uid_)
      + sizeof(MsgGetByIdsRes::_impl_.auth_uid_)
      - PROTOBUF_FIELD_OFFSET(MsgGetByIdsRes, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
}

std::string MsgGetByIdsRes::GetTypeName() const {
  return "PTP.Msg.MsgGetByIdsRes";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Msg
}  // namespace PTP
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::PTP::Msg::MsgReq*
Arena::CreateMaybeMessage< ::PTP::Msg::MsgReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Msg::MsgReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Msg::MsgRes*
Arena::CreateMaybeMessage< ::PTP::Msg::MsgRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Msg::MsgRes >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Msg::MsgNotify*
Arena::CreateMaybeMessage< ::PTP::Msg::MsgNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Msg::MsgNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Msg::MsgReadAckReq*
Arena::CreateMaybeMessage< ::PTP::Msg::MsgReadAckReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Msg::MsgReadAckReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Msg::MsgReadNotify*
Arena::CreateMaybeMessage< ::PTP::Msg::MsgReadNotify >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Msg::MsgReadNotify >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Msg::MsgGetByIdsReq*
Arena::CreateMaybeMessage< ::PTP::Msg::MsgGetByIdsReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Msg::MsgGetByIdsReq >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Msg::MsgGetByIdsRes*
Arena::CreateMaybeMessage< ::PTP::Msg::MsgGetByIdsRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Msg::MsgGetByIdsRes >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
