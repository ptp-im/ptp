// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PTP.Common.proto

#include "PTP.Common.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace PTP {
namespace Common {
PROTOBUF_CONSTEXPR IpAddress::IpAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0u} {}
struct IpAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IpAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IpAddressDefaultTypeInternal() {}
  union {
    IpAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IpAddressDefaultTypeInternal _IpAddress_default_instance_;
PROTOBUF_CONSTEXPR UserInfo::UserInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pub_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.avatar_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.nick_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sign_info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.first_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.last_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_)*/0u
  , /*decltype(_impl_.uid_)*/0u
  , /*decltype(_impl_.login_time_)*/0u
  , /*decltype(_impl_.is_online_)*/false} {}
struct UserInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserInfoDefaultTypeInternal() {}
  union {
    UserInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserInfoDefaultTypeInternal _UserInfo_default_instance_;
PROTOBUF_CONSTEXPR UserStatInfo::UserStatInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uid_)*/0u
  , /*decltype(_impl_.status_)*/1} {}
struct UserStatInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserStatInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserStatInfoDefaultTypeInternal() {}
  union {
    UserStatInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStatInfoDefaultTypeInternal _UserStatInfo_default_instance_;
PROTOBUF_CONSTEXPR MsgInfoList::MsgInfoList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_id_)*/0u
  , /*decltype(_impl_.from_uid_)*/0u
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.sent_at_)*/0u
  , /*decltype(_impl_.msg_type_)*/1} {}
struct MsgInfoListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgInfoListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgInfoListDefaultTypeInternal() {}
  union {
    MsgInfoList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgInfoListDefaultTypeInternal _MsgInfoList_default_instance_;
PROTOBUF_CONSTEXPR GroupMember::GroupMember(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.uid_)*/0u
  , /*decltype(_impl_.member_status_)*/1} {}
struct GroupMemberDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupMemberDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupMemberDefaultTypeInternal() {}
  union {
    GroupMember _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupMemberDefaultTypeInternal _GroupMember_default_instance_;
PROTOBUF_CONSTEXPR GroupRecord::GroupRecord(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.avatar_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_adr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pair_uid_)*/0u
  , /*decltype(_impl_.owner_uid_)*/0u
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.unreadcnt_)*/0u
  , /*decltype(_impl_.lastmsgid_)*/0u
  , /*decltype(_impl_.msguptime_)*/0u
  , /*decltype(_impl_.memberuptime_)*/0u
  , /*decltype(_impl_.group_type_)*/1} {}
struct GroupRecordDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupRecordDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupRecordDefaultTypeInternal() {}
  union {
    GroupRecord _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupRecordDefaultTypeInternal _GroupRecord_default_instance_;
PROTOBUF_CONSTEXPR GroupInfo::GroupInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.group_adr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.avatar_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.about_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_uid_)*/0u
  , /*decltype(_impl_.pair_uid_)*/0u
  , /*decltype(_impl_.group_idx_)*/0u
  , /*decltype(_impl_.created_time_)*/0u
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.updated_time_)*/0u
  , /*decltype(_impl_.group_type_)*/1} {}
struct GroupInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GroupInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GroupInfoDefaultTypeInternal() {}
  union {
    GroupInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GroupInfoDefaultTypeInternal _GroupInfo_default_instance_;
PROTOBUF_CONSTEXPR MsgInfo::MsgInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.group_id_)*/0u
  , /*decltype(_impl_.from_uid_)*/0u
  , /*decltype(_impl_.sent_at_)*/0u
  , /*decltype(_impl_.msg_id_)*/0u
  , /*decltype(_impl_.msg_type_)*/1} {}
struct MsgInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MsgInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MsgInfoDefaultTypeInternal() {}
  union {
    MsgInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MsgInfoDefaultTypeInternal _MsgInfo_default_instance_;
PROTOBUF_CONSTEXPR DevicesInfo::DevicesInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.client_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.browser_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.browser_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.os_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.login_time_)*/0u
  , /*decltype(_impl_.is_intel_)*/false
  , /*decltype(_impl_.uid_)*/0u
  , /*decltype(_impl_.client_type_)*/1} {}
struct DevicesInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DevicesInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DevicesInfoDefaultTypeInternal() {}
  union {
    DevicesInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DevicesInfoDefaultTypeInternal _DevicesInfo_default_instance_;
PROTOBUF_CONSTEXPR InputPhoneContact::InputPhoneContact(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.phone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.first_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.last_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_id_)*/uint64_t{0u}} {}
struct InputPhoneContactDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InputPhoneContactDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InputPhoneContactDefaultTypeInternal() {}
  union {
    InputPhoneContact _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InputPhoneContactDefaultTypeInternal _InputPhoneContact_default_instance_;
PROTOBUF_CONSTEXPR BuddyQueryParam::BuddyQueryParam(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.addresslist_)*/{}
  , /*decltype(_impl_.usernamelist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BuddyQueryParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BuddyQueryParamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BuddyQueryParamDefaultTypeInternal() {}
  union {
    BuddyQueryParam _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BuddyQueryParamDefaultTypeInternal _BuddyQueryParam_default_instance_;
}  // namespace Common
}  // namespace PTP
namespace PTP {
namespace Common {
bool ERR_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 404:
    case 1003:
    case 1004:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ERR_strings[16] = {};

static const char ERR_names[] =
  "E_CLIENT"
  "E_CLIENT_TIMEOUT"
  "E_GROUP_CREATE_PAIR_GROUP_MEMBER_SIE_INVALID"
  "E_GROUP_CREATE_PAIR_GROUP_NO_REG_USER"
  "E_GROUP_HAS_CREATED"
  "E_LOGIN_ERROR"
  "E_PB_PARSE_ERROR"
  "E_REASON_NO_DB_SERVER"
  "E_REASON_NO_LOGIN_SERVER"
  "E_REASON_NO_ROUTE_SERVER"
  "E_SERVER_NOT_FOUND"
  "E_SWITCH_USER_NO_ONLINE"
  "E_SYSTEM"
  "E_USERNAME_EXISTS"
  "E_USERNAME_INVALID"
  "NO_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ERR_entries[] = {
  { {ERR_names + 0, 8}, 1003 },
  { {ERR_names + 8, 16}, 1004 },
  { {ERR_names + 24, 44}, 2 },
  { {ERR_names + 68, 37}, 3 },
  { {ERR_names + 105, 19}, 4 },
  { {ERR_names + 124, 13}, 8 },
  { {ERR_names + 137, 16}, 9 },
  { {ERR_names + 153, 21}, 7 },
  { {ERR_names + 174, 24}, 6 },
  { {ERR_names + 198, 24}, 5 },
  { {ERR_names + 222, 18}, 404 },
  { {ERR_names + 240, 23}, 10 },
  { {ERR_names + 263, 8}, 1 },
  { {ERR_names + 271, 17}, 11 },
  { {ERR_names + 288, 18}, 12 },
  { {ERR_names + 306, 8}, 0 },
};

static const int ERR_entries_by_number[] = {
  15, // 0 -> NO_ERROR
  12, // 1 -> E_SYSTEM
  2, // 2 -> E_GROUP_CREATE_PAIR_GROUP_MEMBER_SIE_INVALID
  3, // 3 -> E_GROUP_CREATE_PAIR_GROUP_NO_REG_USER
  4, // 4 -> E_GROUP_HAS_CREATED
  9, // 5 -> E_REASON_NO_ROUTE_SERVER
  8, // 6 -> E_REASON_NO_LOGIN_SERVER
  7, // 7 -> E_REASON_NO_DB_SERVER
  5, // 8 -> E_LOGIN_ERROR
  6, // 9 -> E_PB_PARSE_ERROR
  11, // 10 -> E_SWITCH_USER_NO_ONLINE
  13, // 11 -> E_USERNAME_EXISTS
  14, // 12 -> E_USERNAME_INVALID
  10, // 404 -> E_SERVER_NOT_FOUND
  0, // 1003 -> E_CLIENT
  1, // 1004 -> E_CLIENT_TIMEOUT
};

const std::string& ERR_Name(
    ERR value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ERR_entries,
          ERR_entries_by_number,
          16, ERR_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ERR_entries,
      ERR_entries_by_number,
      16, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ERR_strings[idx].get();
}
bool ERR_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERR* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ERR_entries, 16, name, &int_value);
  if (success) {
    *value = static_cast<ERR>(int_value);
  }
  return success;
}
bool SwitchType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SwitchType_strings[6] = {};

static const char SwitchType_names[] =
  "SwitchType_Answer"
  "SwitchType_Apply"
  "SwitchType_Bye"
  "SwitchType_Candidate"
  "SwitchType_Offer"
  "SwitchType_Ready";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SwitchType_entries[] = {
  { {SwitchType_names + 0, 17}, 3 },
  { {SwitchType_names + 17, 16}, 1 },
  { {SwitchType_names + 33, 14}, 6 },
  { {SwitchType_names + 47, 20}, 4 },
  { {SwitchType_names + 67, 16}, 2 },
  { {SwitchType_names + 83, 16}, 5 },
};

static const int SwitchType_entries_by_number[] = {
  1, // 1 -> SwitchType_Apply
  4, // 2 -> SwitchType_Offer
  0, // 3 -> SwitchType_Answer
  3, // 4 -> SwitchType_Candidate
  5, // 5 -> SwitchType_Ready
  2, // 6 -> SwitchType_Bye
};

const std::string& SwitchType_Name(
    SwitchType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SwitchType_entries,
          SwitchType_entries_by_number,
          6, SwitchType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SwitchType_entries,
      SwitchType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SwitchType_strings[idx].get();
}
bool SwitchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SwitchType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SwitchType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<SwitchType>(int_value);
  }
  return success;
}
bool UserStat_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserStat_strings[3] = {};

static const char UserStat_names[] =
  "USER_STAT_LEAVE"
  "USER_STAT_OFFLINE"
  "USER_STAT_ONLINE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserStat_entries[] = {
  { {UserStat_names + 0, 15}, 3 },
  { {UserStat_names + 15, 17}, 2 },
  { {UserStat_names + 32, 16}, 1 },
};

static const int UserStat_entries_by_number[] = {
  2, // 1 -> USER_STAT_ONLINE
  1, // 2 -> USER_STAT_OFFLINE
  0, // 3 -> USER_STAT_LEAVE
};

const std::string& UserStat_Name(
    UserStat value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          UserStat_entries,
          UserStat_entries_by_number,
          3, UserStat_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      UserStat_entries,
      UserStat_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     UserStat_strings[idx].get();
}
bool UserStat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStat* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      UserStat_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<UserStat>(int_value);
  }
  return success;
}
bool MsgType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MsgType_strings[2] = {};

static const char MsgType_names[] =
  "MSG_TYPE_AUDIO"
  "MSG_TYPE_TEXT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MsgType_entries[] = {
  { {MsgType_names + 0, 14}, 2 },
  { {MsgType_names + 14, 13}, 1 },
};

static const int MsgType_entries_by_number[] = {
  1, // 1 -> MSG_TYPE_TEXT
  0, // 2 -> MSG_TYPE_AUDIO
};

const std::string& MsgType_Name(
    MsgType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          MsgType_entries,
          MsgType_entries_by_number,
          2, MsgType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      MsgType_entries,
      MsgType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     MsgType_strings[idx].get();
}
bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      MsgType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<MsgType>(int_value);
  }
  return success;
}
bool ClientType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientType_strings[5] = {};

static const char ClientType_names[] =
  "CLIENT_TYPE_ANDROID"
  "CLIENT_TYPE_IOS"
  "CLIENT_TYPE_MAC"
  "CLIENT_TYPE_PC"
  "CLIENT_TYPE_WEB";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientType_entries[] = {
  { {ClientType_names + 0, 19}, 18 },
  { {ClientType_names + 19, 15}, 17 },
  { {ClientType_names + 34, 15}, 3 },
  { {ClientType_names + 49, 14}, 2 },
  { {ClientType_names + 63, 15}, 1 },
};

static const int ClientType_entries_by_number[] = {
  4, // 1 -> CLIENT_TYPE_WEB
  3, // 2 -> CLIENT_TYPE_PC
  2, // 3 -> CLIENT_TYPE_MAC
  1, // 17 -> CLIENT_TYPE_IOS
  0, // 18 -> CLIENT_TYPE_ANDROID
};

const std::string& ClientType_Name(
    ClientType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientType_entries,
          ClientType_entries_by_number,
          5, ClientType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientType_entries,
      ClientType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientType_strings[idx].get();
}
bool ClientType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ClientType>(int_value);
  }
  return success;
}
bool SessionStat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionStat_strings[2] = {};

static const char SessionStat_names[] =
  "SESSION_STAT_DELETE"
  "SESSION_STAT_OK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionStat_entries[] = {
  { {SessionStat_names + 0, 19}, 1 },
  { {SessionStat_names + 19, 15}, 0 },
};

static const int SessionStat_entries_by_number[] = {
  1, // 0 -> SESSION_STAT_OK
  0, // 1 -> SESSION_STAT_DELETE
};

const std::string& SessionStat_Name(
    SessionStat value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SessionStat_entries,
          SessionStat_entries_by_number,
          2, SessionStat_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SessionStat_entries,
      SessionStat_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SessionStat_strings[idx].get();
}
bool SessionStat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionStat* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SessionStat_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<SessionStat>(int_value);
  }
  return success;
}
bool ShieldStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ShieldStatus_strings[2] = {};

static const char ShieldStatus_names[] =
  "SHIELD_STATUS_DELETE"
  "SHIELD_STATUS_OK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ShieldStatus_entries[] = {
  { {ShieldStatus_names + 0, 20}, 1 },
  { {ShieldStatus_names + 20, 16}, 0 },
};

static const int ShieldStatus_entries_by_number[] = {
  1, // 0 -> SHIELD_STATUS_OK
  0, // 1 -> SHIELD_STATUS_DELETE
};

const std::string& ShieldStatus_Name(
    ShieldStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ShieldStatus_entries,
          ShieldStatus_entries_by_number,
          2, ShieldStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ShieldStatus_entries,
      ShieldStatus_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ShieldStatus_strings[idx].get();
}
bool ShieldStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShieldStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ShieldStatus_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<ShieldStatus>(int_value);
  }
  return success;
}
bool BuddyModifyAction_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BuddyModifyAction_strings[6] = {};

static const char BuddyModifyAction_names[] =
  "BuddyModifyAction_avatar"
  "BuddyModifyAction_first_name"
  "BuddyModifyAction_last_name"
  "BuddyModifyAction_nickname"
  "BuddyModifyAction_sign_info"
  "BuddyModifyAction_user_name";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BuddyModifyAction_entries[] = {
  { {BuddyModifyAction_names + 0, 24}, 2 },
  { {BuddyModifyAction_names + 24, 28}, 5 },
  { {BuddyModifyAction_names + 52, 27}, 6 },
  { {BuddyModifyAction_names + 79, 26}, 1 },
  { {BuddyModifyAction_names + 105, 27}, 3 },
  { {BuddyModifyAction_names + 132, 27}, 4 },
};

static const int BuddyModifyAction_entries_by_number[] = {
  3, // 1 -> BuddyModifyAction_nickname
  0, // 2 -> BuddyModifyAction_avatar
  4, // 3 -> BuddyModifyAction_sign_info
  5, // 4 -> BuddyModifyAction_user_name
  1, // 5 -> BuddyModifyAction_first_name
  2, // 6 -> BuddyModifyAction_last_name
};

const std::string& BuddyModifyAction_Name(
    BuddyModifyAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BuddyModifyAction_entries,
          BuddyModifyAction_entries_by_number,
          6, BuddyModifyAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BuddyModifyAction_entries,
      BuddyModifyAction_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BuddyModifyAction_strings[idx].get();
}
bool BuddyModifyAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BuddyModifyAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BuddyModifyAction_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<BuddyModifyAction>(int_value);
  }
  return success;
}
bool GroupType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupType_strings[2] = {};

static const char GroupType_names[] =
  "GROUP_TYPE_MULTI"
  "GROUP_TYPE_PAIR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupType_entries[] = {
  { {GroupType_names + 0, 16}, 2 },
  { {GroupType_names + 16, 15}, 1 },
};

static const int GroupType_entries_by_number[] = {
  1, // 1 -> GROUP_TYPE_PAIR
  0, // 2 -> GROUP_TYPE_MULTI
};

const std::string& GroupType_Name(
    GroupType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupType_entries,
          GroupType_entries_by_number,
          2, GroupType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupType_entries,
      GroupType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupType_strings[idx].get();
}
bool GroupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GroupType>(int_value);
  }
  return success;
}
bool GroupMemberStatus_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupMemberStatus_strings[1] = {};

static const char GroupMemberStatus_names[] =
  "GROUP_MEMBER_STATUS_NORMAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupMemberStatus_entries[] = {
  { {GroupMemberStatus_names + 0, 26}, 1 },
};

static const int GroupMemberStatus_entries_by_number[] = {
  0, // 1 -> GROUP_MEMBER_STATUS_NORMAL
};

const std::string& GroupMemberStatus_Name(
    GroupMemberStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupMemberStatus_entries,
          GroupMemberStatus_entries_by_number,
          1, GroupMemberStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupMemberStatus_entries,
      GroupMemberStatus_entries_by_number,
      1, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupMemberStatus_strings[idx].get();
}
bool GroupMemberStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupMemberStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupMemberStatus_entries, 1, name, &int_value);
  if (success) {
    *value = static_cast<GroupMemberStatus>(int_value);
  }
  return success;
}
bool GroupModifyAction_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupModifyAction_strings[2] = {};

static const char GroupModifyAction_names[] =
  "GroupModifyAction_avatar"
  "GroupModifyAction_name";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupModifyAction_entries[] = {
  { {GroupModifyAction_names + 0, 24}, 2 },
  { {GroupModifyAction_names + 24, 22}, 1 },
};

static const int GroupModifyAction_entries_by_number[] = {
  1, // 1 -> GroupModifyAction_name
  0, // 2 -> GroupModifyAction_avatar
};

const std::string& GroupModifyAction_Name(
    GroupModifyAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupModifyAction_entries,
          GroupModifyAction_entries_by_number,
          2, GroupModifyAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupModifyAction_entries,
      GroupModifyAction_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupModifyAction_strings[idx].get();
}
bool GroupModifyAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupModifyAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupModifyAction_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GroupModifyAction>(int_value);
  }
  return success;
}
bool GroupMemberModifyAction_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GroupMemberModifyAction_strings[2] = {};

static const char GroupMemberModifyAction_names[] =
  "GroupMemberModifyAction_ADD"
  "GroupMemberModifyAction_DEL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GroupMemberModifyAction_entries[] = {
  { {GroupMemberModifyAction_names + 0, 27}, 2 },
  { {GroupMemberModifyAction_names + 27, 27}, 1 },
};

static const int GroupMemberModifyAction_entries_by_number[] = {
  1, // 1 -> GroupMemberModifyAction_DEL
  0, // 2 -> GroupMemberModifyAction_ADD
};

const std::string& GroupMemberModifyAction_Name(
    GroupMemberModifyAction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GroupMemberModifyAction_entries,
          GroupMemberModifyAction_entries_by_number,
          2, GroupMemberModifyAction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GroupMemberModifyAction_entries,
      GroupMemberModifyAction_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GroupMemberModifyAction_strings[idx].get();
}
bool GroupMemberModifyAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GroupMemberModifyAction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GroupMemberModifyAction_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GroupMemberModifyAction>(int_value);
  }
  return success;
}

// ===================================================================

class IpAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<IpAddress>()._impl_._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

IpAddress::IpAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.IpAddress)
}
IpAddress::IpAddress(const IpAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  IpAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.port_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    _this->_impl_.ip_.Set(from._internal_ip(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:PTP.Common.IpAddress)
}

inline void IpAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_){}
    , decltype(_impl_.port_){0u}
  };
  _impl_.ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IpAddress::~IpAddress() {
  // @@protoc_insertion_point(destructor:PTP.Common.IpAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IpAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ip_.Destroy();
}

void IpAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IpAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.IpAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.ip_.ClearNonDefaultToEmpty();
  }
  _impl_.port_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* IpAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IpAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.IpAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // required uint32 port = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.IpAddress)
  return target;
}

size_t IpAddress::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Common.IpAddress)
  size_t total_size = 0;

  if (_internal_has_ip()) {
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  if (_internal_has_port()) {
    // required uint32 port = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
  }

  return total_size;
}
size_t IpAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.IpAddress)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string ip = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());

    // required uint32 port = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IpAddress::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const IpAddress*>(
      &from));
}

void IpAddress::MergeFrom(const IpAddress& from) {
  IpAddress* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.IpAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ip(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IpAddress::CopyFrom(const IpAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.IpAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpAddress::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void IpAddress::InternalSwap(IpAddress* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ip_, lhs_arena,
      &other->_impl_.ip_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

std::string IpAddress::GetTypeName() const {
  return "PTP.Common.IpAddress";
}


// ===================================================================

class UserInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UserInfo>()._impl_._has_bits_);
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pub_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_avatar(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nick_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sign_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_first_name(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_last_name(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_login_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_is_online(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000307) ^ 0x00000307) != 0;
  }
};

UserInfo::UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.UserInfo)
}
UserInfo::UserInfo(const UserInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_){}
    , decltype(_impl_.pub_key_){}
    , decltype(_impl_.avatar_){}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.nick_name_){}
    , decltype(_impl_.sign_info_){}
    , decltype(_impl_.first_name_){}
    , decltype(_impl_.last_name_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.login_time_){}
    , decltype(_impl_.is_online_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pub_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pub_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pub_key()) {
    _this->_impl_.pub_key_.Set(from._internal_pub_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar()) {
    _this->_impl_.avatar_.Set(from._internal_avatar(), 
      _this->GetArenaForAllocation());
  }
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    _this->_impl_.user_name_.Set(from._internal_user_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.nick_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nick_name()) {
    _this->_impl_.nick_name_.Set(from._internal_nick_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sign_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sign_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sign_info()) {
    _this->_impl_.sign_info_.Set(from._internal_sign_info(), 
      _this->GetArenaForAllocation());
  }
  _impl_.first_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_first_name()) {
    _this->_impl_.first_name_.Set(from._internal_first_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.last_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_last_name()) {
    _this->_impl_.last_name_.Set(from._internal_last_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.status_, &from._impl_.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_online_) -
    reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.is_online_));
  // @@protoc_insertion_point(copy_constructor:PTP.Common.UserInfo)
}

inline void UserInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.address_){}
    , decltype(_impl_.pub_key_){}
    , decltype(_impl_.avatar_){}
    , decltype(_impl_.user_name_){}
    , decltype(_impl_.nick_name_){}
    , decltype(_impl_.sign_info_){}
    , decltype(_impl_.first_name_){}
    , decltype(_impl_.last_name_){}
    , decltype(_impl_.status_){0u}
    , decltype(_impl_.uid_){0u}
    , decltype(_impl_.login_time_){0u}
    , decltype(_impl_.is_online_){false}
  };
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pub_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pub_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nick_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nick_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sign_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sign_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.first_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.last_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserInfo::~UserInfo() {
  // @@protoc_insertion_point(destructor:PTP.Common.UserInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.address_.Destroy();
  _impl_.pub_key_.Destroy();
  _impl_.avatar_.Destroy();
  _impl_.user_name_.Destroy();
  _impl_.nick_name_.Destroy();
  _impl_.sign_info_.Destroy();
  _impl_.first_name_.Destroy();
  _impl_.last_name_.Destroy();
}

void UserInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.UserInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pub_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.avatar_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.nick_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.sign_info_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.first_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.last_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_online_) -
        reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.is_online_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes pub_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_pub_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string avatar = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_avatar();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_user_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string nick_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_nick_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string sign_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_sign_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 uid = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_uid(&has_bits);
          _impl_.uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string first_name = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_first_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string last_name = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_last_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 login_time = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_login_time(&has_bits);
          _impl_.login_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_online = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_is_online(&has_bits);
          _impl_.is_online_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.UserInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string address = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_address(), target);
  }

  // required bytes pub_key = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_pub_key(), target);
  }

  // required string avatar = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_avatar(), target);
  }

  // required uint32 status = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_status(), target);
  }

  // optional string user_name = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_user_name(), target);
  }

  // optional string nick_name = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_nick_name(), target);
  }

  // optional string sign_info = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_sign_info(), target);
  }

  // required uint32 uid = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_uid(), target);
  }

  // optional string first_name = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_first_name(), target);
  }

  // optional string last_name = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_last_name(), target);
  }

  // optional uint32 login_time = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_login_time(), target);
  }

  // optional bool is_online = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_is_online(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.UserInfo)
  return target;
}

size_t UserInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Common.UserInfo)
  size_t total_size = 0;

  if (_internal_has_address()) {
    // required string address = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_address());
  }

  if (_internal_has_pub_key()) {
    // required bytes pub_key = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_pub_key());
  }

  if (_internal_has_avatar()) {
    // required string avatar = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar());
  }

  if (_internal_has_status()) {
    // required uint32 status = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status());
  }

  if (_internal_has_uid()) {
    // required uint32 uid = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uid());
  }

  return total_size;
}
size_t UserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.UserInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000307) ^ 0x00000307) == 0) {  // All required fields are present.
    // required string address = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_address());

    // required bytes pub_key = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_pub_key());

    // required string avatar = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar());

    // required uint32 status = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status());

    // required uint32 uid = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000f8u) {
    // optional string user_name = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional string nick_name = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nick_name());
    }

    // optional string sign_info = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sign_info());
    }

    // optional string first_name = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_first_name());
    }

    // optional string last_name = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_last_name());
    }

  }
  if (cached_has_bits & 0x00000c00u) {
    // optional uint32 login_time = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_login_time());
    }

    // optional bool is_online = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserInfo*>(
      &from));
}

void UserInfo::MergeFrom(const UserInfo& from) {
  UserInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.UserInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pub_key(from._internal_pub_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_avatar(from._internal_avatar());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_nick_name(from._internal_nick_name());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_sign_info(from._internal_sign_info());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_first_name(from._internal_first_name());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_last_name(from._internal_last_name());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.uid_ = from._impl_.uid_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.login_time_ = from._impl_.login_time_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.is_online_ = from._impl_.is_online_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserInfo::CopyFrom(const UserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.UserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UserInfo::InternalSwap(UserInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pub_key_, lhs_arena,
      &other->_impl_.pub_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.avatar_, lhs_arena,
      &other->_impl_.avatar_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_name_, lhs_arena,
      &other->_impl_.user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.nick_name_, lhs_arena,
      &other->_impl_.nick_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sign_info_, lhs_arena,
      &other->_impl_.sign_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.first_name_, lhs_arena,
      &other->_impl_.first_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.last_name_, lhs_arena,
      &other->_impl_.last_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserInfo, _impl_.is_online_)
      + sizeof(UserInfo::_impl_.is_online_)
      - PROTOBUF_FIELD_OFFSET(UserInfo, _impl_.status_)>(
          reinterpret_cast<char*>(&_impl_.status_),
          reinterpret_cast<char*>(&other->_impl_.status_));
}

std::string UserInfo::GetTypeName() const {
  return "PTP.Common.UserInfo";
}


// ===================================================================

class UserStatInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<UserStatInfo>()._impl_._has_bits_);
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

UserStatInfo::UserStatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.UserStatInfo)
}
UserStatInfo::UserStatInfo(const UserStatInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  UserStatInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.uid_, &from._impl_.uid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) -
    reinterpret_cast<char*>(&_impl_.uid_)) + sizeof(_impl_.status_));
  // @@protoc_insertion_point(copy_constructor:PTP.Common.UserStatInfo)
}

inline void UserStatInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uid_){0u}
    , decltype(_impl_.status_){1}
  };
}

UserStatInfo::~UserStatInfo() {
  // @@protoc_insertion_point(destructor:PTP.Common.UserStatInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserStatInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserStatInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserStatInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.UserStatInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.uid_ = 0u;
    _impl_.status_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* UserStatInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 uid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_uid(&has_bits);
          _impl_.uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.UserStat status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::UserStat_IsValid(val))) {
            _internal_set_status(static_cast<::PTP::Common::UserStat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserStatInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.UserStatInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 uid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_uid(), target);
  }

  // required .PTP.Common.UserStat status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.UserStatInfo)
  return target;
}

size_t UserStatInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Common.UserStatInfo)
  size_t total_size = 0;

  if (_internal_has_uid()) {
    // required uint32 uid = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uid());
  }

  if (_internal_has_status()) {
    // required .PTP.Common.UserStat status = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t UserStatInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.UserStatInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 uid = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uid());

    // required .PTP.Common.UserStat status = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserStatInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const UserStatInfo*>(
      &from));
}

void UserStatInfo::MergeFrom(const UserStatInfo& from) {
  UserStatInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.UserStatInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.uid_ = from._impl_.uid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserStatInfo::CopyFrom(const UserStatInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.UserStatInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserStatInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UserStatInfo::InternalSwap(UserStatInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.uid_, other->_impl_.uid_);
  swap(_impl_.status_, other->_impl_.status_);
}

std::string UserStatInfo::GetTypeName() const {
  return "PTP.Common.UserStatInfo";
}


// ===================================================================

class MsgInfoList::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgInfoList>()._impl_._has_bits_);
  static void set_has_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sent_at(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000037) ^ 0x00000037) != 0;
  }
};

MsgInfoList::MsgInfoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.MsgInfoList)
}
MsgInfoList::MsgInfoList(const MsgInfoList& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgInfoList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.msg_id_){}
    , decltype(_impl_.from_uid_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.sent_at_){}
    , decltype(_impl_.msg_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg_data()) {
    _this->_impl_.msg_data_.Set(from._internal_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.msg_id_, &from._impl_.msg_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.msg_type_) -
    reinterpret_cast<char*>(&_impl_.msg_id_)) + sizeof(_impl_.msg_type_));
  // @@protoc_insertion_point(copy_constructor:PTP.Common.MsgInfoList)
}

inline void MsgInfoList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.msg_id_){0u}
    , decltype(_impl_.from_uid_){0u}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.sent_at_){0u}
    , decltype(_impl_.msg_type_){1}
  };
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgInfoList::~MsgInfoList() {
  // @@protoc_insertion_point(destructor:PTP.Common.MsgInfoList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgInfoList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_data_.Destroy();
}

void MsgInfoList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgInfoList::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.MsgInfoList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.msg_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sent_at_) -
        reinterpret_cast<char*>(&_impl_.msg_id_)) + sizeof(_impl_.sent_at_));
    _impl_.msg_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgInfoList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 msg_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_id(&has_bits);
          _impl_.msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 from_uid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_from_uid(&has_bits);
          _impl_.from_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 group_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 sent_at = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_sent_at(&has_bits);
          _impl_.sent_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.MsgType msg_type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::MsgType_IsValid(val))) {
            _internal_set_msg_type(static_cast<::PTP::Common::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string msg_data = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgInfoList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.MsgInfoList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 msg_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_msg_id(), target);
  }

  // required uint32 from_uid = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_from_uid(), target);
  }

  // optional uint32 group_id = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_group_id(), target);
  }

  // required uint32 sent_at = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_sent_at(), target);
  }

  // required .PTP.Common.MsgType msg_type = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_msg_type(), target);
  }

  // required string msg_data = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_msg_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.MsgInfoList)
  return target;
}

size_t MsgInfoList::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Common.MsgInfoList)
  size_t total_size = 0;

  if (_internal_has_msg_data()) {
    // required string msg_data = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_msg_data());
  }

  if (_internal_has_msg_id()) {
    // required uint32 msg_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
  }

  if (_internal_has_from_uid()) {
    // required uint32 from_uid = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_uid());
  }

  if (_internal_has_sent_at()) {
    // required uint32 sent_at = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sent_at());
  }

  if (_internal_has_msg_type()) {
    // required .PTP.Common.MsgType msg_type = 7;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_type());
  }

  return total_size;
}
size_t MsgInfoList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.MsgInfoList)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000037) ^ 0x00000037) == 0) {  // All required fields are present.
    // required string msg_data = 8;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_msg_data());

    // required uint32 msg_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());

    // required uint32 from_uid = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_uid());

    // required uint32 sent_at = 6;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sent_at());

    // required .PTP.Common.MsgType msg_type = 7;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 group_id = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgInfoList::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgInfoList*>(
      &from));
}

void MsgInfoList::MergeFrom(const MsgInfoList& from) {
  MsgInfoList* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.MsgInfoList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_msg_data(from._internal_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msg_id_ = from._impl_.msg_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.from_uid_ = from._impl_.from_uid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sent_at_ = from._impl_.sent_at_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgInfoList::CopyFrom(const MsgInfoList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.MsgInfoList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgInfoList::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MsgInfoList::InternalSwap(MsgInfoList* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_data_, lhs_arena,
      &other->_impl_.msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgInfoList, _impl_.sent_at_)
      + sizeof(MsgInfoList::_impl_.sent_at_)
      - PROTOBUF_FIELD_OFFSET(MsgInfoList, _impl_.msg_id_)>(
          reinterpret_cast<char*>(&_impl_.msg_id_),
          reinterpret_cast<char*>(&other->_impl_.msg_id_));
  swap(_impl_.msg_type_, other->_impl_.msg_type_);
}

std::string MsgInfoList::GetTypeName() const {
  return "PTP.Common.MsgInfoList";
}


// ===================================================================

class GroupMember::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupMember>()._impl_._has_bits_);
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_member_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

GroupMember::GroupMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.GroupMember)
}
GroupMember::GroupMember(const GroupMember& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupMember* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.member_status_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.uid_, &from._impl_.uid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.member_status_) -
    reinterpret_cast<char*>(&_impl_.uid_)) + sizeof(_impl_.member_status_));
  // @@protoc_insertion_point(copy_constructor:PTP.Common.GroupMember)
}

inline void GroupMember::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.uid_){0u}
    , decltype(_impl_.member_status_){1}
  };
}

GroupMember::~GroupMember() {
  // @@protoc_insertion_point(destructor:PTP.Common.GroupMember)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupMember::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GroupMember::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupMember::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.GroupMember)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.uid_ = 0u;
    _impl_.member_status_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupMember::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 uid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_uid(&has_bits);
          _impl_.uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.GroupMemberStatus member_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupMemberStatus_IsValid(val))) {
            _internal_set_member_status(static_cast<::PTP::Common::GroupMemberStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupMember::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.GroupMember)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 uid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_uid(), target);
  }

  // required .PTP.Common.GroupMemberStatus member_status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_member_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.GroupMember)
  return target;
}

size_t GroupMember::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Common.GroupMember)
  size_t total_size = 0;

  if (_internal_has_uid()) {
    // required uint32 uid = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uid());
  }

  if (_internal_has_member_status()) {
    // required .PTP.Common.GroupMemberStatus member_status = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_member_status());
  }

  return total_size;
}
size_t GroupMember::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.GroupMember)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 uid = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uid());

    // required .PTP.Common.GroupMemberStatus member_status = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_member_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupMember::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupMember*>(
      &from));
}

void GroupMember::MergeFrom(const GroupMember& from) {
  GroupMember* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.GroupMember)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.uid_ = from._impl_.uid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.member_status_ = from._impl_.member_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupMember::CopyFrom(const GroupMember& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.GroupMember)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupMember::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupMember::InternalSwap(GroupMember* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.uid_, other->_impl_.uid_);
  swap(_impl_.member_status_, other->_impl_.member_status_);
}

std::string GroupMember::GetTypeName() const {
  return "PTP.Common.GroupMember";
}


// ===================================================================

class GroupRecord::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupRecord>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_avatar(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_group_adr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_group_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_pair_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_owner_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_unreadcnt(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_lastmsgid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_msguptime(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_memberuptime(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000767) ^ 0x00000767) != 0;
  }
};

GroupRecord::GroupRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.GroupRecord)
}
GroupRecord::GroupRecord(const GroupRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupRecord* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.avatar_){}
    , decltype(_impl_.group_adr_){}
    , decltype(_impl_.pair_uid_){}
    , decltype(_impl_.owner_uid_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.unreadcnt_){}
    , decltype(_impl_.lastmsgid_){}
    , decltype(_impl_.msguptime_){}
    , decltype(_impl_.memberuptime_){}
    , decltype(_impl_.group_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar()) {
    _this->_impl_.avatar_.Set(from._internal_avatar(), 
      _this->GetArenaForAllocation());
  }
  _impl_.group_adr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_adr()) {
    _this->_impl_.group_adr_.Set(from._internal_group_adr(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.pair_uid_, &from._impl_.pair_uid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.group_type_) -
    reinterpret_cast<char*>(&_impl_.pair_uid_)) + sizeof(_impl_.group_type_));
  // @@protoc_insertion_point(copy_constructor:PTP.Common.GroupRecord)
}

inline void GroupRecord::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.avatar_){}
    , decltype(_impl_.group_adr_){}
    , decltype(_impl_.pair_uid_){0u}
    , decltype(_impl_.owner_uid_){0u}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.unreadcnt_){0u}
    , decltype(_impl_.lastmsgid_){0u}
    , decltype(_impl_.msguptime_){0u}
    , decltype(_impl_.memberuptime_){0u}
    , decltype(_impl_.group_type_){1}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.group_adr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupRecord::~GroupRecord() {
  // @@protoc_insertion_point(destructor:PTP.Common.GroupRecord)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupRecord::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.avatar_.Destroy();
  _impl_.group_adr_.Destroy();
}

void GroupRecord::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.GroupRecord)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.avatar_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.group_adr_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.pair_uid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.lastmsgid_) -
        reinterpret_cast<char*>(&_impl_.pair_uid_)) + sizeof(_impl_.lastmsgid_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.msguptime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.memberuptime_) -
        reinterpret_cast<char*>(&_impl_.msguptime_)) + sizeof(_impl_.memberuptime_));
    _impl_.group_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupRecord::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string avatar = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_avatar();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string group_adr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_group_adr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.GroupType group_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupType_IsValid(val))) {
            _internal_set_group_type(static_cast<::PTP::Common::GroupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pair_uid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pair_uid(&has_bits);
          _impl_.pair_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 owner_uid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_owner_uid(&has_bits);
          _impl_.owner_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 unReadCnt = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_unreadcnt(&has_bits);
          _impl_.unreadcnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lastMsgId = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_lastmsgid(&has_bits);
          _impl_.lastmsgid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 msgUpTime = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_msguptime(&has_bits);
          _impl_.msguptime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 memberUpTime = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_memberuptime(&has_bits);
          _impl_.memberuptime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupRecord::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.GroupRecord)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required string avatar = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_avatar(), target);
  }

  // required string group_adr = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_group_adr(), target);
  }

  // required .PTP.Common.GroupType group_type = 4;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_group_type(), target);
  }

  // optional uint32 pair_uid = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_pair_uid(), target);
  }

  // optional uint32 owner_uid = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_owner_uid(), target);
  }

  // required uint32 group_id = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_group_id(), target);
  }

  // required uint32 unReadCnt = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_unreadcnt(), target);
  }

  // optional uint32 lastMsgId = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_lastmsgid(), target);
  }

  // required uint32 msgUpTime = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_msguptime(), target);
  }

  // required uint32 memberUpTime = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_memberuptime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.GroupRecord)
  return target;
}

size_t GroupRecord::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Common.GroupRecord)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_avatar()) {
    // required string avatar = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar());
  }

  if (_internal_has_group_adr()) {
    // required string group_adr = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_adr());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_unreadcnt()) {
    // required uint32 unReadCnt = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unreadcnt());
  }

  if (_internal_has_msguptime()) {
    // required uint32 msgUpTime = 11;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msguptime());
  }

  if (_internal_has_memberuptime()) {
    // required uint32 memberUpTime = 12;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_memberuptime());
  }

  if (_internal_has_group_type()) {
    // required .PTP.Common.GroupType group_type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_type());
  }

  return total_size;
}
size_t GroupRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.GroupRecord)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000767) ^ 0x00000767) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required string avatar = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar());

    // required string group_adr = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_adr());

    // required uint32 group_id = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 unReadCnt = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unreadcnt());

    // required uint32 msgUpTime = 11;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msguptime());

    // required uint32 memberUpTime = 12;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_memberuptime());

    // required .PTP.Common.GroupType group_type = 4;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional uint32 pair_uid = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pair_uid());
    }

    // optional uint32 owner_uid = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_owner_uid());
    }

  }
  // optional uint32 lastMsgId = 9;
  if (cached_has_bits & 0x00000080u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lastmsgid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupRecord::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupRecord*>(
      &from));
}

void GroupRecord::MergeFrom(const GroupRecord& from) {
  GroupRecord* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.GroupRecord)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_avatar(from._internal_avatar());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_group_adr(from._internal_group_adr());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.pair_uid_ = from._impl_.pair_uid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.owner_uid_ = from._impl_.owner_uid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.unreadcnt_ = from._impl_.unreadcnt_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.lastmsgid_ = from._impl_.lastmsgid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.msguptime_ = from._impl_.msguptime_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.memberuptime_ = from._impl_.memberuptime_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.group_type_ = from._impl_.group_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupRecord::CopyFrom(const GroupRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.GroupRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupRecord::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupRecord::InternalSwap(GroupRecord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.avatar_, lhs_arena,
      &other->_impl_.avatar_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.group_adr_, lhs_arena,
      &other->_impl_.group_adr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupRecord, _impl_.memberuptime_)
      + sizeof(GroupRecord::_impl_.memberuptime_)
      - PROTOBUF_FIELD_OFFSET(GroupRecord, _impl_.pair_uid_)>(
          reinterpret_cast<char*>(&_impl_.pair_uid_),
          reinterpret_cast<char*>(&other->_impl_.pair_uid_));
  swap(_impl_.group_type_, other->_impl_.group_type_);
}

std::string GroupRecord::GetTypeName() const {
  return "PTP.Common.GroupRecord";
}


// ===================================================================

class GroupInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GroupInfo>()._impl_._has_bits_);
  static void set_has_group_adr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_avatar(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_owner_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_pair_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_group_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_group_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_created_time(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_updated_time(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_about(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000007df) ^ 0x000007df) != 0;
  }
};

GroupInfo::GroupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.GroupInfo)
}
GroupInfo::GroupInfo(const GroupInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  GroupInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_adr_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.avatar_){}
    , decltype(_impl_.about_){}
    , decltype(_impl_.owner_uid_){}
    , decltype(_impl_.pair_uid_){}
    , decltype(_impl_.group_idx_){}
    , decltype(_impl_.created_time_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.updated_time_){}
    , decltype(_impl_.group_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.group_adr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group_adr()) {
    _this->_impl_.group_adr_.Set(from._internal_group_adr(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar()) {
    _this->_impl_.avatar_.Set(from._internal_avatar(), 
      _this->GetArenaForAllocation());
  }
  _impl_.about_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.about_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_about()) {
    _this->_impl_.about_.Set(from._internal_about(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.owner_uid_, &from._impl_.owner_uid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.group_type_) -
    reinterpret_cast<char*>(&_impl_.owner_uid_)) + sizeof(_impl_.group_type_));
  // @@protoc_insertion_point(copy_constructor:PTP.Common.GroupInfo)
}

inline void GroupInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.group_adr_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.avatar_){}
    , decltype(_impl_.about_){}
    , decltype(_impl_.owner_uid_){0u}
    , decltype(_impl_.pair_uid_){0u}
    , decltype(_impl_.group_idx_){0u}
    , decltype(_impl_.created_time_){0u}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.updated_time_){0u}
    , decltype(_impl_.group_type_){1}
  };
  _impl_.group_adr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.group_adr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.avatar_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.about_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.about_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GroupInfo::~GroupInfo() {
  // @@protoc_insertion_point(destructor:PTP.Common.GroupInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GroupInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.group_adr_.Destroy();
  _impl_.name_.Destroy();
  _impl_.avatar_.Destroy();
  _impl_.about_.Destroy();
}

void GroupInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GroupInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.GroupInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.group_adr_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.avatar_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.about_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.owner_uid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.created_time_) -
        reinterpret_cast<char*>(&_impl_.owner_uid_)) + sizeof(_impl_.created_time_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.updated_time_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.updated_time_));
    _impl_.group_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GroupInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string group_adr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_group_adr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string avatar = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_avatar();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 owner_uid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_owner_uid(&has_bits);
          _impl_.owner_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pair_uid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_pair_uid(&has_bits);
          _impl_.pair_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.GroupType group_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::GroupType_IsValid(val))) {
            _internal_set_group_type(static_cast<::PTP::Common::GroupType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_idx = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_group_idx(&has_bits);
          _impl_.group_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 created_time = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_created_time(&has_bits);
          _impl_.created_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 group_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 updated_time = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_updated_time(&has_bits);
          _impl_.updated_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string about = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_about();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GroupInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.GroupInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string group_adr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_group_adr(), target);
  }

  // required string name = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // required string avatar = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_avatar(), target);
  }

  // required uint32 owner_uid = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_owner_uid(), target);
  }

  // optional uint32 pair_uid = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_pair_uid(), target);
  }

  // required .PTP.Common.GroupType group_type = 6;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_group_type(), target);
  }

  // required uint32 group_idx = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_group_idx(), target);
  }

  // required uint32 created_time = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_created_time(), target);
  }

  // required uint32 group_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_group_id(), target);
  }

  // required uint32 updated_time = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_updated_time(), target);
  }

  // required string about = 11;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_about(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.GroupInfo)
  return target;
}

size_t GroupInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Common.GroupInfo)
  size_t total_size = 0;

  if (_internal_has_group_adr()) {
    // required string group_adr = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_adr());
  }

  if (_internal_has_name()) {
    // required string name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_avatar()) {
    // required string avatar = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar());
  }

  if (_internal_has_about()) {
    // required string about = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_about());
  }

  if (_internal_has_owner_uid()) {
    // required uint32 owner_uid = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_owner_uid());
  }

  if (_internal_has_group_idx()) {
    // required uint32 group_idx = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_idx());
  }

  if (_internal_has_created_time()) {
    // required uint32 created_time = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_created_time());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 9;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_updated_time()) {
    // required uint32 updated_time = 10;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_updated_time());
  }

  if (_internal_has_group_type()) {
    // required .PTP.Common.GroupType group_type = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_type());
  }

  return total_size;
}
size_t GroupInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.GroupInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000007df) ^ 0x000007df) == 0) {  // All required fields are present.
    // required string group_adr = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_group_adr());

    // required string name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required string avatar = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_avatar());

    // required string about = 11;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_about());

    // required uint32 owner_uid = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_owner_uid());

    // required uint32 group_idx = 7;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_idx());

    // required uint32 created_time = 8;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_created_time());

    // required uint32 group_id = 9;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 updated_time = 10;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_updated_time());

    // required .PTP.Common.GroupType group_type = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_group_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 pair_uid = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000020u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pair_uid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GroupInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GroupInfo*>(
      &from));
}

void GroupInfo::MergeFrom(const GroupInfo& from) {
  GroupInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.GroupInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_group_adr(from._internal_group_adr());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_avatar(from._internal_avatar());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_about(from._internal_about());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.owner_uid_ = from._impl_.owner_uid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.pair_uid_ = from._impl_.pair_uid_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.group_idx_ = from._impl_.group_idx_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.created_time_ = from._impl_.created_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.updated_time_ = from._impl_.updated_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.group_type_ = from._impl_.group_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GroupInfo::CopyFrom(const GroupInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.GroupInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void GroupInfo::InternalSwap(GroupInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.group_adr_, lhs_arena,
      &other->_impl_.group_adr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.avatar_, lhs_arena,
      &other->_impl_.avatar_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.about_, lhs_arena,
      &other->_impl_.about_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GroupInfo, _impl_.updated_time_)
      + sizeof(GroupInfo::_impl_.updated_time_)
      - PROTOBUF_FIELD_OFFSET(GroupInfo, _impl_.owner_uid_)>(
          reinterpret_cast<char*>(&_impl_.owner_uid_),
          reinterpret_cast<char*>(&other->_impl_.owner_uid_));
  swap(_impl_.group_type_, other->_impl_.group_type_);
}

std::string GroupInfo::GetTypeName() const {
  return "PTP.Common.GroupInfo";
}


// ===================================================================

class MsgInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgInfo>()._impl_._has_bits_);
  static void set_has_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_from_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sent_at(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_msg_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

MsgInfo::MsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.MsgInfo)
}
MsgInfo::MsgInfo(const MsgInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MsgInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.group_id_){}
    , decltype(_impl_.from_uid_){}
    , decltype(_impl_.sent_at_){}
    , decltype(_impl_.msg_id_){}
    , decltype(_impl_.msg_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg_data()) {
    _this->_impl_.msg_data_.Set(from._internal_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.group_id_, &from._impl_.group_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.msg_type_) -
    reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.msg_type_));
  // @@protoc_insertion_point(copy_constructor:PTP.Common.MsgInfo)
}

inline void MsgInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.group_id_){0u}
    , decltype(_impl_.from_uid_){0u}
    , decltype(_impl_.sent_at_){0u}
    , decltype(_impl_.msg_id_){0u}
    , decltype(_impl_.msg_type_){1}
  };
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MsgInfo::~MsgInfo() {
  // @@protoc_insertion_point(destructor:PTP.Common.MsgInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MsgInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_data_.Destroy();
}

void MsgInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MsgInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.MsgInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.group_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.msg_id_) -
        reinterpret_cast<char*>(&_impl_.group_id_)) + sizeof(_impl_.msg_id_));
    _impl_.msg_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MsgInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 group_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_group_id(&has_bits);
          _impl_.group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 from_uid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_from_uid(&has_bits);
          _impl_.from_uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 sent_at = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sent_at(&has_bits);
          _impl_.sent_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 msg_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_msg_id(&has_bits);
          _impl_.msg_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .PTP.Common.MsgType msg_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::MsgType_IsValid(val))) {
            _internal_set_msg_type(static_cast<::PTP::Common::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string msg_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MsgInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.MsgInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_group_id(), target);
  }

  // required uint32 from_uid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_from_uid(), target);
  }

  // required uint32 sent_at = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sent_at(), target);
  }

  // required uint32 msg_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_msg_id(), target);
  }

  // required .PTP.Common.MsgType msg_type = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_msg_type(), target);
  }

  // required string msg_data = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_msg_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.MsgInfo)
  return target;
}

size_t MsgInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Common.MsgInfo)
  size_t total_size = 0;

  if (_internal_has_msg_data()) {
    // required string msg_data = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_msg_data());
  }

  if (_internal_has_group_id()) {
    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());
  }

  if (_internal_has_from_uid()) {
    // required uint32 from_uid = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_uid());
  }

  if (_internal_has_sent_at()) {
    // required uint32 sent_at = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sent_at());
  }

  if (_internal_has_msg_id()) {
    // required uint32 msg_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());
  }

  if (_internal_has_msg_type()) {
    // required .PTP.Common.MsgType msg_type = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_type());
  }

  return total_size;
}
size_t MsgInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.MsgInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required string msg_data = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_msg_data());

    // required uint32 group_id = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_group_id());

    // required uint32 from_uid = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_from_uid());

    // required uint32 sent_at = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sent_at());

    // required uint32 msg_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_msg_id());

    // required .PTP.Common.MsgType msg_type = 6;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_msg_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MsgInfo*>(
      &from));
}

void MsgInfo::MergeFrom(const MsgInfo& from) {
  MsgInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.MsgInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_msg_data(from._internal_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.group_id_ = from._impl_.group_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.from_uid_ = from._impl_.from_uid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.sent_at_ = from._impl_.sent_at_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.msg_id_ = from._impl_.msg_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MsgInfo::CopyFrom(const MsgInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.MsgInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void MsgInfo::InternalSwap(MsgInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_data_, lhs_arena,
      &other->_impl_.msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgInfo, _impl_.msg_id_)
      + sizeof(MsgInfo::_impl_.msg_id_)
      - PROTOBUF_FIELD_OFFSET(MsgInfo, _impl_.group_id_)>(
          reinterpret_cast<char*>(&_impl_.group_id_),
          reinterpret_cast<char*>(&other->_impl_.group_id_));
  swap(_impl_.msg_type_, other->_impl_.msg_type_);
}

std::string MsgInfo::GetTypeName() const {
  return "PTP.Common.MsgInfo";
}


// ===================================================================

class DevicesInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DevicesInfo>()._impl_._has_bits_);
  static void set_has_client_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_client_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_login_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_browser_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_browser_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_os_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_intel(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000003ff) ^ 0x000003ff) != 0;
  }
};

DevicesInfo::DevicesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.DevicesInfo)
}
DevicesInfo::DevicesInfo(const DevicesInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  DevicesInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_version_){}
    , decltype(_impl_.browser_name_){}
    , decltype(_impl_.browser_version_){}
    , decltype(_impl_.os_name_){}
    , decltype(_impl_.os_version_){}
    , decltype(_impl_.client_id_){}
    , decltype(_impl_.login_time_){}
    , decltype(_impl_.is_intel_){}
    , decltype(_impl_.uid_){}
    , decltype(_impl_.client_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.client_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_version()) {
    _this->_impl_.client_version_.Set(from._internal_client_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.browser_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_browser_name()) {
    _this->_impl_.browser_name_.Set(from._internal_browser_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.browser_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_browser_version()) {
    _this->_impl_.browser_version_.Set(from._internal_browser_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.os_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_name()) {
    _this->_impl_.os_name_.Set(from._internal_os_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_version()) {
    _this->_impl_.os_version_.Set(from._internal_os_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_client_id()) {
    _this->_impl_.client_id_.Set(from._internal_client_id(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.login_time_, &from._impl_.login_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.client_type_) -
    reinterpret_cast<char*>(&_impl_.login_time_)) + sizeof(_impl_.client_type_));
  // @@protoc_insertion_point(copy_constructor:PTP.Common.DevicesInfo)
}

inline void DevicesInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.client_version_){}
    , decltype(_impl_.browser_name_){}
    , decltype(_impl_.browser_version_){}
    , decltype(_impl_.os_name_){}
    , decltype(_impl_.os_version_){}
    , decltype(_impl_.client_id_){}
    , decltype(_impl_.login_time_){0u}
    , decltype(_impl_.is_intel_){false}
    , decltype(_impl_.uid_){0u}
    , decltype(_impl_.client_type_){1}
  };
  _impl_.client_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.browser_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.browser_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.os_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DevicesInfo::~DevicesInfo() {
  // @@protoc_insertion_point(destructor:PTP.Common.DevicesInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DevicesInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.client_version_.Destroy();
  _impl_.browser_name_.Destroy();
  _impl_.browser_version_.Destroy();
  _impl_.os_name_.Destroy();
  _impl_.os_version_.Destroy();
  _impl_.client_id_.Destroy();
}

void DevicesInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DevicesInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.DevicesInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.client_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.browser_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.browser_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.os_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.os_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.client_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.login_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_intel_) -
        reinterpret_cast<char*>(&_impl_.login_time_)) + sizeof(_impl_.is_intel_));
  }
  if (cached_has_bits & 0x00000300u) {
    _impl_.uid_ = 0u;
    _impl_.client_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DevicesInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .PTP.Common.ClientType client_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PTP::Common::ClientType_IsValid(val))) {
            _internal_set_client_type(static_cast<::PTP::Common::ClientType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string client_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_client_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 login_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_login_time(&has_bits);
          _impl_.login_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string browser_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_browser_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string browser_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_browser_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string os_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_os_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string os_version = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool is_intel = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is_intel(&has_bits);
          _impl_.is_intel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 uid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_uid(&has_bits);
          _impl_.uid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string client_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_client_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DevicesInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.DevicesInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .PTP.Common.ClientType client_type = 1;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_client_type(), target);
  }

  // required string client_version = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_client_version(), target);
  }

  // required uint32 login_time = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_login_time(), target);
  }

  // required string browser_name = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_browser_name(), target);
  }

  // required string browser_version = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_browser_version(), target);
  }

  // required string os_name = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_os_name(), target);
  }

  // required string os_version = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_os_version(), target);
  }

  // required bool is_intel = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_is_intel(), target);
  }

  // required uint32 uid = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_uid(), target);
  }

  // required string client_id = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_client_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.DevicesInfo)
  return target;
}

size_t DevicesInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:PTP.Common.DevicesInfo)
  size_t total_size = 0;

  if (_internal_has_client_version()) {
    // required string client_version = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_version());
  }

  if (_internal_has_browser_name()) {
    // required string browser_name = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_browser_name());
  }

  if (_internal_has_browser_version()) {
    // required string browser_version = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_browser_version());
  }

  if (_internal_has_os_name()) {
    // required string os_name = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_os_name());
  }

  if (_internal_has_os_version()) {
    // required string os_version = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_os_version());
  }

  if (_internal_has_client_id()) {
    // required string client_id = 10;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_id());
  }

  if (_internal_has_login_time()) {
    // required uint32 login_time = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_login_time());
  }

  if (_internal_has_is_intel()) {
    // required bool is_intel = 8;
    total_size += 1 + 1;
  }

  if (_internal_has_uid()) {
    // required uint32 uid = 9;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uid());
  }

  if (_internal_has_client_type()) {
    // required .PTP.Common.ClientType client_type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_client_type());
  }

  return total_size;
}
size_t DevicesInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.DevicesInfo)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x000003ff) ^ 0x000003ff) == 0) {  // All required fields are present.
    // required string client_version = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_version());

    // required string browser_name = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_browser_name());

    // required string browser_version = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_browser_version());

    // required string os_name = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_os_name());

    // required string os_version = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_os_version());

    // required string client_id = 10;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_id());

    // required uint32 login_time = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_login_time());

    // required bool is_intel = 8;
    total_size += 1 + 1;

    // required uint32 uid = 9;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uid());

    // required .PTP.Common.ClientType client_type = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_client_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DevicesInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DevicesInfo*>(
      &from));
}

void DevicesInfo::MergeFrom(const DevicesInfo& from) {
  DevicesInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.DevicesInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_client_version(from._internal_client_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_browser_name(from._internal_browser_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_browser_version(from._internal_browser_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_os_name(from._internal_os_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_os_version(from._internal_os_version());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_client_id(from._internal_client_id());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.login_time_ = from._impl_.login_time_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_intel_ = from._impl_.is_intel_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.uid_ = from._impl_.uid_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.client_type_ = from._impl_.client_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DevicesInfo::CopyFrom(const DevicesInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.DevicesInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DevicesInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void DevicesInfo::InternalSwap(DevicesInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_version_, lhs_arena,
      &other->_impl_.client_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.browser_name_, lhs_arena,
      &other->_impl_.browser_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.browser_version_, lhs_arena,
      &other->_impl_.browser_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_name_, lhs_arena,
      &other->_impl_.os_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.os_version_, lhs_arena,
      &other->_impl_.os_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_id_, lhs_arena,
      &other->_impl_.client_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DevicesInfo, _impl_.uid_)
      + sizeof(DevicesInfo::_impl_.uid_)
      - PROTOBUF_FIELD_OFFSET(DevicesInfo, _impl_.login_time_)>(
          reinterpret_cast<char*>(&_impl_.login_time_),
          reinterpret_cast<char*>(&other->_impl_.login_time_));
  swap(_impl_.client_type_, other->_impl_.client_type_);
}

std::string DevicesInfo::GetTypeName() const {
  return "PTP.Common.DevicesInfo";
}


// ===================================================================

class InputPhoneContact::_Internal {
 public:
  using HasBits = decltype(std::declval<InputPhoneContact>()._impl_._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_phone(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_first_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_last_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

InputPhoneContact::InputPhoneContact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.InputPhoneContact)
}
InputPhoneContact::InputPhoneContact(const InputPhoneContact& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  InputPhoneContact* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phone_){}
    , decltype(_impl_.first_name_){}
    , decltype(_impl_.last_name_){}
    , decltype(_impl_.client_id_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.phone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_phone()) {
    _this->_impl_.phone_.Set(from._internal_phone(), 
      _this->GetArenaForAllocation());
  }
  _impl_.first_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_first_name()) {
    _this->_impl_.first_name_.Set(from._internal_first_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.last_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_last_name()) {
    _this->_impl_.last_name_.Set(from._internal_last_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.client_id_ = from._impl_.client_id_;
  // @@protoc_insertion_point(copy_constructor:PTP.Common.InputPhoneContact)
}

inline void InputPhoneContact::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.phone_){}
    , decltype(_impl_.first_name_){}
    , decltype(_impl_.last_name_){}
    , decltype(_impl_.client_id_){uint64_t{0u}}
  };
  _impl_.phone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.first_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.last_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InputPhoneContact::~InputPhoneContact() {
  // @@protoc_insertion_point(destructor:PTP.Common.InputPhoneContact)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InputPhoneContact::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.phone_.Destroy();
  _impl_.first_name_.Destroy();
  _impl_.last_name_.Destroy();
}

void InputPhoneContact::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InputPhoneContact::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.InputPhoneContact)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.phone_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.first_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.last_name_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.client_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* InputPhoneContact::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_id(&has_bits);
          _impl_.client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string phone = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_phone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string first_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_first_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string last_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_last_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InputPhoneContact::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.InputPhoneContact)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint64 client_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_client_id(), target);
  }

  // optional string phone = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_phone(), target);
  }

  // optional string first_name = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_first_name(), target);
  }

  // optional string last_name = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_last_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.InputPhoneContact)
  return target;
}

size_t InputPhoneContact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.InputPhoneContact)
  size_t total_size = 0;

  // required uint64 client_id = 1;
  if (_internal_has_client_id()) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_client_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string phone = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_phone());
    }

    // optional string first_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_first_name());
    }

    // optional string last_name = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_last_name());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InputPhoneContact::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const InputPhoneContact*>(
      &from));
}

void InputPhoneContact::MergeFrom(const InputPhoneContact& from) {
  InputPhoneContact* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.InputPhoneContact)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_phone(from._internal_phone());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_first_name(from._internal_first_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_last_name(from._internal_last_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.client_id_ = from._impl_.client_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InputPhoneContact::CopyFrom(const InputPhoneContact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.InputPhoneContact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputPhoneContact::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void InputPhoneContact::InternalSwap(InputPhoneContact* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.phone_, lhs_arena,
      &other->_impl_.phone_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.first_name_, lhs_arena,
      &other->_impl_.first_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.last_name_, lhs_arena,
      &other->_impl_.last_name_, rhs_arena
  );
  swap(_impl_.client_id_, other->_impl_.client_id_);
}

std::string InputPhoneContact::GetTypeName() const {
  return "PTP.Common.InputPhoneContact";
}


// ===================================================================

class BuddyQueryParam::_Internal {
 public:
};

BuddyQueryParam::BuddyQueryParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:PTP.Common.BuddyQueryParam)
}
BuddyQueryParam::BuddyQueryParam(const BuddyQueryParam& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  BuddyQueryParam* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.addresslist_){from._impl_.addresslist_}
    , decltype(_impl_.usernamelist_){from._impl_.usernamelist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:PTP.Common.BuddyQueryParam)
}

inline void BuddyQueryParam::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.addresslist_){arena}
    , decltype(_impl_.usernamelist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BuddyQueryParam::~BuddyQueryParam() {
  // @@protoc_insertion_point(destructor:PTP.Common.BuddyQueryParam)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BuddyQueryParam::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.addresslist_.~RepeatedPtrField();
  _impl_.usernamelist_.~RepeatedPtrField();
}

void BuddyQueryParam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BuddyQueryParam::Clear() {
// @@protoc_insertion_point(message_clear_start:PTP.Common.BuddyQueryParam)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.addresslist_.Clear();
  _impl_.usernamelist_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BuddyQueryParam::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string addressList = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_addresslist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string usernameList = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_usernamelist();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BuddyQueryParam::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PTP.Common.BuddyQueryParam)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string addressList = 1;
  for (int i = 0, n = this->_internal_addresslist_size(); i < n; i++) {
    const auto& s = this->_internal_addresslist(i);
    target = stream->WriteString(1, s, target);
  }

  // repeated string usernameList = 2;
  for (int i = 0, n = this->_internal_usernamelist_size(); i < n; i++) {
    const auto& s = this->_internal_usernamelist(i);
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PTP.Common.BuddyQueryParam)
  return target;
}

size_t BuddyQueryParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PTP.Common.BuddyQueryParam)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string addressList = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.addresslist_.size());
  for (int i = 0, n = _impl_.addresslist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.addresslist_.Get(i));
  }

  // repeated string usernameList = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.usernamelist_.size());
  for (int i = 0, n = _impl_.usernamelist_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.usernamelist_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BuddyQueryParam::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BuddyQueryParam*>(
      &from));
}

void BuddyQueryParam::MergeFrom(const BuddyQueryParam& from) {
  BuddyQueryParam* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:PTP.Common.BuddyQueryParam)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.addresslist_.MergeFrom(from._impl_.addresslist_);
  _this->_impl_.usernamelist_.MergeFrom(from._impl_.usernamelist_);
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BuddyQueryParam::CopyFrom(const BuddyQueryParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PTP.Common.BuddyQueryParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuddyQueryParam::IsInitialized() const {
  return true;
}

void BuddyQueryParam::InternalSwap(BuddyQueryParam* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.addresslist_.InternalSwap(&other->_impl_.addresslist_);
  _impl_.usernamelist_.InternalSwap(&other->_impl_.usernamelist_);
}

std::string BuddyQueryParam::GetTypeName() const {
  return "PTP.Common.BuddyQueryParam";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Common
}  // namespace PTP
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::PTP::Common::IpAddress*
Arena::CreateMaybeMessage< ::PTP::Common::IpAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::IpAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Common::UserInfo*
Arena::CreateMaybeMessage< ::PTP::Common::UserInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::UserInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Common::UserStatInfo*
Arena::CreateMaybeMessage< ::PTP::Common::UserStatInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::UserStatInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Common::MsgInfoList*
Arena::CreateMaybeMessage< ::PTP::Common::MsgInfoList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::MsgInfoList >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Common::GroupMember*
Arena::CreateMaybeMessage< ::PTP::Common::GroupMember >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::GroupMember >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Common::GroupRecord*
Arena::CreateMaybeMessage< ::PTP::Common::GroupRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::GroupRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Common::GroupInfo*
Arena::CreateMaybeMessage< ::PTP::Common::GroupInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::GroupInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Common::MsgInfo*
Arena::CreateMaybeMessage< ::PTP::Common::MsgInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::MsgInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Common::DevicesInfo*
Arena::CreateMaybeMessage< ::PTP::Common::DevicesInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::DevicesInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Common::InputPhoneContact*
Arena::CreateMaybeMessage< ::PTP::Common::InputPhoneContact >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::InputPhoneContact >(arena);
}
template<> PROTOBUF_NOINLINE ::PTP::Common::BuddyQueryParam*
Arena::CreateMaybeMessage< ::PTP::Common::BuddyQueryParam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PTP::Common::BuddyQueryParam >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
